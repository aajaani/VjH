 Tänase loingu teema on siis webi-teenused. Järgmine nädal me jätkame webi-teenuste teemadega ja räägime sellistest webi-teenuste standaarditest nagu Open App ja Swagger ja mõned ka Soop standaardid. Aga täna räägime pikem, mis asjad on üldse webi-teenused. Räägime, mis on Soop protokoll ja räägime, mis on HTTP protokoll. Nii, natuke räägime ka REST spetsifikatsioonist, mis on selline välja pakutud standaarditest viis, kuidas HTTP appisid kasutada. Kuna HTTP protokoll ise võimalda väga palju erinele viise kasutada, siis REST oli selline viis, kuidas proovida, siis natuke standaardiseerida, kuidas neid appi meetodid välja kutsuda. Varasemast praktikumis olemme rääkinud Soop liuendustest, olemme rääkinud sõnumite vahetusest, olemme rääkinud sõnumite järekordadest ja RPC-st. Täna võtamegi viimase teema, mis on seadud nende suhtlusviisidega, kui ikka järgmikord natukene katame veel webi-teenuste, aga siis lähme juba ka pilve-teenuste poole nad küle. Täna rääkime siis, mis on HTTP ja Soop ja rääkime, mis on REST spetsifikatsioon, et mis on erinevus HTTP ja RESTi vahel, et kui keegi teile räägib REST-appist vahe vahe. Alustame webi-teenuste ülevaateste ja siis lähme nende protokollide juurda. Et mis on üldse webi-teenuse, et kui te täna päeval kasutat VVV-d, World Wide Webi, webi üldiselt siis teie browser läheb kuskile mingisuguse serveri hostneemile ja mingisugusele adressi selle hostneemijalle, mingislash appi, slash raamatud näiteks, ja kutsub välja seal HTTP metodi, et teha ketpäring ja mingisugune resursse alla tõmata. Et webi-teenuste ta valis on alati mingisugun resurss. Browseri puul see võib olla siis HTML-fail koos mingi JavaScript-failiga või siis mingi PILDI-fail, või siis mingi TEXTI-fail, või siis mingit muud tüüpi resursset. Tavalaselt me räägime mingitest resurssidest, mida ülerendi webi-appide siis alla tõmatakse ja teie browseris siis näitab teile, kui te browseri kasutajate olete. Aga vnb-teenuste on natuke üldisemad. Idee on, et kui meil on nii laialtane protokoll kasutuses, et kõik maailma arvutid ja browserid kasutavad samu webi protokolle, miks mitte neid protokolle kasutada, aga siis üks kõik milliste operatsioonide välja kutsumiseks olgu need siis teie poolt, kui te lähete Google Translate lehele ja soovite ingliskeese tegsti ja estigeese tegsti tõlkida, et te lähete browseris, kirjutada sinna teksti sisse ja kutsud selle välja saate tulemuse kätte, või siis te teete pyütun rakenduse, mis vaatab, kus asub Google Translate appi ja teab täpselt sama protsesi läbi, et välja kutsuda siis Google Translate metood üle webi ja täpselt samu protokolle kasutades, kui see lähene minu natuke teine ja seal tulab ka autentida, kui teie rakenduse hakkab Google Translatei välja kutsuma, aga põhimusalt täpselt samade protokolle te vii põhjal on võimalika siis teie püüten rakenduse Google Translatei välja kutsuda. Või siis te teete ise, panate üles mingi eestigels põlkimise appi ühe hajussüsteemi komponentina ja teises komponentist kasutate täpselt sama viisi Http appid, näiteks, et selle teise hajussüsteemi komponenti funktsiooni välja kutsuda ja te kasutate täpselt sama appid, või sama protokolle, mida kasutad teie browser, või siis see püüteni programaks kasutanud, või siis hajussüsteemide komponent ka kasutab täpselt sama protokolle. Ja kui nüüd sellised hajussüsteemid, appid, webi teenused samamoodi ülesheita, siis nad on kõik oma vahel ülduvad. Et siis saabki lihtsast ehitada selliseid komponente, mis on võimalsed teiste komponentide metodeid välja kutsuma, et me ei pea nii väga nagu uurima, et mis sellised protokolle nad toetavad, või me saamegi sellised webi protokolle välja kutsuda. Aga selline ingliskeene definitsioon on, et webi teenused on siis loosely coupled, web services are loosely coupled, standard based reusable software components that systematically encapsulate some discrete functionality and are distributed and programmatically accessible over the standard internet protocols. Et ei peaks mingit erilisi protokolle nendele jaoks välja kutsuma ja tähnapäev väga suur osa webi sasuvatest teenustest, kuskil mingisuguse targvara poolt pakutavad teenused ongi webi apud ja poolt välja kutsutavad. Jah. Jah. Jah, et suvalised webi lehed samuti serveerivad resursse ülesamada protokolle, hattateb ja hattateb essi ja tänapäeval kõik ongi sul pikem nagu webi teenuste peale ülesehtudud. Võib-pal, see vahe on see, et kui see tavalne web on mõeldud HTML lehteda või allatõmvamiseks ja näitamiseks, aga mina tahan nüüd mingis serveres mingisuguse meetodi välja kutsuda, et ta hakkaks piltetöötlema või et ta saadaks mingi alarmi või midagi. Et enam ei ole selleks, et ma soovin mingid webi lehte vaadata või mingisugust ma pikem soovin nüüd täiesti mitte webis oleva kahe komponendi vahel mingisugust meetodi välja kutsuda, et näiteks ma soovin pilves uut virtuaalmasinad luua, ma saan täpselt sama protokolli kasutada, et pilvega 11 võtta ja jäälda talle, et halosta mulle loomul uus virtuaalmasin. Aga ma kasutan täpselt sama protokolli, mida ma kasutaks kuskil HTML lehel läbi vormi uue sõnumis isestamist kuskil foorumisse. Et see protokoll on täpselt sama. Kuigi ma ei soovin mingid webi and-mate muuta, ma pikem soovin, et Amazonis uus virtuaalmasin käivitataks. Et saan asjad protokollid. Mis on vahe webil ja nendel webi teenustel? Et ongi, on tarkvaratenused, mis kasutavad World Wide Webi protokolle. Aga see tarkvaratenus võib üldse mitte webiga olla seotud. Aga tihtin, et webi teenused, neid näheks ikkagi, et nad on webis kätte saadav, kuna tegelikult ma saaksin kas webi browseri või postmaniga minna ja vaadata, et mis on hetkel jooksad virtuaalmasinad. Et ma saaks minna browseriga vaadata, et mis on Amazonis mulle jooksad virtuaalmasinad, et kui seal on toetatud sama ketparing, millega ma mingid webilehti alla tõmban, siis ma saaks samav ketparing ka listida näiteks jooksvaid mingid resursse või Amazoni webiservery. Mane teised näiteks, et me saame, kas läbi browseri üleslaadida mingi pildi, et seda väiksemaks konverteerida või me saame oma appi kaudu või oma tarkvarakaudu näiteks pyytu niist väljakutsuda siis selle pictures.com taostal oleva webi teenuse. Või see redditid, et me saame browseri kaudu redditeese sõnumid, panne sõnumid listida, aga me võime ka otse kasutada nende webi appisid, et seda programmatiliselt teha meie programmis ja ehitada näiteks mingi mobiilirakenduse, mis ise nagu listib neid redditi poste, mida meie kasut on teinud. Kui tänapäeval on minnaks see selles suunas, et need webi appisid limiteeritakse, et limiteerida, kui palju võib üks kasutada näiteks mingisugust pärin, kui redditi vastu jooksutada, et reddit tahab hakkata rahaküsima selleks, kui mingisugused teised firmaad tohutud palju redditi appid kasutavad näiteks selleks, et allatõmata mingeid tekst, et õppetada oma masinope mudeleid või suur keele mudeleid, et siis hakkati nagu järjest kinni keel, et meie webi appisid ei oleks nüüd nii lahtised enam. Põhjemist panaks see neile limitid peale. Ja webi teenuste omadused ongi siis, et nad toetavad täpselt samu protokolle, mida ajaloolised kasutati webis, esimeste webi süsteemide loomiseks. Nii, et meil on mingisugune server, mis serveerib mingisuguseid resursse või võtab vastu mingisuguseid operatsioone üle samade protokollide, ja siis klient ühendub sinna serveris ja kutsub selle serveri mehedoteid välja. Põhimõttel samasugune mude nagu RPC-el. Webi teenuseid saab lihtsalt kasutada rakenduse webi liidese ja taga teenuse vahel, et meil on JavaScript rakendus, mis jookseb kasutaja brousseris. Küll esimest kord, kui me läme mingile webi rakendusaadra, siis tõmadaks JavaScript alla, hatemel alla käivitadakse, aga selleks, et mingi tünamlist infod kätte saada, siis webi teenus, mis jookseb JavaScriptina, siis tõmbab kuskilt appi kaudu teisei anmed alla. Kasutajapraeguseid anmed ühendub kuskil taga liidese appisse ja tõmbab kasutajanmed alla. Aga samamoodi võib neid samu webi teenuste protokolle kasutada ka mikro teenuste vahel või hajussüsteemide komponentide vahel selleks, et meil oleks täpselt samasugune standardne liides, et me ei peaks mäliste klentide ja esiliidese vahel kasutama HTTP-ed ja siis me peaksime oma mingi hajussüsteemide komponentide vahel kasutama teisi liidesed. Tegelikult on võimalik hajussüsteemid ja mikro teenused ülessehita nima, et kõik kasutavad neid webi protokolle. Kuigi täna päeval see ei prugi kõike efektiivsem olla, et näiteks on tihti efektiivsem kasutada mingi teise protokolle nagu gRPC-ed näiteks, et efektiivsemalt suhelda hajussüsteemide komponentide vahel, aga sellest räägime võibolla tuleviku looingutus. Ja miks webi teenused on nagu populaarseks sanud, et see võimalitab sellist erinevalt ehitatud teenuste oma vahelist koostööd, et meil on täelik platformi neutraalsus, et kui me loome rakendused, mis räägivad näite HTTP-ed protokolle, et siis siia olla vahel, et mis keeles nad on implementeeritud, me saame nad oma vahel rääkima panna üksteise meetodeid välja kutsuma panna ja see võimalitab lihtsasti teha nad täiesti programeerimes keeles sõltumatuks, et kui meil jahk jahva ja püüt on oma vahel vahetavad jason sõnumeid läbi HTTP, siis tegelikult ei ole vahet, mis parsjad kasutatakse ja püüt on itse ja mis parsjad kasutatakse jahvalt, et tulemus on ikkagi täpselt sama sugunne. Me saame siis neid appisid välja kutsuta, kas synkroonsalt või asynkroonsalt, et kui meil on vaja näiteks hästi palju anmeid üleslaadida, siis me ei pea ootel jääma, et kas me... kas pilt laeti üles ära ja siis hakkame järgmist pilt üleslaadima või ma asynkroonsalt näiteks 10 pilti samaheikselt üleslaadida erinades lõimedest. Saame näiteks läbi lõimed ja kasutada neid appisid asynkroonsalt või siis, et ei jäägi ootama või... et saab siis nii asynkroonsalt, kui sinkroonsalt kasutada. Ja tavastame kasutama sellist klentserver mudelid. Server on see, kes siis implementeerib, mis operatsioonid on ja mis resursid on serveritud ja mis operatsioonid nende resurside peal võib välja kutsuda. Ja server pakub mingisugust teenust ja meie saame teha päringuid või saata rekveste sina serverisse, et midagi küsida. Ja... Üldjuhul, see on natuke erinev sõnumid nende järekordade systemist, et klents ja server peavad suhtlemise aale olema aktiivselt, et meil ei saa... klient ei saa serverisse, on meid saata, kui server samal ajal ei ole aktiivne. Ja kui meil on synkroone, siis klentavased ka blokkeerib, kuni ta saab vastusa. Ja serveri loogik on tavalselt suhtselt lihtne, et ootab mingid sisse tulaid päringud ja sehera töötleb ja vastab nendale, et alati saab ehitada palju keerulisemad süsteeme, mis töötavad sellise, kui ta saan, lüüsina hajussüsteemi ja klentide vahel. Ja see tarkku ära, mis esimised päringud vastu, ota peale tegelikult see, mis anmeid töötleb ja töötlevad võib olla mingisugused teised komponentid hajussüsteemis, aga see lihtne lähene minna on server lihtsalt võtab päringud vastu, töötleb need ja vastab nendale ja kõik, et ehitada sellised lihtsad lahendusi. Server ja klendisuhtlus saab lihtsalt visualiseerida niimoodi, et klent saadab päringud ja server vastab nendale, see ongi selline request-response model, kus on klendi ja serveri vahel suhtlus. Aga meil võib olla siis neid lähenemisi tavalselt mitu, et tihti on, et meil ei piisa lihtsalt mingisugust ühes monoliitsest rakenduses, kes tegeleb kõike kärad, meil on vaja anmebaasi, meil on vaja siis mingisugust teisi, võib-olla me tahamad serverid skaleeridesi, meil on vaja ka mingisugust sisse tuleva liikluse jaoturid, et tavaliselt, kui just meil ei ole hästi lihtne rakendus, siis me ei kasuta sellised ühetasemile arhietuse. Kui meil on kõik arhitektuur, et meil on ainult klent või server, vaid meil on kas kahe-kolme või sike endasemised arhitektuurid, et selle aseme, et meil on monoliitne server, me paneme anmebaasi erinevasse virtuaalmasinasse või erinevasse asukohta, siis meil tekib selline kahetasemile kiht või siis meil võib-olla ka kolmekasemile kiht, et meil on eraldi frontend mingisugune Javascript HTML põhine lahendumist avaselt jookseb klendi enda arvutis, et kui klenti esimiskorda server raadus läheb, tõmateks alla Javascript-aadiselt arvutis, ja Javascript, ja see käivitub tägelikult klendi arvutis, see on väga hea, et vähendada serveri koormust, et näiteks kõik kaardipõised rakendused nagu Google Maps'i sellised, töötavad pigem tagud klendi arvutis Javascriptina selleks, et mitte koormad üle serverid, siis on tägelikult väga efektiivne viis, kui tähes kasutada klentide arvutide jõudlust ära selleks, mingi tarkkora sellase mõel, et see server peaks kõike renderdama serveri pool ja saadma need anmed. Et siis meil tekeki selline kolmetasemne archituur, et meil on klient, klienti arutis võib-olla mingi front-end, front-end suhtle back-endiga, nii et meil peab serveris mingi tarkkora olema ja siis eraldiga anmebaas, et meil siis ongi tekivad sellised kihilised süsteemid, kus tõmataks alla näiteks mingi Angular Vue, raamistiku Javascripti ja siin onksutatakse klienti arutis, azee oma korda suhtleb näiteks HTTP ka protokolliga siis rakendusserveri back-endingane, mis on võib-olla implementeeritud kas mingis Python Flask raamistikus PHPs või Node.js'is ja siis pärast seda meie rakendusserver ühendub siis anmebaasiga, mis on oma korda näiteks mingis teises virtuaalmasinas, mis suhtleb siis selle rakenduse ja anmebaasi vahel näiteks kasutatakse SQL, et Structured Query Language protokollis siis pärin kuid teha anmebaasi ja seal on mingi Postgres näiteks või MySQL või Misiganas. Jah. Pärast. Seda see neid on nagu meil on tehtud? Pike me ei pead, nagu hea hea praktis hea hea lähenemine on, et ei sai peagi meeles, et sa põhimõttelselt, kui sul tuleb siit hästi palju klientte, siis sa paned siia ühekii veel vahele, et sul see frontend jooksab kasutavarvutis, kasutavarvuti võtab ühendust nagu hostnameiga, mille taga on siis need serverid, aga siia tekib siis jõudlusejaotur või sellne load balancer näiteks seda siin on konfigureeritud, et mis on need serveri adressid, apide serveri adressid ja sul tekib appi serveritas 16 koopjad ja see vahe pealne jõudlusejaotur siis valib nende 16 serveri seast, et kui tuleb ühel klendi päring, et millisele 16 serverist siis päring edasi suunata ja siis tekjad küsimused, et kas ma tahan, et minu rakendusa serverappi hoiaks midagi meeles, kasutajahelmise päringu kohta või mitte, kui ma ei pea meeles oledma, see on hästi lihtne, ma lihtsalt suunan üks kõik millises sellesse 16-sest serverist. Kasutajaga tuleb kaasa kasutajad või mingisugune kasutasessioon või kypsis ja seal kypsises on tavalist infot, mis kasutajaga on tegu ja server kontrollib üle, et see kasutaj on autenditud, tal on õige, et mingisuguse turva taukenid ja kasutajad ei tee põhjal, mis tuleb selle päringu kaasa, selle põhjal siis se server töötlab seda rekwesti ja näiteks paneb või võtab kasutajad anmebaasist ja iga kord, kui tuleb uus rekwest, siis server võtab anmebaasist selle kasutajad anme ja teeb sellega midagi. Mul on kaks slide selle kohta ka, et kas on efektiivne, kui ei hoita meeles kasutajelmise päringute infot, kui meeles hoitakse, siis saab ka siin koormuse auturis või loot balancerist teha sellist sticki ümbersuunamist, et kui tuleb kasutaja IT-värtusega mingisugus konkreetse IT-värtuskanmed, siis meil on seene loogika, mis tavaselt on eteks hashide põhjal, et kasutaja IT hashitud mingisugus algoritmiga selle põhjal jagatakse samalt kasutajalt tulnud päringut alati esimeses serverisse, et lihtsalt hoolistuks sellest, et suunatakse alati sama kasutaja anmed samassa serverisse, et siis on võimalik sellist sessiooni info või stateful töötlus ka teha, et jätta meelde, aga põhimist ja siia panaks see veel üks kicht vahele ja jagatakse need päringut, sisse tullad päringut paljude appi serverite vahele ära. Ja seda me, ma pole kindel, kas me selles ainees vaatame, aga ma räägin selle kohtaga pilvetehnoloogia loengus täpselmalt, et kudas seal pilvetehnoloogisse skaleerimine käib ja nende sisse tulevat päringute jaotumine, paraleliselt töötavate replitseeritud rakenduse koopjate vahel käib. Jah aga to oli natuke keeruisem sisteemed, pikem võib-olla lihtsam, kudas sinul on võimalik luua oma appi rakendus näiteks pyütan flaskis, nagu me praktikumis sisse teeme ja siis tockeris saada seada üles kaks koopjad, sellest kaks tockeri konteinerid ja nende vahel liiklus illust ära jagad, et see on isegi tockeris, see tänab on sisse ehitetud, et see saad niimoodi liiklust jagada mitme tockeri konteineri vahel ära ja kui sa tead tockeris vormis, siis need konteinerid võib-olla olema viis serveris. Et natuke lihtsam läheneme, et lihtsalte tekitame appist mitu koopjad ja jagame sisse tulevad päringut nende vahel ära. Jah aga seal on väga väga aga, et see peamine muster, kudas Postgres nagu paraliseeriteks, see on niimoodi, et sa sead üles ühe peamise serveri ja tema on nagu see right server, et kuhu suunateks kõik right päringud ja sa sead samal ajal üles näiteks nelideist read koopjad ja hoolid seda taustal, et kõik right päringud synkroniseeriteks read koopjadele ja siis sa saad paraleliselt 15 serveris luge tanmeid, aga sa suunad kõik kirjutamised samasse ühteservesse, et see on kõige tavalisem muster, kudas Postgres kasutada saad hästi hea sellise lugemise jõudluse ja kirjutamise jõudluse paraliseerimiseks on palju palju keerulisem Postgres puhul. Ja me räägime ka ühe sannebaaside või piljotehnoloogil looängus natuke sellest, et mis on need alternatiivset, mis oskaad paremini neid kirjutamisega ära paraliseerida. Et ja, et sul on võimalik mõnesmitte see on kõik paraliseeritud, sest see ei avaskeleb jookse kõik, et kõik ka kasutavate arvutite vahel ära, et ta ei ainult tõmatakse põhimised JavaScript alla ja Hatemel alla ja kõik resursid alla. Rakendust seda saab siis paraliseerida ja anmebaside paraliseerimin on natuke keerulisem teema. Selle teutud ihti Postgres SQL ja asemel sa kasutad näiteks mingit Amazon SQL teenust, mis ise oskap sisemiselta asjad ära skaleerida, et siis saab ise selle pärast nii väga muratsamad. Siis olemegi natuke tagasi selle küsimuse juurde, et kas teha synkroonsed suhtlust ja asumkroonsed suhtlust. Synkroonsed suhtluse puhul klientid jäävad ootale, kui nii nad saavad mingisuguse tulemese tagasi jätkuvad ja asumkroonsed suhtluse puhul nagu täpselt esimeses praktiku, mis saaks klient lihtsalt teha lõimed ja erineate lõimed ja ka põhimõtteliselt kutsuda välja erinead HTTP metodid näiteks või API metodid, et sellise juhu nagu anmete saad, mist või kuulamist ei blokkeerita, aga saab teiste tegevuste jätkata. Ja tihti nende see webi apides on sisse heitatud asumkroonsus, et iga kord, kui tulla puhus päring, siis tekitatakse lõim näiteks või panakse päring tööde järjekorda ja siis töödel takkse lõimedega sehära, et oleks kaljeerivam, et ei tekikse seda probleeme, et on ahjad üks töötleja, kes sellega tegeleb, vaid näiteks fast API python rammistike puhus ja python rammistike puhus on hästi tavalne, et iga sisse tulla päring, kui jaoks genereeritakse eralte lõimed, kes tegeleb selle töötlusega. Ja ühendustega ühenduste protokollide ja se serverite puhul on tegelikult atuke keeruline teema, kui te seda hästi seletada, sest üks asi on ühendusega protokollid ise näiteks TCP, kus luaks see kahe osapool sokkalite vahel ühendus, ja selle ühenduse kaudu saab saata pakette, aga meil on ka ühenduseta protokollid näiteks UDP, kus me ei peagi sellist sokkalite otsaselt looma, või tegelikult me peame sokkalite vahel sellise defineerima saatmise, aga me ei peasi püsivad ühendust defineerima, et me peame saata pakette. See võimalda veel rohkem saata on meid ilma, et me peaksime iga uue saatja asu. Sa paketite saaja koku lepima, et me teeme ühenduse, et me saame UDP protokolliga näiteks lihtsalt saata pakette ja saata pakete paljudel adresile korraga või kõikidele hetkel lokaasusvõrgus olevatele seatmetele ilma, et me saame kõikidele nende adresi ja teame, et saame sellist broadcast ja multi-casti teha. Aga ühendusega protokollide puhul on suhtus natuke ebaefektiivsemsest, me peame kõigepealt ühenduse looma ja siis kõik järgmise paketid peavad olema seotud juba tehtud ühendusega, et me peame koku lepima, et see server peab ühenduse vastu võtma ja siis me saame selle ühendusega seotud pakette saata teise otspunkti. Ja mitme partneriga, et kui me kahe serveriga või kahe appiga sama aegis, et ta on ühenduses, peab iga ühe jaoks ühendus olema. Ja samamoodi võib vada, et serveri poolt, et selleks, et TCP protokolli kasutav server paketesaks võtta, siis tal on vaja tegelikult vähemalt ajutiselt luua ühendus ja seda ühendus lahtioida kõigi sisse tulevate klintidega. Aga see võimalda siis meil saata pakete niimoodi, et me saame jagada ühe suure file näiteks, mis üleslaadaks tükkideks ja meil tekib selleks ühenduse raamese paketide saamises paketide õige järjekord, et me panevame selleks pildi niimoodi õiges järjekordust takas kokku, mida UDP puhul on palju keeralsam teha. Ja teine, mida ma mainisin, olisi olekutepõhjised protokollid ja olekutepõhjised serverid, et meil on efektiivse teha kogu sellist ühest appist paljude koopjate, replitseeritud koopjate loomist ja nende vahel liiklus ära jagamist, et kui ükski server ei pea midagi meeld jätma eelmise päringukohta, mida sama kasuta tegi, et meil ei tegi seda vajadest, et me peame alati kasuta saatma täpselt samasse serverisse, et ühelt kasutat tulevad kolm päringud, nad võivad siis olla suvalistesse serveritesse minna meie rakandust töötab ja ei tegi mingiselt probleeme, et see tihti selle eelis on see, et meil ei ole vaja hoolitseda selle äest, et kas üks server saab hakkama kõigi klientidega, kelle päringud peaksid nendele olema alaku eritud, et me saame lihtsalt reaal ajas otsustada ümber, et või ästi labaselt või lihtsalt jagada neid päringud kõikide serverite vahel võrtsalt ära, ilma, et me peaksime arvesse võtma, et võib-olla üks kasutal, seal tuleb 10x rohkem päringud kui teised kasutalt ja kuidas me neid kasutad nende serverite vahel ära jagama, et sellisega asja ka ei pea tegelema. Aga olekult põhised serverid ja protokollid on sellised, et näiteks FTP serveri protokoll on selline, mis protokollis korraks autenditeks kasuta ära ja pärast seda saab kasuta saata nagu päringud, serverilma, et peaks mingisest kontrolli tegema, et kas kasutada. Ja no, autenditud, kas kasutala, on õigusi midagi saata, et saab teha sellise natuke efektiivsema lähenemise, et ei pea nagu igakord ülekontrollima, näiteks kas kasutaja võtgi on, kas kasutale on lubatud midagi teha, et seostatakse kõik sama ühenduseks jäutad asjad. Et server põhvist jätab meeld, et sellel kasutal oli õigus seda kasutada ja siis kasutas adab uue päringu, näiteks uue mingit failide listimise, et FTP on siis nagu file transfer protokoll, et serverist file aladamad üleslaadida, et siis saab natuke efektiivsem suhtlus, kui sama klienter tohutub palju päringud ja me ei pea igakord kontrolli, et kas näiteks appi päringu tegi ala on õigus, kas appi võiti on korrekte, et see on mõnesvõttes võib olla efektiivsem. Et nende jõudlus võib olla selline parem, kui mitte ole kui põhist servete puhul. Ja tihti, et miks me üldse seda teeme, et üks ongi see, et me tahame, et me tegaks meeldie jäted, et selle kasutale on õigus meie rakendust kasutada, samuti võib see FTP server meeldie jäted näiteks, mis failid on avatud, et kui kasutaj hiljuti mingist faili muutis, siis ta saab selle faili pideme lahti jäta Linuxis, et tal on efektiivsem seda faili uuesti avad, siin uuesti kirutada, et kui kasutaj näiteks sama faili uuest laeb, siis server ei pea uuest seda faili lahti, aga võib selle faili lahti jäta ja võib igasugus klendiga seotud info, nagu oma vahe mällu salvestada või mällu salvestada, et see oleks efektiivsem, et server ei pea uuesti otsima klendi anmeid anmebaasist näiteks. Aga selle suur probleem on just töökindlus ja skaleeritavus, et kui meil on hästi palju klente, kui palju mällu, siis selle klendite elmiste päringute kohta server peaks siis meeldie jätma ja see võib tekitada väga suure probleemi just törketa aluusega, et kui server kokku kasvus, me kaotame iguni kogu mällu, kui millegi tõttu suunatakse klendi päringut ühte teise serverse nüüd, siis jälle on see kõik kadund ja skaleeritavus on palju suurem probleem, sest me peame kui kudagi ka balanseerima seda, et kui palju servered haldavad, kui palju hetkel aktiivse klente, sest me ei saa lihtsalt nüüd klente teise serveri peale saata, et meil on efektiisem, et kui need peab samase serverse suunatakse. Aga olekute serverid, need ongi paremad sellise hästi skaleeritavad systeemide puhul ja nende ehitamiseks ja see on tänapäeval muutunud selliseks de facto standaardiks, et pigem kasutada oleku vabasid lahendusi ja protokolle, et näiteks, saadad, et peabapid on ka ülesseidadud niimoodi, et tegelikult nade ei tohiks meelda jäta midagi klendiiga seotud, et igakord kasuta tegelikult peab uuesti autentima, et näiteks heederis uuesti saadma appi võtme, heederis uuesti saadma appi päringuga, põhimselt kaasa saadmas lappi touken igakord, kui see suhtlust käib ja igakord autentitaks, siis kasuta uuesti ära. Ja et designitakse näite appid ja lahendused niimoodi, et nende ei jäta mitte midagi klendiipolt meelda, et ei salvestada siis mällu klendi info, et ei salvestada, kas failid on mingi tavatud, ei jäeta meeles, kas klend oli autentitud või mitte ja pigem kasutatakse näiteks klendi polsad sessioone, mis panakse kaasa siis päringutega mingiselt küpsised või appi toukenid ja sellega, et vältida näiteks, et see server peab ise anmebase, et nende alla tõmbama. Ja kui server soovib mingisugust anme, et salvestada klendi kohta, siis kõik läheb anmevaasi, et ta läheb väljas poole seda rakendust ennast, et ei jäeta rakenduse ja prozesimällu infot sisse tuleva päringu kohta. Ja kui klend koku jookseb, kui server koku jookseb, siis sellest mitte midagi juhtus, sest kõik meil ei olegi midagi mälus, midagi klendiipolt oli mälus, aga põhimest kokuse suhtus on üles ehitetud sellele, et me ei pea midagi meelda jätma, et päringute tegemine töötab niimoodi, aga me ei pea midagi meelda jätma. Ja sellest, et on ka hästi lihtne seda skaleerida, sest me võime lihtsalt suvaliselt sisse tulevat päringut, suvaliste serverite, saata suvaliste serverite vahele ära jagada, et sisse tulevate päringute balanceerimine, see on hästi lihtne, et meil ei olegi mingid tarkkus sisse vaja, loogikat sinna sisse vaja heitada. Aga lähme siis pigem nende protokollidi juurde, kõigevalt ma räägin soapist, mis on selle keerulline ja hästi mõnesmates ka tüütu protokoll, kuna need sõnumid on hästi suure, et mida saadetakse ja tohutab palju sellist mitte vaelik. No mõnesmates vajaliku, aga kasutale mitte vajaliku infot on selli juures, sest kasutatakse sellised x-emeljad dokumente. Et see oli siis selline sõnumi protokoll, ta 1998. aastat, et saada struktureeritud anmed siis selliste webi teenuste vahel, seda siia maani kasutatakse näiteks Eesti XT's, et kui te lähete tööle mingisse firmasse, mis tegeleb Eesti XT ka ja sõnumid vahetusega, siis XT on liikumas soapi pealt, HDTP arresti peal, aga väga paljud vanad asjad võib aga ikkagi soap protokolli peal töötada. Ja idee on, et see oleks siis täiesti platformist ja sõltumatu viis, kuidas välja kutsuda mingisuguseid ARP-C tüüpillisi operatsioone üle webi teenuste protokollid nagu HDTP ja sõnumid saadatakse XML-dokumentid, kuna XML on selline masin loetavad, kus dokument ise kirjalda päramis on dokumentisees. Piisab ainult sellest XML-dokumentist endast, et aru saada, mis infos on dokumentisees. Et see ise selgitav anme struktuur, kus anme tüüpid on tehti linkid enne kasas, et näiteks, kui me tegeleme mingisuguse Eesti riigi teenuse XML-dokumentiga, et seal eksisteerib link, mille kaudu saab allatõmata selle teenuse spetsifikatsiooni, et mida näid väärtused sellel XML-iseest tähendavad ja mis seal lubaadud nimed ja kuidas õieti parsid XML-dokumenti ja mis väärtused seal võivad olla ja või olla, et seal kõik vaelik info on mõnesmõttes XML-dokumentis olemas või vähelalt linkitud. Samas on probleemid sõnumide suurusega, et ei saa väga suuri sõnumid saata, et ei ole väga hästi toetadud pinaarse tanmetse saatmine, kuna XML-ise on tekst, ta on teksti dokument ja kui me soovime näiteks mingi pilti saata läbi XML-dokumenti, mis me tavasalt teeme on see, et me võtame pilti pinaarse tanmet, me tekitame pinaarse jada ja siis enkoodime selle Base64 algoritme abil niimoodi, et ta on string karakterid, ükski ei, põhimiseid ei tegei, nende see ole mingist karakterid, mis teeks mingisuguse XML-i või JSON-i parsimise katki. Ja siis me võtame selle Base64 enkooditud stringi ja paneme selle üheks väärtuseks sinna XML-dokumenti sisse, aga tihti see tähendab, et seal suure pildiaks hoidad olla tohutult suured stringi jadad dokumenti sees, mis hoidad olla suuremult, kui see originaalne pinaarna pilt ja näit fileid isemuutub hästi suureks. Ja HTTP ise toetab saama moodi HTTP protokollile, millest me räägime natuke iljem, aga seda võib ka kasutada teiste protokollidega lihtsalt. HTTP protokoll, et kuidas siis klient ja server oma vahel anmeid ja sõnumid edastavad, on osutunud nagu sellises kõige populaarsemaks, aga tegelikult sõup ei ole HTTP speciifiline, et ta pigem speciifiseeri pärad, mis on need sõnumid, mida saadetakse XML-dokumendid, et kui mingi teise protokolliga sa pigem XML-dokumenda saata, siis see toetab saama moodi. Mis sõupilts on, on simple object access protocol, et kuidas mingi tobekste vahetada nende anmeid allatömata või põhimõtteliselt pigem on ta selline RPC's arna, kudas mingisugust metodid välja kutsuda. Aga selline naljakas kirjeldus võib-pal on, et see, mis laseb Java ja .NET komponentid, et on omavahel suhel, et kudas alguses pandises erinevad selle progameerimiskeeles kirjutatud teenust omavahel rääkima, et kuidas vahetada siis anmeid erinevate skeeles, erinevas platformides kirjutatud tarkkura komponentide või haussisteemide komponentide või webi teenust vahel. Et transporti protokolli on erinevaid, HTTP on üks kõige populaarsemaid, kõik päringudiv vastusad on XML struktuuris ja see, mida need XML-sees olevad sellised tagit tähendavad, on tavaliselt skeemadega defineeritud, kus skeemad on linkitud dokumentid, mille sees on defineeritud. Et kui mul on XML-i sees kirjas näiteks person, siis mida see person tähendab, mis väljataks, et person obekti sees olema, mis tüüpinad on, et anme basis skeemad tohjentsud sama muudi, et anmete skeemad. Et kirjeldatakse sellised nimeruume ja sisu elementide definitsoone linkitud dokumentina, et tõmatakse sellised XML-t data-skeemad alla ja nende põhel saab parsimise ajal vaadata, et kas seal seese olevad väärtsedist vastavad kokkulepidud skeemadele või mitte. Ja Soap sellises webi teenuses defineeriteks põhimõttel tähed selle serveri implementeerijapool, et mis on kokkulepidud operatsioonid, mida Soap server siis toetab. Kui me näen Soap serverilis pakub mingi webi teenuses, me tavaselt paneme paikka, et see toetab sellised operatsioonid nagu product title, order product, update order ja cancel order. Et sa arvaselt RPC-le me defineerime, et mis on need operatsioonid, mida klientid saavad välja kutsuda ja nende operatsioonidele me defineerime sisend ja väljund muutujad XML-ide tasamele. Et sisse peab olema teatud struktuuriga XML sisendiks ja väljundiks on teatud struktuuriga XML. Et kui klient kutsub välja update order, siis ta peab saab ma XMLi, sellel XMLi peab olema õige struktuuris, siis mingisuguse tellimuse, uuendamise anmed ja see webi teenuse kirjaldus siis ütleb, et mis on see operatsioon ja mis on see sisend XML, mis väljas, et see XML peab sisse siseldama. Kui te ajate HTTP-appisid kasutend, siis te näete, et tegelikult see on päris erinev, et HTTP puhul on panutud paikka operatsioonid ja siis pigem defineeriteks, et mis resursside peal need operatsioonid välja kutsutakse, aga soapi tasamele resursse otsaselt ei defineerita, vaid defineeriteks lihtsalt listo operatsioone ja soap protokolli puul võib näiteks neid operatsioonale kaks oda, et mida mingisugune webi teenus toetab. Ja me loengu lopus vaatame ka siis soap versus HTTP nagu erinev. Kõige päris räägime soapist, siis vaatame HTTP-id ja siis võrdleme neid oma vahel. Nüüd on nimeruumide probleem, et kui meil on mingisugune XMLi dokument ja meil on seal seees näiteks mingisugune HTML-podi ja siis meil on mingisugune inimesekeha anmed. Meil on kaks täegi ja podi ja podi. Mis on nende kahe podi erinevas? Üks on HTML-keha ja teena inimesekeha. Meil tuleb kui tegi ära defineerida, et mida need tähendavad. Meil oleks alati võimalik neid nimetada umber. Ümbesad meil on HTML-podi ja human-podi, aga siis meil saanme modelid läha tästi keerukuks, et pigem on ikkagi kasutada sellist lihtsalt nime, podi, aga nüüd me peaks jääma paikka panema, et see on podi, nagu miss nimeruumis, et me saame defineerida, et see on podi, aga see on podi HTML-nime ruumis, see on podi, aga see on podi mingisuguses Eesti, Eesti riigi anmedte nimeruumis, et me saame paikka panna, et see podi tähendab teatate tüüpi podi mingis konkreetses nagu nimeruumis ja nimeruumid eraldavad, nagu ma rääksin ka Tokkeril oengus, meil vist ei ole Tokkeril oengus peale, teises aine sääksin sellest, aga ma rääkin sest ka Tokkeril oengus, mis haisata nimeruumid, aga põhimõtteliselt neda ruumid, kus mingi nimi tähendab teist asja, kui teises nimeruumis mingi nimi, nii et see nagu eraldab nede nimeruumid, kus meil on mingisuguses sihemeesed nimed, nede definitsioonid oma vahel, et meil on näiteks height and weight of podi olla nagu inimesepikkus, inimesekaal, aga näiteks HTML-is podi height või mingisuguses podialamosa height võib olla, et mitu pikselid kõrgedan, saab mingisuguse pilt näiteks, et ne on täitsad erinad asjad. Ja siis XML-is, kui me kasutame suupis, me hakkamegi defineerim, et meil on human podi ja see human defineeriteks mingis webis asuva dokumenti põhjal, et meil on mingisugune skeema, mis defineerib, et mis asi on human ja selle sees on definitsioon, et mida podi tähendab. Saamoodi, et meil on HTML-ikohtad, meil on HTML podi ja see HTML on teatud nimeruum, et selle nimeruumi definitsioon asub kuskil aabresis ja see dokument, mida saab allotamata, siis kirjeldab, mida tähendab HTML ja mida tähendab podi HTML kontekstis. Ja siis tihti me peamegi defineerim nagu nimeruumi ja siis selle oleme, mille onmed me siis paneme, siis siin height ei ole lihtsalt height, vaid ta on human height, kui siin ala võib olla veel mingisugun nimeruum, et ta on mingisugun teine height. Ja niimoodi tekitatakse nagu nende XML dokumentide nagu ise kirjeldatavus, et me defineerime ära, et kus on meie definitsioon, et mis täpselt ütlevad, et mida see väärtus siin tähendab. Ja kui me saadame sõlb sõnumi webiserverele, me tavaselt peame defineerime sellise ümbriku, sellised header-value-ud ja siis podi-value-ud, kus ümbrik ise defineerib ära, et mis versioon sõupi, näiteks me kasutame. Päises või heeteris on igasust lisa info-ud, meta-info-ud ja kehas või podis on siis päringu sisu, et näiteks, mis on me, et me serverile saadame. Ja vastu võib tulla lisaks veel üks vea teate, selne kehaseese olev komponent või siis manus, et näiteks mingid failid, mida me kaasa paneme ja mida me saame vastu serverelt, et meil võib siis eraldi olla manused ka, mingisugusete failid. Ja kui me hakkame saadma sõup teadad serverle, siis ümbrik või envelope näeb pärle niimood, et meil on envelope, mis defineerib ära, et mis XML-version on, et on mis tüüpi sõupenvelope on ja mis sen koodingud kasutatakse ja sellesees on siis heeter-värtused ja podi-värtused ja põmst kõik, et siis se kirja ümbrik defineerib need standaardid ära, mida kasutatakse. Ja heeter võib näha välja lisaks enne heeterisse minekult, et seal envelope-sees võib olla kõikasuguses teised nimeruumide, kirjeldused, näiteks, et me kasutam X-road mingit anmete spetsifikatsiooni, et seal plaetakse siis teatud tüibid, anme tüibid, mida saab hiljem siis kas podi või heeter-seese ära kasutada, et siin on siis näide X-roadi päringust. Ja heeter võib see näha välja selline, et me defineerime näiteks ära, et mis on mingisugune service, mida me kasutam, et see kuulub näiteks Eesti, Riigi, mingisuguse konkreetse riigi-organisationi mingi alamsüsteemi kohta, et siin võib näiteks olla mingi RIA ja siin võib olla mingi RIA webi süsteem, näiteks, ja mingisugune selle webi süsteemi alam teenus, siis mida välja prooja teks kutsuda. Ja siis client defineerib ka, et kest ta on, et client on siis ka Eesti mingisuguse organisatsiooni, teise member one mingi teise Eesti organisatsiooni alamsüsteemist tuleb päring, mingi teise organisatsiooni teise alamsüsteemi tehta päring. Ja lisaks on ka sellel päringu ID, kasutada ID ja mingisuguse teised informatsioon, näiteks, et kui ta on seotud mingisuguse, ma teagi, mis see täpselt issuisin tähendab, aga kui ta on seotud mingisuguse probleemiiga võib olla. Ja ma pole kindel, et ma kujutan, et ta võib ka olla mingisugun õigused, mingisuguse õigust, väljaandust õiguste issu, aga ma ei tea, mis issu võib siin olla. Ta võib ka mingi järjekord toist olla. Ja siis on tavasid sellest ID-spiisab, aga ma ei tea, et ta võib mingisugu teine ID olla näiteks. Authentiminne toimub ka tavalist heedrate põhjal, aga siin seda välja toodud näitena ei ole. Ja podi see, siis võib olla näiteks, et ma kutsun välja example service, mis on siis see, et ma kutsun välja siis example servicei ja see example servicei sisähend on siis värtus fu. Et see on pige mõttes need konkreetne anmed, mida me kaasa anname sest selle funksiooni väljakutsama. Funksioon, mida me väljakutsama on example service ja selle sisendid on fu ja vastu võivad siis tulla meile sama sugun, et meil on mingisugut ennmeloob, mingi heeter, mingi podi. Heeter on sustat sarane, et kes oli klient, kes oli service ja võib-olla natuke nüüd on meil mingisugust teised anmed siin juures, nagu protocol version ja request hash, et kontrollida, kas on täpselt samarequest või mitte, et kas sisu on muutunud, et visak siitele, et kas ka põhimselt, et kogu selle request xml dokumenti hash ja siis ka algoritmi, mis algoritmi kasutad selle hashi loomiseks. Ja siis vastus võib tulla par, ubar. Aga selleks, et me saaksime saata sellest väikest funksiooni nime, siin on vist funksiooni vastuuse nimi ja sest väikest väärtust siis selleks peab see dokument olema päris suur. Et siin mul ühele slaadil ta ei mahtunudki, et ma pene nagu viiele slaadile selle raja ka. Ja agu ta tööta põhimõtteliselt nagu webi arpet see, et me defineerime, et mis on see meetod, mille me välja kutsume ja mis on selle meetodi argumentid ja me lepime kokku, et mis see xml-ides struktuur peab olema siis klientide serverite vahel. Et HTTP API on selles mõttes huvitavam. Et me kasutame siis HTTP protokolli ja see on huvitavan, selled öötat on rohkem nagu, ma ei ütleks aru saadavam, aga vähem infod vajav anmete vahetuse protokolle viis, sest progameeria ei pea nii väga teadma, et mis meetodid on võimalikud. Ma ei pea nagu uurima, et mis on need 200 meetodid, mida see appi-server või webi teenus siis toetab. Meil on operatsioonid paigas. Meil on get-operatsioon, post-operatsioon, put-operatsioon ja delete-operatsioon ja mõnikord me teeme ka head, trace, options, connect või patchi. Aga peaamised kasutame need nelja meetodid. Get, post, put ja delete. Ja selle asemel, et meil algs 200 on ikkasad operatsiooni, me pigem defineerime, mis on resursid, mille peale me teeme need nelja operatsiooni. Resursiks võib meil olla siis html-let, pildi-file, kasutaja, virtual machine, kellegi ma ei tea mingisugune asukoht põhimõtsed. Et siis html-protokollide puhul see on kehitatud nagu webi resurside jaoks pigem. Et see ei ole designitud nagu mingida operatsioonide väljakutsumiseks, aga see on defineeritud, et resurside peal ja resursid võib olla peaga üks kõik mida, aga webist avalstate resursid on siis html-let, pildi-file ja need asi. Ja mis on siis get, post, put ja delete operatsioonid? Get tõmbab alla mingisuguse resursi, post loob mingisuguse alamresursi, put muudab tavalselt võib ka lisab mingisuguse resursi ja delete kustutab selle resursi. Ja ta hästi loogiline aru saada, mida me nende operatsioonidega teeme, kui me jooksutame getto operatsiooni pildi peal me tõmbab mingisuguse alla, kui me jooksutame getto operatsiooni asukoha peal, siis me tõmbab asukoha info alla, kui me teeme post operatsiooni kasutaja asukohtade peal, me paneme anmebasei uue kasutaja asukoha, et kus ta praegu asub. Kui me teeme asukoha peal delete, siis me kustutame sellas asukoha anmebasei ära. Ja see loogilise on viis, kuidas defineerida, mida me soovime tehaad. Me defineerime mingisugust resursid või resurside komplektid, näiteks kõik veebilehed, kõik pildid, kõik kasutajapostitused, kõik kasutajad. Ja me saame nende resurside peal sellised operatsioone väljakutsuda. Ja see loogike tuleb pigem sellest, et mis on nende resurside kogumik, mida see server haldab ja mis operatsioone nende peal on lubatud väljakutsuda ja mis operatsioonid näiteks nõuad autentimist ja nii edasi. Et kui HTTB sellised operatsioonid ei nõua nagu tead, mis niivaga operatsioonides, siis tegelikult sõubibuhul tullab väga palju tead, et mis on siin. Ma panasin ta tagasi, muidu teisedi puhle. Ma loodan, et mind on veel kuulda. Sõubibuhul me peame uurima, mis nendes dokumentides sees asub, et mis on seal defineeritud. HTTB-buhul nagu meil tavalised nii väga sellest spetsifikatsioon ei prugi olla, aga see kogu süsteeme on natukene loomulikum ja loogilisem ja selle tõttu on ka palju palju populaarsemaks saanud ja tänapäeval pigem kasutatakse HTTB appisid ja protokolle selleks, et veebideenuseid ehitada ja isegi suhtlus teha hajusüsteemide komponeetid vahel. Ja serverid teenida võib mingisugused resurssioid ja komplekte, neid võib olla 1, neid võib olla 16 ja nad toetavad neid operatsioone. Nende objektide peal server ei pea kõike operatsioone toetamata võib näiteks implementeerida ainult keti ja delidi, või põl ketje delidi ei ole väga normaalega keti, näiteks ainult toetada ja ei toetakse uuendamist. Või delitimist ongi info ainult, et sa tahad praegust elektri hindu vaadata, et sinul ei ole õigus elektri hindu anmebaasi panna või et sinul ei ole õigus elektri hindu näiteks omset elektri hindu allatõmata. Et server ei pea mingi resursi peal kõiki operatsioone implementeerima. Ja siis klientid saavad välja kutsula neid operatsioone, mida siis see server toetab. Ja siin on näite ket, et ütleme, et meil on asjade internet ja anmebaas, kus on anmed, nede anmed tüübiks on measurement, et see ongi resursid on meil siis measurement ja meil on measurementide selline list või measurementide kollektsioon on siis measurement measurements ja seal all on calcrips ja mingisugune üks konkreetne measurement, mingisugune mõdik, mis on mõõdetud sensori poolt. Siin ta on mingisuguse temperatuur ja meil eksisteerib server, kus me saame teha siis selle slash measurement slash measurements slash mingi ID päringu ja see measurements, seal on see resurside kollektsioon ja see on siis konkreetse resursi ID adres. Ja me saame selle peal teha ketpäringu, et selle resursi anmed siis alla tõmad, et konkreetne mingisugune asjade interneti sensori measurement. Ja oleleb nüüd, kas me saame vastu ainult numbrise värts, et see värts oli 100 või me saame nagu sellise Jasoni, mis samuti proovib masiin loetavalt kirraldada ära, et mis see measurement või mis need anmed on, kus on näiteks saadateks vahegi siis Jason. Jasonis on selle measurement ID, mis seadme pealt see measurement on mõdetud, on sensori ID näiteks, kuna täpselt see mõdik tehti, mõõtmine tehti, mõõtmine tehti oli 2020, mis tüüpi see mõõtmine on, et on kui mulle ostiti steam tüüpi ja siis et mis selle measurementi enda nagu meta anmed on, et on steam, temperature ja seal siis on väärtus 100 ja unit on Celsius, et 100 Celsius oli see hetke väärtus. Proovi kise, et minge näiteks selfie või posti meie adresile ja vaadake, et mitu ketpäringud tehakse. Ja kus F12-nega vaadate, et mitu päringud tehaks ühe lehekülle laadimisel, eriti kui ta allaskrollite ka veel, et siis te näete tegelikult, mina kui ma seda 2021 aasta tegin selle pildi, et siis postimees tehti 166 ketpäringud, et see postimeesel leht alla tõmata, aga see oli siis, kui ma allaskrollisin, siis ta tegelikult rea laajas laeb rohkem neid piltte ja lehtid. Ja täna pala ongi, et kui te lähead veebilehele, see ei toimu ühteketpäringud, kus ta tõmate HTML-faili alla, vaid iga pildi jaoks on eraldi päring. HTML-lehes võib olla 10 linki erinate JavaScript-failidele ja seal võib-a, et igasakust teised JavaScript-failid olla, mis on importitud näidest JavaScript-tidesest ja tegelikult tõmataksegi alla siis hästi palju file ja tegelikult 16 MB oli vaja, sõil läksed kõik asjad alla tõmata selles päringus. Kõik need on siis ketpäringud, mida tege browser automaatsal teeb, kui HTMLis on mingisakun link, veeb iresursile ja see resurs võib olla siis teene HTML-leht, pildi-fail, JavaScript-fail, näiteks mingisugune Chart-Pit, Map ja nii-edasi. Ja siis tege browser automaatsal teebki ketpäringud resurside peal. Kui me sooviksime näiteks uud dokumenti luua hudlet-teja appis, siis me samuti saame panna selle sisu kaasa ja teha näiteks mingisuguse resursi koleksiooni peal postpäringud. Me saadame siis mingisese serverisse adresile alarm alarms ja see adres alarm alarms, see defineeribki, et mis resursiga me tegelemad. Meil need see sisu ise ei defineeri resursityüpi, vai tavalselt resursityüpi defineerib see otspunkt, htp, appi otspunkt, kuhume selle operatsiooni saadame. Mõnes mõttes selasame, et meil tekiks alarm dot alarms, change alarm või modify alarm, meil tekib see, et meil on listalt post, tüüpipäring ja teatud resursityüpi peal, kus otspunkt või appi endpoint defineerib, et mis resursidega on siis tegu. Et kui meil oleks user resursi, saaks juba slash user slash users või slash appi slash users ja me saame postida uue useri. Ja siin tekiks uus alarm ja noh, jasonist sisu on ikkagi samamoodi serveri ja klendi vahel koko lepid, et mida server soovib saada, et seda tüüpid me peame saadma, et muidu saame serverga erorri näiteks, et type pärdus on puudu jasonist ja seda päringud vastavõi võetakuna seal type ja la. Mõnikord saadaks vega, mida tavalsed väga ei teht, aga mõnikord võib ka paika panna sellised samamoodi xml tüüpi spetsifikatsiooni, et mis tüüpid jasonid me vastavõtame, et see on mõnesemalt info kliendil, et kui minna sellele adresil, et seda tüüpid jasonid võimest võetakse vastu, aga seda väga tihti ei kasutatakse. Ja kui meil on mingisugun autentimin, et see panaks heeteritevärdusesse, et mis tüüpi näiteks basic-off või api token või midegi sellist ja content type tavalsed definerib, et mis tüüpi sõnum, et ootatakse, et kas jason või csv või xml või midegi muud. Et hardretel peab, et api tegelikult ei pane paika, et ta peaks olema jason, aga me tulem selle eurde koha ja tagasi. Delete operatsioon, me pane paika, et mis on selle kollektsiooni objekti adres, mida me soovime kustutada, näiteks, slash measurement slash measurement slash 2617 näiteks. Ja tulemus võib olla kas error, näiteks, et meil ei ole autentitutetet anmed kustutada, või siis võib tulemus olla näiteks HTTP 204 kood, mis tähendab, et no content, ma tulem selle eurde tagas, et mida need koodid tähendavad. Delete puhul tihti ei ole koodi vastust, et kustutad ja võib piga seda, et no content, et sisu selle laadrasil enam ei eksisteerimest mõnesmõttes sõitelik, et see on kustutad. Et kustutad järele ja sõeldeks, et seal enam content ei ole no content. Putti näide on näiteks mingisuguse resursi anmedte muutmine, et kui ta on kasutaja, soovite kasutaja imeli muuta, et siis sellase me teeme posti, peaks tavalselt tegema putti. Ma tulem ka selle eurde tagasi ühe slide puhul, et mis see selline standard restful appide puhul on, et kuna kasutada posti, kuna kasutada putti. Aga putparing siis samuti mingisuguse resursi aadresil, kus meil on näiteks rakendused ja se rakaniduse ID ja me saadame selle rakenduse adjationi kas uuesti, või me saadame selle rakenduse adjationi mingida alam, võitmed ja väärtused, ainult need, mida me muuta tahame. See olemb ka sellest, et kuidas see rakendus on eitad, et kas ta tahab kogu selle rakenduse kõiki kirjaid või tahab näiteks ainult alam viite kirjat, mida ta muuta soovib. Lisaks on Hotetepeks ka teised erinevad operatsioonid, mida appide puul alat ei kasutat, aga näiteks head operatsioon tagastab ainult resursi nagu metaanmed, et siis su ei tagastata. Kui tead, et kui see on mingisuguna suur video, taad te teada, kui see on suur video, siis te pead saadma ketto operatsioonid video alatamata, võit saadte, et antke mulle ainult heeter väärtused, et siis saad te teada, et kui suur, mitu pittise video siis on, või pilt ennekude alatamate pildi, et saad te lihtsalt küsida Hotetepekservea käest. Näites soovite teada, kuna mingit pilti muudeti või kuna see loodi, et saad te siis küsida, et mis on selle pilti resursi siis metaanmed ja saad te selt vaadata selle suurust ja loomisaaega, aga ei pea seda pilti alatamu. Options on sarnaan, aga options defineerib tavalsed mingisuguse endpointi otspunkti infot. Mitte enam nii väga resursi info, aga te võib ka resursi info tegelikult anda, aga näites, kui me ei oksutama, siis options sparingu slash appi slash resursikohta, siis me saame teada näiteks, et mis operatsioonid on lubatud sellele otspunktile saata ja kas mingisuguse muu ifoad, kas seal on lubatud näiteks kuskib mujald seda väljakutsuda ja mitte, et kas seal on lubatud alatamada anmed scriptilt, mis ei eksisteeri samas serveris või ta asub kusagi mujal. Lisaks on teised operatsioonid nagu trace, mis kontrollib seda, kui saanmed kohale juuavad, et tihti on sellist ümbersuunamised ja koormuse ja autorid vahel, ja kui ma mõnikord vaja diagnostilise eesmärkida näha, et kui tegelikult nad sparingud liiguvad või kudas neid muutetakse vahe serverite poolt, siis trace on selleks kasulik, et kui näiteks me tavaliselt saksime, see võimalda peaa, et niimoodi lisainformatsiooni saad, et kudas muutetakse näiteks mingisugused heterovärtusi või muid väärtusi. Lisaks on ka connect, metod, kui sooviteteks tunnelid luua, et siit ta tihti kasutatakse just HDFDB-s jaoks, et luua siis turvalne tunnel, kus skripteeriteks ühendus ära, põhjumist, et see tagastab selled kas õnestus turvaliselt ühendusluua või mitte, kui ühendata üle HDDB-s. Ja mis on siis post ja puti vahel, sest mõlema tegelikult on operatsioonid, mis muudavad andmeid. See ei ole nii väga niimoodi paikab andud HDDB protokollis, aga restful spetsifikatsioonis, millest ma järgmisele rääginan, on see tegelikult defineeritud niimoodi, et post peaks lisama uue objekti objektide listi. Uue kasutaja kasutate listi, uue piltide listid. Kui meil on kuskil veepi teenus, mis halda piltide kolleksiooni, siis uue pildi loomine peaks töötama postiga. Ja postiga ei panda kaasa objekti ID-ed, et ma loon uue pildi, selle pildi ID on 316, või tavastatud umbes niimoodi, et ma paneme uue pildi list ja me saame servel tagasi, et mis on selle pildi identifikaatoreneid, et ikka ID-värtus. Put on tavalist resursimuutmine või väga konkreetsed resursi panemine kuhugi konkreetse adressiga või ID-ka, et me soovime näiteks tekitada kasutaja, mille nimi on 16 või mille ID on 16, et me saame teha päringu put-päringu slash users slash 16, et seal tagasi luua infot, et me loome konkreetse resursi kirjat. Kui post on pigem täiesti uue resursi viskamene serverisse, siis put proovib mingisugust olemasolata resursi muuta ja võib-olla on defineerid, kui seda resursi eksisteeris, siis loome selle 0. Et selle tõttu ka puti mõnikord kasutataks uue resursi loomiseks kui kui see on pigem infomuutmiseks mõeldud. Ja lisaks on selline päringute omadus, nagu idempotensus, mis tähendab seda, et mis juhtub siis, kui me kordame täpselt samapäratsiooni, et kui me teeme mingisuguse pildi üleslaadimise postmedia tabil, me loome pildi ja me loome selle pildi uuesti, mis juhtub, kas tekib kaks pildi, minna täpselt sama sisu ja minna erinata alat vessite, erinata idega või kirjutudeks esimene pildi üle teise päringuga. Eidee onki, et post ei ole ülekirjutav funktsioon, vaid ta lihtsalt loob mitu alam objekti, kui me sama pildi mitte korda üleslaadime, aga puti, et put proovib panna selle pildi teadud nimega võib-olla või teadud idega ja put lihtsalt kirjutab selle üle. Ja see onki nende kahe metodi vahe, aga kas ta on selline või mitte, seda täiesti implementeerib servet. Teie kood, kui teie looda appi, siis teie kood otsustab, kuidas see tegelikult on implementeeritud, et ta on pigem nagu sellise loogika tasemel, kui kui kui protokolli poolt kontrollitud. Lisaks ketanud, kui teete, mitu ketpäringud, siis midagi toeks muutuda. Headpäring, optionsparing, traceparing, deleteparing and putparing on ka sellised, et te võite neid mitu korda teha ja kui te kaks korda midagi kustutate, siis see teki tagasi, ta ei ole nagu negatiivsuse, kahekorna negatiivsuse, et panaks see pild tagasi kaks korda kustutada. Kõik need on siis sellised, kus tulemus on sama, kui te sama operatsiooni mitu korda teete. Ja tihtite saate mingisuguse stringi tagasi või jationi tagasi, kui te teete operatsiooni, mis HTTB protokolliga mingi appi vastu ja need jagatakse tavaliselt kolme kruppi. On edukad operatsioonid, mis algavad kahega, on klendi tehtad vead, mis algavad neljaga. Alati ei ole klendi poosed vead, aga vead, mis viitavad, et võib-olla klent tegi midagi valesti. Ja serveri vead, mis algavad viiega ja selle mõte, mikste ta serveri viga, on, et see ei sõltu klendist. Yks kõik, mida klent teeks, ta saaks ikka selle sama viiesaja vea. Nende vahe ei ole alati niid selgelt defineeritud, et pigem neljaga algavad koodid, ütlevad näiteks, valed anmed saadeti, et vale funksiooni, kus jutakse välja, või seda pilt ei eksisteeri. Ja viie puhul on see, et koodist tekis viga. Püütan koodist tekis error. Ta või kui tekida klendi poolt saadetud sisendid tõttu, et näiteks Jasonis oli mingisugune string, mida ei õnestanud parsida korralikult ja siis teie püütan koodist tekis viga. Aga ta pigem ütleb, et midagi on serveris valesti, et midagi on koodis valesti. Ja 400 koodik näiteks ütlevad, et seda rekuesti ei toetata, teil ei ole õigusi päringud saata, seda meedladid ei ole lubatud välja kutsuda näiteks teie õigustega. Seda resursi ei eksisteeri, et näiteks selle aades ka pilt ei ole mida allatõmata. See meetood ei ole küll keelatud teie kasutajal, aga ta ei ole lihtsalt lubatud. Vist 400 koodid mingisugune sisend ei ole acceptable, näiteks ta on liiga suur. Ma pole sada protsindiselis kindel. Räkkues taimatud võtis liiga kaua aega ja see serveri tarkkora otsustas ühendus ärakadkestada. Näiteks proovisite mingid suurt videot üleslaadida, aga oli lubatud ainult 60 sekund et ühendus lahti hoida. Elaks kaua aega. Unsupported media typer näiteks seda tüüpi pilt ei ole lubatud üleslaadida ja tuume nii rekuested, kui on pandud lemiit, et te ei või rediti see rohkem kui 10 korda tunnis sõnumid saata, kui teil on tasuta API võtii. Millis on 418? Mis oli? Ma ei tea. Ma ei tea, ma seda siia ei pannud. Ta näete, et siin on mõetumbrid ka puudu. 510 on lihtsalt, et see oli mingisugun eror. 502 tähendab seda, et ei õnestund õigese kohta ümber suunata. Vistid juhtub seda, et kui server ei ooks ja seal, kuhu prooviti suunata seda serveri päringut, prooviti suunata näiteks ühte 16 serverist, aga ta olis hetkel maas ja siis võib koormuse jatur saada, et seda serveri praegu üle oli ole ja tuleb selline vastus, et asukoht, kuhu prooviti saata, seda ei eksisteeri enam. Server on kadud põhimõttelselt. 503 on pigemsed server eksisteerib, aga ta ei võtnud vastu. Ma saan, et ta porti ka ühendast võtama näen, et keegi seda porti kuulab, aga ta ei võtnud minu päringut vastu. Teehti on ülekohormatud näiteks, või järjekord on täis, või ta on praegu 16 lõime, ta on lubatud 16 lõime korraga jooksutada ja tööde järjekorda ei ole, et ta lihtsalt lükkab tagasi. Praegu ei saa vastuveta. See on tegelikult hea selleks, et võib seda päringut korrata teise serverist, võib lihtsalt uuesti korrata, kuniid seda vastuvetakse, aga bad gateway pigem ötleb, et server on maas, et ei ole keltse serverid. Ja gateway timeout on siis mitte, et server või see webi teenus on maas, vaid näiteks mingi vahe pealne see, ütleme, kormus jaotur on maas. Et ei õnestundki serverise ümber suunata või ei õnestundki proovida serverise suunata, et seal on see natuke vahe vist. Et gateway oli kätte saadav, aga ta andis vastu, et timeout ei õnestunud, kui seda vastu võtta. Siis on mõnesmõttes võib-olla küsimus, et mis on nende kahe vahe. Üks on see, et see on, võib-olla kasuta saadis liiga suure file ja selledut on see timeout. A gateway timeout võib olla, nagu see, keesel vahe vara või kormus jaoturi probleem, et ta millegipäeks tei vasta korraksalt. Et võttis küll päringu vastu võib-olla, aga siis annab tagas, et ei õnestun seda väljakutsuda või. Tihti need koodid tegelikult sellest, kuidas teie ise implementeerite need oma koodis. Kuigi bad gateway võib tulla ümper suunamist. Kui meilatada kihilist arhitektuurid, üks kicht suunab teisele kihile edasi ja gateway amad on kichtide vahele ei õnestunud, aga edasi suunata. Või küll tehti ühendus, aga siis teha ühendus timeoutis. Bad gateway on pigemist seda gateway, et ei ole seda erinam. IP adressi näiteks võib porti enam eksisteri. Või keegi kuulasuda. Lisaks on sellised metodid, nagu safe metodid, mis midagi, mis on defineeritud niimoodi, et nad serveris midagi muda. Nii, et te võite neid väljakutsuda ilma, et almebasis näiteks midagi muutuks. Ei kirjuta serveris uusi almed. Teoreetselt nende päringude tegemine ei tohiks mõjutada, nagu serveri olekut. Alati see ei ole tõene. Praktikas see ei ole karonteeritud. Me võime ketpäringud teha tõmbama pildi alla, anmebasi midagi tohiks muutuda. Aga järsku tarkvara implementeeria on teinud, et ta kaundib, mitte ühendust on olnud, või mitte päringud on tehtud, siis kirjutab anmebasid, on olnud 617 ketpäringud. Nii, et reaalislas elus ei ole kudegi karonteeritud. Et safe-i mõte on selles, et ta on nagu turvalised, et nende tõttu ei tohiks anmebas korrupeeruda või midagi, aga tegelikult võib juhtuda, et nende tegelikult midagi seerele muudad. Ja turvaliselt haatadab ja metodid on ket, head, options ja trace, mis tegelikult ainult infot tagastavad ja teoreetselt ei tohiks midagi, nagu anmebasis muuta, aga olem implementatioonist. Ket protokoll tegelikult ei pane paika, kuidas peaks need ket-appisid kasutama, ket protokoll isegi pane paika täpselt, et me tegeleme resursidega. Tegelikult see, mis pane paika, et me tegeleme resursidega ja kuidas need resursse kasutada ja kuna millised operatsioone kasutada, see tuli tegelikult natuke hiljem. Ja see tuli sellisest, nagu ühes vist oli lõputöö, ma ei mäletagi, kas tal oli magisti või doktoranturi lõputöö, kus pakutid välja selline standard veebi teenustele, mis kasutad HATVP-t ja selle nimi on siis representational state transfer, ehk rest või restful, mõni kui nimetakse restful. Aga see ei ole nagu uus protokoll, kasutadakse täpselt sama HATVP protokolli, kasutadakse sama metodeid, aga lubatakse ainult viis metodid, et ülehand öeldaks, et ülehand ei kasuta, et ülehand ei tegele nagu selle tasemega või selle väebi liidasega. Ja see lihtsustab natuke või paned paikareeglid, kuidas HATVP-appisid ja resursse defineerida. Ja defineeriteks, et igal resursil, mida serveeriteks veebi teenustele, seal peaks olla mu unikaalne adress, unikaalne URI või unified resource identificator. Ehk kui meil on pilt, selle peaks olla mu unikaalne adress, kui meil on mingisid kasutaj, selle peaks olla mu unikaalne adress, et tavaselt teakssegi seda nimod, et meil on mingisid ID-värtused või mingi file niimi sinn, et meil on konkreetne server, seal sisav asuvs resursi-t või path ja siis resursi-id või identifikaator. Ja need siis defineerivad konkreetse resurssi, mida on võimaleks siis lua, vaadata, kustutada ja nii edasi, ja resursside kolleksioon on siis see sama adress enne seda ID-t, et slash kasutajad ja siis on loogine aru saad, et kui ma soovin kasutajad halvata mochi mingisugust slash appi slash users või slash users, seal all võiks olla see kasuta ID, et kui ma soovin nendeks mingid konkreetsi kasutajad, vaadata, et see paned see loogilise standaardi paika, et kuidas need resursse defineerid, et rakenda, rakendus arendad ei mõtleks ise mingisugust suvalisi viise välja, et kuidas need resursse identifitseerida ja kuidas need ue RIsid või linked genererida. Ja rest spetsifikatsioonisest spetsifitserib, et me kasutam posti, putti, keti, daliiti ja patchi ja teisi väga ei kasuta, teised on seotud protokolli endaga, aga mitte nagu webi appidega. Ja kaks asja veel, mis panaks sa paika, et kõik implementatsioonid peaks olema olekuta, et serveri implementatsioonid ei tohiks midagi nagu mällu etta ja teine on, et nad peaksid olema käsitavad. Ja mida tähendab käsitavad, on see, et teie rakendus ise peaks vastama põhimõtsel niimoodi, et ta ütleb, kas te saite tagasi käsitud või rooanmed. Et kui teie vastatab päringkule, siis seal võiks heeteris olla kirja, et kas need olid käsitud anmed, kui nad olid käsitud. Kui on käsitud, siis võib-olla teie peavastama, aga kui anmed olid käsitud, et siis tead, et nad ei võetud anmebasist sellel hetkel, või nad on natukene varem nagu meeldie jätud pahemelus alvestadud anmed, et siis seda tuleb defineerida vastuses. Et see, kes teab päringkud, saaks sellega arvestada, et kas ta või saada vanu anmed, või ta sai kõige viimastada anmed sellel hetkel, kui päringkule vastati. Ja defineeriteks, et siis mis meetodeid võib kasutada kas kogu ressursside koleksiooni peal või siis viimases tulbas konkreetse ressursi peal. Et me teeme neid meetodi päringkud kas siis slash klientide peal, et modifiseerida siis klente või slash klientid slash klienti ide peal, et modifiseerida kindlad klenti või kindla klendi ressursi peal operatsioone väljakutsuda. Ja postmetodid on lubatud siis väljakutsuda kogu kolleksiooni peal, et luua uus kolleksiooni elemente, luua uus klientide kolleksioonis. Postmetodid ei ole lubatud konkreetse klendi või konkreetse ressursi peal väljakutsuda, selleks, et selle ressursi muuta. Et ressursi muuta peaks kutsuma välja putto operatsiooni selle ressursi peal, et me siis muudame juba olemas oleva IT ka eksisteeriva klendi anmeid või sisu. Et mis iganes see ressurs on, kas klent või midagi muud? Ei. Panema on lihtsalt ketmetod selleks liulia. Jah, et kui seda terori, et juba eksisteerib, seda võib juba tähendada seda, et eksisteerib ja 404, siis sa saad, kui ei eksisteerida. Ja siis on siis kõik, et juba on juba kõik, et juba on juba kõik, et juba on kõik, et juba ei eksisteerida. Aga see natuke, ja, ja, kui mingil põhjel selle sa kette ei sa kasutada, siis ja, sa oled posti prood kasutada. Aga siis sa loodad, et implementeerion on higged koodid sina pannud. Muidu sa vaid lihtsalt saada, et tänapäeva apidel on see ka väga raske teha sellet, et järgmises loon, kus me räägime nagu sellest vägerest ja open-upi spetsikatsioonist, ja kui te kasutat open-upi spetsikatsiooni, siis selle spetsikatsioonipool, genereritud koodis, panaks kõrgemalt asemal paika, et need metodid, mida ei eksisteeri või mida ei ole lubatud välja kutsuda, nende kohtada saada lihtsalt tasnauteksist koodi, et mis, kas 404 võib olla, või siis method allowed, võib siis 404 not fa, ja pikem võib olla sellel või, et põhjumselt saate vastus, et seda methodid ei eksisteeri, et pikem saate, et seda ei ole implementeeritud tänapäeval, sest mõnesemalt siiaht ei eeldab, et see method eksisteerib, aga miks ta methodid luua, kui seda ei tohiks luua. Keti saab teha mõlema peal, ketsressursside kolleksiooni peal tagastab mingisuguse nimekirja, näiteks kõikide kasutate listi, ja ketti ühe ressursi peal tagastab selle ressursi sisu, näiteks kasutada enda anmed. Puttis ei ole lubatud kolleksiooni peal jooksutada, sest me ei loo uud kolleksiooni putiga teatud olukordades võibse olla, et te teete mingi ülidünaamilise appi, kus te iseloote uusi user collection, trees collection, clouds collection, et näiteks on mingisugune piltide gruppeloote, teoreetiliselt oleks see võimalik, et tegib mingi kaust ja siin kaustal alla saad uute, näiteks teete loomade kolleksiooni ja siin alla hakkade loomade piltte panema, et teoreetiliselt keegi võiks seda implementeerida, aga üldiselt mõeteks, et putt ei jooksutada kolleksiooni peal ja putti siis ühe objekti peal ühe ressursi peal selle muutmiseks. Ja te liiti ka, et kolleksiooni peal nagu me ei kustuta, me ei kustuta kogu kasutajade ära, või me saame kustutada ühe kasutaja, aga me ei kustuta kasutata kolleksiooni ära, aga teatud olukord, et see keegi võib seda implementeerida, neemad, et kustuta mulle kõik piltid ära, kustuta mulle kõik kasutajade ära, et kui keegi seda implementeerib, siis ta käib küll selle restfuli vastu, aga ta võib loogiliselt olla vaja, nagu huvitav kasutada, et soovite mingid metodid, mis kõik ressursi alam objekti ära kustutab, mingi kolleksiooni alam ressursi ära kustutab. Ja niilt põhimest ongi nagu viis kasutust ja see teab ka sellegi appidest aru saamise naltukul lihtsamaks. Kui te näete ketmetodid ressursid peal, kus see ID ei ole, siis on tavasalt kõikid alamressursid alla tõmbamine. Kui teil on ketmetod mingi konkreetse ID peal, siis ta tavasalt konkreetse ressursi alla tõmbamine ja nagu see on aru saadav, et kui te saate aru, et slice-klientid on klientid, siis te saate väga hästi ette kuutada, midas appi siis toetab, klientide listimist, klientide infok alla tõmbamist või siis klienti kustutamist, et nagu nad on loogiliselt aru saadam ja tavalselt appides, hattate pea appides ongi nelj metodid, aga võib-olla palju end pointe, kuhu vastu näid päringud saab teha. Ja vähemalt minu jaaks on sellistest hattate pea appides nii lihtsam aru saada, sest ma ei pea teadma, mis on need 200 operatsiooni, ma pigem pean aru saama, et mis on võib-olla need 16 või 20 erinele resurssi, mida halatakse seal serveris ja võib-olla siis mina appi võitmed, mida halatakse kasutajad, kasutajada postitused, mingisugused pildid, mingisugused failid, mingisugused muud asjad ja see on nagu loomulikud aru saadav, et ma eeltan, et siis piltiteaks on, kas kõik need operatsioonid lubatud või siis vähemalt get-meedad lubatud, et pilt ei halatamata. Ja kui meil on siis get-paring, siis soobis näeb see get-paring selline välja ja restis näeb selline, kus me soobis peame ütlema, et meil on mingisugud get-product-title operatsioon ja selle argument on siis product-id 21 või selles ketis andale lihtsalt slash get slash product, et me tõmbame alla siis product-koleksiooni andmeid, aga me tõmbame alla siis konkreetse product-koleksiooni 21. objekti id järgi siis andmed ja nagu ketist, nagu HATVB ketidest ja soobi operatsioonilisest aru saamine nagu sellavõra lihtsam ja võib-olla ka see, et meil on lihtsalt vähem andmeid, mida me peame edastama. Aga soobi puul on osa asi nagu masin loetavam, näiteks need tüübid ja muud asjad, mis ketipuhul tegelikult mõnikord lihtsalt tunnustateks ära, et kasutad ihti peab lihtsa asja teadma. Ja siis see vahe soobi ja restivalent soobi puul me siis defineerime konkreetse operatsioonid, et cancel order sellase mene teha delete operation slash orderi peal, update order sellase mene teha put order, et meil peab siis eksisteerima sellised natuke listuni kaasemadest operatsioonidest ja me peame nagu neid listi läbi vaatama, et mis on need operatsioonid nende nimed ja need nimed ei ole nagu standardsed, kus HATVB appid või restful appide puul on nagu see resursikoleksiooni nimi on unikaal, nagu need operatsioonid on alati standardsed, et niimoodi on natuke lihtsam aru saada. Aga mõnikord on raske otsustada, et mis need appi endpointid peab siit olema, kui need on dimetratud peab siit olema ja tegelikult see olema pikkagi implementeeriest, kas ta hästi defineerib, et nad on aru saadavad või mitte, et HATVB appide loomine ei karanteeri, et nad on aru saadavad. Et sõup on nagu kasutaja või implementeerijapuolt määratud operatsioonide kogum ja rest on selline standardsed operatsioonide kogum, mida rakendatakse kasutajapuolt määratud resurside kogumu või komplektile. Ta saab nagu suurematega hakkama, ma ei tea, kas protokolli tasemel on neid sõnumite mahu erinevused. Et sa saad ikkagi ketpärin kogu 30 gigabaitis ja faili alla tõmbamist, et see on sisse ehitatud, kui tead toimub selline stream alla tõmbamine, et su browser jätkab alla tõmbamist, et ta ei saa seda ühe paketine saada ninguneis asjad ta saata, et sa peab olema paketide jada. Et see on nagu sisse ehitatud, aga juba see, et XML raiskab väga palju ruumi, muud asjad jaoks, nagu tekitab ratoca probleeme. Ja sest neid XML sõnumid lihtsalt on suured võrraldes. Ketpärin, kus sul ongi ainult heeter väärdus, et sul podi ei olegi, hatate pea ketpärin, kus sul nagu podi ei olegi väa. Teatud olukordades pannakse mingisugused atribüudid või parametrit siia filtreerimisparameetrid näiteks pannakse, kui sa soovad kõikite kasutade listi, aga sa soovad sadad kasutad korraga ja 7,7-dat lehekülge, et saab siia urli parametriks panna, aga mõnikõrd panaks see ka podisse. Ja järgmine nädal siis vaatame, kuidas need veebiteenuseid kirjeldateks ja niimoodi, et neid on võimalik ka üles leida veebist või hajussisteemide vahel. Ja mis on sellised standaartselt viisid, kuidas kirjeldada hatatepe-appid, siit me vaatame seda open appi ja swagger spetsifikatsiooni. Ja tänases praktikumis või selles nädas praktikumist te ehitate oma appi, hatatepe-appi, mis on siis raamadate-haldussisteemi-appi. Ja järgmine nädal me selle aseme, et me ehitame appi nagu pyytanis valmis. Me ehitame valmis open appi spetsifikatsiooni, mis on see nii jam dokument ja kasutame generaaturid, et genereerida meile server record. Ja siis implementeerime järgmine nädal selle spetsifikatsiooni põhjal serveri koodi loogika, aga selle serveri implementatsioon genereriteks meile webiteenuse kirjelduse põhjal automaatsalt. Ja seda tavalist kasutataksegi sõupi puhul, et eksisteerivad sellised teenuse rekistrid, mis defineerid ära, et mis on need operatsioonid ja webiteenused näiteks mingi sugele weather forecast operatsioon või get weather by zip code result operatsioon ja seal defineeriteks ära nagu rekistrid, et mis näite operatsioonid argumentid on ja selle kirjelduse põhjal on võimalik genereerida nii klienti kui serveri koodi, aga me vaatame järgmikõrge seda, et kud seda saab teha siis HTTP-appi ja rest appi puhul. Ja selle näitele praktikumis te siis lootegi oma rest appi, me kasutame selle hästi lihtsalt byton raamistiku kool bytonflask, et see ei ole kõige parem raamistik, mida kasutat, aga see on üks lihtsamad ja seda tihti pilves kasutatakse, ma ise soovitaks kasutada fast appit flaski asemel, kui te soovite end up mingi projekti luua, kuna ta on efektiivsem, aga nagu praktikumis õpetamiseks on see bytonflask hästi selline lihtne ja selge ja me loomegi siis rest appi ja me loome siis kahte tüüpi resursid raamatud ja sellise specialse resursi nagu raamatud otsimine ja raamatule me loome siis raamatuket, raamatu post tegelikult raamatuket, raamatude listiket ja siis raamatud delete operatsioonid. Raamatu post operatsioon on natuke imeliks, sest me ei laaie üles raamatud, me teeme raamatu üleslaadimise niimoodi, et me saadame Jasoni, mis ütleb, et mis IIDga raamat Kutembergist allatõmbata ja raamatul oomine tegelikult on nagu post operatsioon, mis defineerib, et mis raamatud me tahame, et meie selles raamatude haldusplatformis oleks, aga taustal toimub siis Kutembergist selle raamatu allatõmbamine ja pärast seda luuaks raamatuses meie haldussystemis, aga me ise ei laaie üles nagu raamatu textfaili. Et ta võib-e natuke senal äkast raamatu post meetada, aga ülevend on sellest standaardsed ja siis teeme ka raamatust otsimise, kus postiga saab defineerida, et mis termi, mis raamatust otsida ja siis saame vastuseks, et mis ja võimsed, kui palju mitu korda see term siis raamatuseks isteris. Järgmise loengus räägime siis web-teenosta omadustest natuke rohkem ja siis web-teenosta standaarditest nagu näid WSTL soapi ja open appi, mis kasvus väljas vägerest, siis rest appide jaoks. Ja järgmises praktikumis järgmises nädalal siis genereerime oma appi koodi open appi spetsikatsiooni põhjal ja implementeerime neid samat metodid, mida te see nädal implementeerite. Kus kellegil on küsimusi? See ei ole seotud otsed turvallisusega ja tihti seda enam ei teha serveris, vaid seda teha samuti eraldi kihina. Me tegime, kui ma räägisin enne nagu ühest, kahest, kolmest või enkiilisest, et me saame käsimise teha nagu eraldi kihina. See, kes suunab päringud näiteks appile, siis võetakse päringu vastuus vahe kihist ja see vahe kihist ise otsustab, kas anda tagasi käsitud väärdused või teha päring tegelikus serverist ja siis anda see tuud väärde. See otsustadaks see, et kui vanad anmed hoidas, siis selles vahe kihist, et tekki selline üks kicht veel vahele. Aga turvallisust see on natuke oleme, et kui sa selle alvasti implementeerid ja kasutad see käsimist, asja teaks, mis ei tohiks olla käsitud, siis ta võib turvallisust mõjutada, aga üldjuhul pigem ei tohiks väga. Käsimi niis ja otsaselt turvallist mõjutada. Kui sa tead, et anmed baasid väärin kui kui sa tead, et anmed baasid asemel väga nagu sellist käsimist ei teha, minu teada. Ja et on sellist asjad nagu right ahead logid anmed baasides, et kõigeva, et kirjutudeks ketale ja siis kirjutudeks anmed baasimälu, et karanteerite, kui anmed pasi ensi kokku jookseb, et siis anmed oleks olemas. Sellist asju tehaks, aga need ei ole otsaselt käsimised, need on ko ajutised ledgerid, kus hoitakse veel kirjutamat anmed põhimõtsult. Aga käsimist tehaks just eraldi tasemel, et vältida anmed baasi enda päringot. Selleks, et vältided anmed baasaks ülekoormatud, tead, et asju lihtsalt käsida natuke aega, et siis tehaks vähem päringu otsa anmed baasi. Ja siis kõige rohkemud sellest kasu, kui sa tead selle anmed baasid väljas pool. Muidusul päring ninguni läheb anmed baasi tarkvara, ja siis kui tarkvara ise käsib oma, siis sa ei väldi need päringut anmed baasi. Aga käsimin on üks teema, mida me väga selles aine seid ei kata. Aga tänu on see esime praktikum kahe tunni perast vist ja saate siis oma appi ehitada, kui te varem appisid ehitada, on te ola.