 Tere tulemast siis kuundasse loengusse. Tänase loengu teemaks on webi teenuste standardid ja jätkame eelmisel nädalal alustatud sellist webi teenuste teemat, kus me eelmikud rääksime peamaselt sellistest appide väljakutsed protokollideste viisidest nii soobi kui HTTB appi näitel. Ja siis tähna rääkin natuke rohkem, et kuidas on standardiseeritud sellist appide ehitamine, ülesleitmine, kasutamine ja vaatame natuke ajalupku, et kuidas varasemad standardid töötasid ja vaatame siis teises loengosas sellist de facto standardid, mida praegu kasutatakse, et kuidas kirjeldada restful appisid ja kuidas neid kasutada ja kuidas neid genereerida ja kuidas neid dokumenteerida niimoodi, et see dokumentatsioon oleks interaktiivne ja klentidel aru saadav. Et siis rääkime natuke sellist vanadest webi teenuste standardid, sest nagu VSTL, UDDI ja ISIL ja siis teises loengosas vaatame open appi standardid, mis kasvas välja Swaggeri standardist või Swaggeri tarkvarast põhimõttel, et standardiseeritud Swagger on siis põhimõttel open appi. Peepi teenuseid, nagu ma eelmikord sisse juhatasin, on tarkvaramist pakub juurde pääsu mingitele resurssidele internetis ja tegelikult näi väga idefineerike ära, mis asjadne resursid võib olla kasutadest standardiseid webi protokolle üle HTTP appide, mida tavasad veebis kasutatakse. Ja näit, et mida meelmikord tõin on, siis näiteks Google Translate, String Pictures või Reddit. Ja täna vaatame mõnda näidet veel, aga põhimõtteliselt see loeng ei ole nii väga näidete põhine see kord. Ja webi teenuste standardid siis tuhetavadki laialdaselt kasutadustandarditele, et näiteks struktureeritud dokumentide jaoks kasutati algselt peamiselt XML-li, tänabäe rohkem JSON-it. VSTL kasutati selleks, et kirjeldad ära, et misse webi teenus üldse on ja mis meedad, et ta võimaldad. Ja siis tavasad suhtluseaks oli HTTP appid kasutuses, aga SOAP toetab lihtsalt SOAP protokolle üle HTTP. Kuigi SOAP ei pane paika, et peab HTTP-t kasutava. Ja need standardid siis määravad, et kuidas kirjeldada need webi teenuseid, niimoodi, et nad oleks aru saadavad kõikidele arendatele, kõikidele kasutatele. Ja määravad ära, et kuidas otsida webi teenused, et kui te lähete ja tahate näiteks mingisugus Twitter või Reddit ja appid kasutada, et kuste saate selle kirjeldus üldse, et kuste selleks leidate. Alguses vanasamate standardides kasutati selleks registreid, et kus kuhu üles laadida, sest selle webi teenuse standardne kirjeldused sai seda allatõmata, tänapäeval need webi teenuste kirjeldused on pigemselt serverisendased. Et seal, kus asub appi, seal asub üks dokumentatsioon või dokument, mida saada allatõmata ja selle põhjal näiteks klendi genererida, klendi koodi genererida omale meelepärases keeles näiteks Pythonis või CS-Sharpis näiteks. Tänapäeval registrid väga enam ei ole kasutusel, aga need algset, VSTL-puhised webi teenuste standardid, needle ehitad ümber, me paneme üles registrid ja klendid, kes on huvitatud mingilte webi teenuste kasutamist, lähevad registrisse, registrist otsivad webi teenuseid ja vaatavad, mis on nende webi teenuste sisendid ja väljundid ja siis saavad neid kasutuma hakkata, aga need standardid eesmerk ongi siis tagada, et jälgides, et kui ehitame webi teenuseid, mis jälgivad neid standardeid, et siis oleks lihtsalt panna need webi teenuseid omal koostud, tegemed webi teenus A saab allatõmata siis webi teenuse B spetifikatsiooni, majaduse lihtsalt isegi genererida klendi, kudas seda webi teenuse metodeid välja kutsuda näiteks Javascriptis, kui kirjaasad need dynaamiselt seda ei tehta ja siis kasutamakata, et oleks siis nii inim, kui masin loetavad standardid webi teenuste kirjeldamiseks. Et nad oleksid platformist sõltamatud, et nad oleksid skaleeritavad ja nad lihtsustaksid üldiselt sellist, lisaks koostulega sellist süsteemide integreerimise ja automatiseerimist, et oleks lihtne tekitada rakendus, mis näiteks oskab Redditi appid kasutada ilma, et peaks nagu programeeria liiga palju tööt tegemad. Täna päeval on väga lihtne tegelikult, nagu näiteks Pythonis mingisuguse suvalise webi teenuse klient genereerida, kus klient on täiesti valmis tarkkora, mida saab kasutada oma Python programmist välja kutsuda. Et kui teile on mingisugune keerulne hard tab appi ja neil on open appi spetifikatsioon, siis teie ei piagi iseimplemeteerima metodeid, kuidas näid open appid metodeid välja kutsuda, vaid saaksid võtta open appi spetifikatsiooni, valida programeerimis keel ja klienti tarkkora valmis genereerida. Ees oma Python koodist võib-olla kutsuta kledi tarkkora metodeid välja, et saata mingit anmed parzida või vastu võtta. Meil selle nädalu praktikumis pigem nende klientidega väga ei tekele, et me genereeerime serveri tarkkora pigem kui klienti tarkkora. Ja see üldiselt näid webi teenused, webi teenuste standaardid võimaldavad siis sellist teenustele orjenteeritud arhitektuurie, et suuremate tarkkora komponendid ongi webi teenused, mis oma vahel suhtlevad, üks teise metodeid välja kutsuvad ja keerukamad susteemid luvakse nende kombinatsioonine, nagu service composition, et ma panen mitmed teenused kokku. Täna päeval selle ase on pigem kasutatakse termi nagu mikro teenused või pilve põhised lahendused, aga enne pilvede tulekud näid pigem nimetati nagu service-oriented arhitektuurideks, et kui kõik suuremad, kõik tähtsamad komponendid osad olid webi teenustena või teenustena üldiselt. Ja need omadused, mis standaardeid jälgivatel webi teenustel täeksid siis olema või on, kuna nad jälgivad standaardeid on taas kasutatav, et oleks lihtne seda sama appid nagu uuesti genereerida näiteks teises keeles, et oleks lihtne nende appid jaoks klente genereerida suvalises progameerimes keeles, mida teie asutuse klendid näiteks soovioad oma rakenduses kasutada, mis teie webi teenuste metodeid välja kutsuvad. Interoperability-t koostalitus võime, et oleks lihtne panna mitmed webi teenused oma vahel rääkima, selle ka on sietud integratsioon, et meil oleks võimalik panna näiteks anmebaasja appi oma vahel rääkima, niimoodi, et anmebaasist oleks lihtne tõmat anmed ja saata näiteks mingis appisse või vastupidi, et mingist appist tula, et anmebasja oleks lihtne panna, et luua sellised anmeintegratsioona. Komponeeritavus, et me saaksime gerukamad süsteeme ehitada, niimoodi, et me kombineerime neid webi teenused, mis on kätes aadavad näide süsteemide poolt ja ehitama gerukad süsteemid pannas neid webi teenused oma vahel suhtlama mingisugus loogikaga. Lisaks veel ka leitavus, sest meil on tegelikult tähtis ka see, et kuidas me üles leian, kus asub näiteks mingisugumne Twitteri appi või kus asub Tartu Ülikooli mingi õisi appi, ja selleks on mitmeid viise, tänapäeval käib see niimoodi, et te lähed appile ja te natuke eeldat, et sellel appi kõrval mingisugus selle alamaadresil on see appi spetsifikatsiooni dokumeet, mida saate allatomata ja mis kirjadab ära, et midas appi toetab varasemalt kasutatud siin rekistreid selleks, et kuidas otsida üles, leida näid webi teenused, mida saab siis välja kutsuda. Webi teenuste sisemine loogika on peidetud, kasutajateist nema näevad ainult seda rakenduse, programeerimisliidest, et appi liidest, ja te teate, mis on sisendid ja väljundid, aga te ei tea täpselt, kuidas see implementeeritud sisemiselt on ja koodi generaatorid ka, et klendiosa oska täiesti genereerida, serveriosa pikem genereerideks niimoodi, et teil on vaja ikkagi sisemine loogika ise implementeerida. Autonoomsus, et iga webi teenus oleks suhteliselt ise seisav, et ta ei sisemise, ta ei tohiks väga nagu sõltuda liiga palju välistest süsteemidest, et põhimõttelselt see tähendab seda, et kui teised webi teenuste kokkujooksevad, siis see webi teenus võiks töötada ilma teistet, aga see ei ole alati võimalik. Pikem see, et iga webi teenus vastutab ise oma sisemise loogika eest ja kui te ta kasutatakse mingite teiste lahendustega komponeeritult või mingit integratsioonid on selleks süsteemi ja teiste vahel, et need kõik lähed katki, kui mõtegi üks osapuole ei tööta tavalselt. Eks see oleneb, et kui meil on näiteks mingisugune süsteemist soovib kasutada ilma teenust ja ta kasutab ilma teenusapid, siis see, et üks ilma teenusapi on maas, võib-ala saab teisi ilma teenusapid kasutada, et mõnikord see olemb, kui üldine sõn, et kas me soovime kindlata oma süsteemi sisest apid kasutada või me soovime suvalist ilma teenusapid kasutada. Nad peakse olema lahtiselt ühendatud, ehk nad võiksid eksisteerida iseseisvalt ja üks veepi teenus kokku jookseb, see ei toeks väga mõjutada teisi veepi teenuseid. See ole alati võimalik näiteks olukorras, kus me loome uue veepi teenuse, mis sõltub kahest veepi teenusest, kutsub välja näiteks ilma teenuse ja kutsub välja mingisuguse bussi sõitmisaegade teenuse. Ja kui üks nendest kahest teenusest ei tööta, siis see komponeeritud teenus ka ei proovi töötada. Näiteks meil on mingisugune delta maja ruumide pukimist teenus, et me saame ruumi kinni panna, aga kui see õisi teenus, mis ütleb, kas ruumist praegu midagi toimub või ei toimu, on kätki, siis eka see teenus ka väga miselmist teenus kasutab, ei oka ei tööta. Alati on, et pigem see räägib nagu nendest sisemistest loogikatest. Ja üldiselt peaksid veepi teenust olema staatuseta, stateless, et iga päringud peaks käsitlema nagu ise seisvana. Et see ei ole nii rangenõue, aga see aitab ehitada skaleeritavad ja törkke talu või teenuse, et kui teenus või tarkvarja ise jätab midagi meeldelmist ja päringute kohta, et siis on lihtsam jaotada, sisse tulad liiklust ja skaleerida süsteeme. Et see staatuseta nõua on natuke nõrgen nõue kui maned teised. Üks esimesi sellised veepi teenuste standaardeid oligi, siis web service description language, ehk VSTL, kus kirjeldad erad, kui meil on veepi teenuse implementatsioon ja meil on veepi teenus kuskilt internetis kätte saadav, mis on protokollid, mis kasutataks, kas näiteks SOAP või HTTP, kus mis on need metodid, mida toetatakse selle veepi teenuseest. Ja meil tekis selline VSTL dokument, kus XML-is kirjeldatakse kõik vajalik ära selle veepi teenuse kohta sarvasad nagu meil SOAPi spetsifikatsioonil ja põhimõttel ongi see enam, et me põhimõttel defineerim ära, et mis on selle veepi teenuse nimi, mis on tema metodid, mis on sisendid ja väljundid ja meil on sen XML-file. Ja see XML-file tavalselt panaks ja kuhugi rekistrisse ja seda saab seda rekistrist alla tõmmate ja siis kui me oleme selle dokumenti alla tõmmates, me saame nagu parsed XML-i ja lugeda sealt, et mis veepi teenuse sellised sisendid, väljundid ja spetsifikatsioon nagu üldiselt on. Lisaks oli meil Universal Description Discovery Integration selline dokumentatsioon või dokumentid, mis olid ka XML-i põhjine standard, mis kirjeldab ära, et kuidas otsida ja leida veepi teenused, mis on nende nagu sellist adressid ja kus nad asuvad. VSTL-i põhjal me kirjeldasime ära, et mis on selle funksionaalsus, aga UDDI põhjal me kirjeldam ära, et mis on näiteks selle veepi teenuse mingisugused täägid, et kas ta on ilmaga seotud, kas ta on millegi muuga seotud ja selle spetsifikatsiooni põhjal sai otsida veepi teenused kuskid rekistrist ja leida see info, kus see veepi teenuse asub, mist tema adress on, kuidas ta välja kutsuda, et mis porti taga ta näiteks on sellist infot. Ja lisaks oli ka selline VSIL, kuna sellist kesksed rekistrit, kus me need dokumentid paneme, me peame teadma, kus need kesksed rekistrit kaasuvad, aga kui me näiteks teame, et me soovime Redditi appid kasutada, me teame, kus asub Redditi adress, aga me ei tea, kus asub rekister, kus asub Redditi sees, ütleme, VSTL dokument, et mis rekistrisse dokument asub, kus me alatõmbame, siis tehti veel eraldi selline spetsifikatsioon nagu web services inspection language, mis võimaldas saata teatud struktuuriga päringu Redditi serverisse, mis ütleb, küsib, et kus asub sinu appi spetsifikatsioon, et kus ma saan selle VSTL dokumeeti alatõmata ja see oli nagu vastupidine lahendus siis rekistril, kui sa ei tea, kus rekister asub, siis sa kasutad seda viisi, et see spetsifikatsioon alatõmatad, et oligi XML puhinspeksifikatsioon, mis siis defineerib, kui tas otseteenuspakku elt, et otseteenuse adressilt hostneimilt küsida siis tema poolt toetatud webi teenuste kirjeldusi. Ja tänapäeval pigem kasutatagi seda lähenämist, kui rekistrite lähenämist, et kui me teame, kus asub Eesti reati asutuse mingisugune aadress, siis me saame tolle serveri käest pigem otsida ja küsida, et kus on sinu appide spetsifikatsiooni fileid ja kas ma saan et alatõmata. Ja põhimõtteliselt, et kui meil on klient ja mingisugune appi pakkuja või appi implementeerija või appi server, siis selle appi implementatsiooni jaoks on meil siis vstl kirjeldus. Tihistise vstl kirjeldus võib eksisteerida enne, kui meil on üldse implementatsioon, sest vstl kirjeldub ära, et mis on neid metodid, mida peaks implementeerima, siis on tihti loogilne teha see vstl enne ja pärast seda siis isegi saab genereerida kogu serveri sellise skeletoni, implementeerida sellise skeletoni ja kui meil see appi on olemas, siis kuskil peab eksisteerida see file, siis see appi pakkuja siis kas hoolitseb sellest, et see vstl on siis VSIL stiilis serveeritud kusagilt samast serverist või vähemalt server ütleb, kust asub. Ja nii, UDDI kui VSIL ka linkivad oma info selle vstliga, et UDDI kaudu me saame siis otsida, kus asuvad serverid, et klient, kes soovib seda appid kasutada, ta saab küsida UDDI rekistritest, et mis webi teenused on olemas, või ta saab siis otsa serverist küsida VSIL speciakatsiooni või lähenämise põhjal, et mis on sinu serveri poolt toetatud appid. Kui ta kus server asub, seda saab otsida serveri, kes kui ta ei tea, kus server asub, seda saab otsida rekistritest. Ja põhimõttel ta saab nende kaudu selle vstl ja plus ta saab ka selle server asukoa ja klient saab nüüd selle vstl põhjal näiteks genereerida nüüd selle koodi, et kuidas need metodeid püüta nis väljakutsuda, kuidas need metodeid C++-is väljakutsuda või siis näiteks mingisugune, mingisugune organisatsiooni arendaja, siis implementeerib selle vstl põhjal selle klienti tarkkuvara ise, et kuidas need metodeid väljakutsuda. Et siis UDDI ja VSIL olid sellised viisid, kuidas nagu neid ülesleida ja vstl on siis kirjeldus. Moneks asjad juba rääksin ette ära, et vstl siis põhimõttel saab vastab küsimustel, et mis operatsioone see webi teenus pakub, misugust on parametrit ja tagastusväärtused, siis sisendid ja väljundid, mis muode and-meid edastatakse, et kas meil on JSON dokumentid, XML dokumentid, raw stringid või mingid pinaarsest striimiid, mida me peame edastama ja mis adressi ja protokolliga ligi pääseb. Ja ligi pääseb tavalselt on kas soap või HTTP ja see on mõnesemate sarane elmekordselt soapi appide kirjeldus ka toimus. Vstl sisu, et see on siis spetsifikatsioon, mis kirjeldab appi olemuse ja standardiseeritud viisil, siis tavalselt koos näeb taipides, ehk and-meid tüüpidest ja tavalselt on XML dokumentide väärtuse tüüpid. Koos näeb sõnumid, et mis on sõnumid, mida edastatakse kas serverissa või server saadab meile, mis on and-meid tüüpid, mis on XML struktuurid, mille see sõnumid on, mis on tagide väärtused ja tüüpide nimed. Lisaks on sellised porti tüüpid ja portid, mis tegelikult defineerivad sellised meetodid, mida saab välja kutsuda teenusest. Ja siis on lisaks sellelega sellised bindingud, mis määravad seosad and-mei vahetuseks, kas me kasutame soapi, kas me kasutas HTTP-ed. Ehk meil on meetod, mida saab välja kutsuda, ja meil on binding, mis ütleb, kuidas seda meetodid saab välja kutsuda, sest meil võib eksisteerita meetod, näiteks get-veter-info, aga meil võib eksisteerita kaks bindingud. Üks ütleb, et sa saad HTTP-abil selle meetodid välja kutsuda ja teine ütleb, et sa saad soap-able meetodid välja kutsuda, et HTTP-s sa peaksid kasutama JSON-id, aga soap-is sa peaksid XML-i kasutama, et see binding paned paika, kuidas need meetodeid või siin definitsioonis portidega suhelda või need meetodid välja kutsuda. Ja see on ka selline üldine kirjeldus, nagu service, mis kirjeldab ära selle webi teenuse nime ja kust ta asub. Ma toon ka mõned näited, kui kui need näited on väga sellised keerulisede XML-puhised. Näiteks, siin on siis selline üldine veestel näite, kus ma olen teatud asjad ära peitnud, et meil on siis üleva sellised XML-i meta-anmed sammut soobi puul, et meil on kirjeldus, et näiteks, mis sukuseid XML-i namespace-i me kasutama, et kui me tegeleme soobi, kõist me peame ka mingit soobityübid ära paika panema, siis meil on veesteli mingisugused namespaces kirjeldatud tüibid, et mis näed põhimõtteliselt tagid tähendad, et kui meil porttab, mida see porttab, siis veestelikontekstis või veestel namespaces siis tähendab. Ja sisameil siin kaks tüüpi sõnumitest, mul on ära peidetud, mis selle C-s on, aga et meil on kaks sõnumit, üks sõnum on get last trade price input ja tein on get last trade price output, et meil on siis mingisugune, vistas siis oli, stock marketi hindade küsimise appi ja meil on siis kaks sõnumit ja meil on üks selline binding ja meil on üks teenus, see teenuse nimija stock quote service, see on selline, et me saame nagu seda stock quotei või stock market hindasest küsida siis selle teenuse kaudu, siis on meil selline metodikireldus, mida me defineerime porttabina, et meil on stock quote porttab ja selle alla on metod get last trade price, et mingisuguse aktiahinna küsimine siis. Ja siis on meil kas, et meil on see metod, aga kuidas seda metodid saab väljakutsuda, kui me ei defineeri, et kas meil on, kas me tovetame soapi või Http appi kaudu väljakutsumist, et me saame defineerida neb bindings, mis ütlevad, et seda get last trade price saab väljakutsuda, siis soap binding-u abil meil on soap üle Http ja siin on see namespace, mis kirjelda pärat, misugused spetsifikatsioonid peab kasutama, et kui sellel viisil ühendust otta, et XML-spetsifikatsioonid on salati igasugused namespace, et siin on mingisagu transporti namespace, et kuidas siis suhelda selle get last trade price metodega. Ja kui me peaksime tovetama veel ühte teist viisi, kuidas suhelda, siis me saaksime veel ühe binding-u luua, aga meil on üks metod, üks binding, aga meil võib selle sama metod ja aga kaks binding-u. Ja siin on siis neid tüüpide definitsioonid, et kui meil on type, on siis stock, code, port type ja get last trade price, siis trade price request. Ma vaatan, kest on siin välja toodud. See on vist mõnes alam osas, mis on praegu peidetud. Et siis me saame tefineerida ka tüüpid, et meil on trade price request-tüüp ja trade price-tüüp. Need on siis nende kahe sonumi alam tüüpid vist, mis on siis get last trade price inputis ja outputis. Et kui me saadame, siis requestis me peame ära defineerima, et mis aktiat me aktia hindame küsim, et meil on siis sellel ticker symbol sees, et meil on nagu kompleks type, milles on all ja siis element name on ticker symbol ja kui me tekitame sellise sõnumis, me peame selle ticker symboli määrava. Ja vastu tuleb meil siis selline vastus, kus me saame lihtsalt price-i. Me isegi ei saa seda ticker symboli tuuesti, me saame lihtsalt price-i, et mis oli siis selle ticker symboli hind praegu selle hetkel. Sõnumid siis defineerivad, et meil on get last trade price input ja get last trade price output ja see määrab, et nende sisu ongi täpselt see ja see, get trade price ja get last price request. Me peame sõnumid defineerima, mille see on sõnumielement ja siis sõnumielement on täpselt see tüüb siin. See on suurselt keeruline, mitmatasemeline ja nüüd me defineerime, ka siis stock port types on siis nagu metod. Metodi nimi on get last trade price ja metodi siis see defineeritakse, et mis on sisend ja mis on väljund sõnumid, mida tuleb saata. Nend sõnumid on küll kirjatatud XMLis, aga need reaalselt peab saata JSONis, et kui meil on binding, mis defineerib siis JSONi. Ja lisaks on meil siis binding, mis panab ka need inputid ja outputid põhimõtteliselt paika, et meil on get last trade price operatsioon ja defineerib siis subactioni, mille nimi on get last trade price ja siin juba defineeriteks, et kus sa asub. Siin bindingu defineeritakse ka see, et kus asub see aadress, kus saab seda välja kutsuda. Siit saab teada, et me kasutame soapi üle HTTP, kun nad CSP-etioon on linkitud, siis transporti allat see määrab, et peab soapi üle HTTP kasutama, kus seda bindigud kasutatakse. Ja... Ja teenus ise on siis selline üldin info, et mis on selle web-teenuse nimi, mis on selle web-teenuse portid ja bindigud, nii et see on nagu lisalt põhimõtteliselt linkib kõik nad asjad kokku, et see teenus toetab seda meetodid ja selle meetodid siis tuleb seda bindigud kasutada ja siis saab määrata, et kus asub see soap-appi server, et siin on veel üks võimalus seda paika panna, kust ta asub. Nii et on suhtselt selline keeruline, aga ta on sellesmatsemas asi loeta ja kõik vajalikud sellised... kõik vajalikud, kus mul see transport siin on, kõik vajalikud, nagu tüibid on ära määratud, et see ka tähendab, et sellised spetsifikatsiooni põhjal on võimalik genereerida, siis kas klient või server, et mis oskeb sellist meetodid siis implementeerida või sellist meetodid väljakutsuda. Toon ka ühe kiire selle uudid.ai näite, et kuidas seda webi teenuste otsimise jaoks kirjeldatakse need webi teenuseid, et võib-seda saa moodi lihtsalt appi, mida saab ülesõuprotokolli väljakutsuda, ehk me saame registrist ülesõuprotokolli siis küsida, et mis webi teenused on sellest registriss kirjeldatud ja saame nende spetsifikatsioon alla tõmata tänapäeval kasutatakse suhtselt vähe, et sellised globaalsid registrid ja alati teadmise vajaduse, et kus need registrid selle meid huvitava appi aaks on, on suhtselt tüutu, nagu klientilad on alati selgitada. Aga see näiteks välja selline, et meil on sellised kiit referentsid, et me saame ära määrata, et mis on sellised tüibid, vstl-taipid, service namespaces ja service local names, et vstl-taipid on service, et on webi teenus, me saame ära, et misugust namespaces kasutab, tal on enda mingisugune xml kirjeldus kusagil, example.com.stockaut, et seal saab alla tõmata siis selle kõik need tüibid spetsifikatsioonid, ehk põhimõtteliselt webi serversi võeldeks, et meil on sellise nime ka teenus, ta on webi teenus ja service type ja tema selline spetsifikatsioon asub siit, et saate selle alla tõmata, et tema xml spetsifikatsioon asub seal ja sellest tema namespace-is kirjeldeks ära tema meetodid asjad ja põhimõtteliselt mõnes mõttes see ongi nagu vaelik. Okei, ma olen natuke selgitas, et seda valesti, et see on pigem nagu otsimisepäring mitte see kirjeldus, et me otsime siis webi teenust, me ütleme, et me otsime webi teenus servisid, me otsime teda sellise nime ka ja kui me teame, siis me saame ka määrata, et kus on tema nagu namespace, et see on pigem nagu otsimisepäring mitte see kirjeldus, mis serveri asub. Et see oleks siis meie soappäring, mida me teeme siis uudeteai rekistrisse, et otsida webi teenust, mille nimi on Stock Code Service. Ja vcl on siis alternatiiv rekistripõhj selle webi teenust otsingule, et kui see uudeteai on sellised centraliseeritud, et me peame teama, kus asub see centraliseeritud rekister, siis vcl on pigem decentraliseeritud, kui me teame, kus asub reddit ja tahame reddit-appid kasutada, siis me saame proovida serverist lihtsalt vaadata, et kas ta toetab vcli. Ja kui ta toetab vcli, siis me saame vcli specialkaudu või protokolli või lähemise kaudu küsida, et mis on sinu serveri webi teenus, et mida selles serveris hostitakse. Ja põhimõttel servelil tootse küsida, ana mulle kõik kirjeldused ja siis ma valin nende seastu või otsin nende seast. Et me põõrtumis otsi teenuse pakkuja poole, kaapi serveri poole ja küsime, mis on sinu pakutavad teenused. Ja me ei pea siis teadma, kus võiksid asuta rekistrid, aga me peame teadma, et kus asub mingisugune organisaatsiooni portaal või serveri aadress, et seda väljakutsuda. Aga see on väga tüüpilne, et me teame seda. Seda saab pigem siis kasutada, kui te teate, mis organisaatsiooni webi te soovite kasutada. Nendeks ilma teenuse puhul te teate, et te soovite tõravere ilma teenust väljakutsuda, siis lähete tõravere ilma jaama aadressil ja küsite tõravere ilma jaama käest. Aga kui te soovite nendeks suvalist tartu ilma jaama kasutada, et siis võib-olla oleks mõistliku mina rekistrisse küsida, mis on tartu ilma jaamad apid. Ja siis saate alla ja valite ühes nendest, et see WCL lähene minu, et te teate konkreetselt api teenus pakkuvad, kelle apite taad väljakutsuda. Ta näeb välja umbes selline, et meil on WCL dokument organisaoni kodulehel. See kirjaldab ära kõik teenused, mida see organisaonime systeem pakub. Ja teenuste kirjaldus üldjuhult jälgib täpselt seda sama WCL standardid, millega me enne defineerisime need stock-out metodid ära. Ja põhimõttiselt kusagil asub selline dokument ja me saame sealt leida, mis on WCL dokumenti asukoht. Et kui meil sellest dokumentis on teenuste list ja meil on üks teenus, siis see teenuse blok kirjaldab ära sellest stock-out service metodi. Siin seeks kirjaldab ära, et kust ta asub, mis serveri aadadesi, mis porti peal, et kust alat omata selled teenuse kirjaldus vest L-file. Ja lisaks, et kuidas seda teenuste ennast väljakutsuda, et mis on sellel appi enda endpointi või appi host aadressed. Kust kuhume need soap sõnumid saadame, et seda teenust väljakutsuda. Ja siis idee on, et kui sellest serveri on 10 teenust, siis siin on laks 10 erinad serviceid. Ja klient peab siis vaatame selle X ja M-l läbi, vaatame need 10 teenust läbi ja ise otsima sealt selle vajaliku teenuse, mida ta soovib kasutada üles. Et kas siis ilma teenuse või midagi muud. Et see WCL on siis palju lihtsam näide selle kohta. Kuna soap on siiamaani kasutuses, siis neid asju tihti kasutatakse just sellist vanametasysteemides, aga ka näiteks VSTXD-s on vanemalt teenused kasutavad siiamaani soap. Ja kül vaikse prooviteks nad üle tuua HAT-TP appide peale, aga sellised... Ma asiin lohetavad kirjaldus on tegelikult väga kasulikud, sest nende puhel, eriti VSTL puhel saab lihtsalt genereerida selle appi väljakusjade klienti tarkko raja, seda kasutam hakkata. Aga pigem tänapäe olen kasutuse, siis Swaggeri või Open Appi spetsifikatsiooniid, et kirjaldada ära HAT-TP ja RESTful appisid. Ja see on ka see, mida me praktikumist kasutam hakkame, et eelmine nädal te ise implementeerisite selle HAT-TP appi kasutades Flaski. See nädal, mis me teeme, me võtame minu poolt valmis tehtud sellise Open Appi spetsifikatsiooni, kus on üks meetod puudu. Ja teie ülesanne on siis võtta see Open Appi spetsifikatsioon, kasutada Open Appi generaatorit, et genereerida täpselt samasuguna appi, Flask appi implementatsioon nagu eelmisest praktikumist ja siis see tööle panna testida seda ja kõik meetodid ära implementeerida ja üks, siis mina takas ja üks puuduole metod sinna spetsifikatsiooni ise lisada ja siis uuesti kõik see asja läbi teha. Elmikord me tegime appi käsit, siis see kord me võtame ette spetsifikatsiooni ja genereerime nagu serveri skeletoni selle spetsifikatsiooni põhjal ja ainult implementeerime meetodite sisu, et me siis enam ei pea muretsama nende serveri üldise logika põhjal ja me saaksime Flaski asema näiteks fast API kasutada või Python aseval mingi teist progameerilis keelt kasutada. Aga open appi spetsifikatsioon muutus standardiks, kui Swagger sa jästi populaarseks ja põhimõttelselt võib üldada open appi spetsifikatsiooni nimi ennali Swagger. Ja põhimõttelselt me loome sellise YAML-i või JSON dokumenti, kus kirjeldatuks ära kõik appi meetodid, kõik appi meetodid sisendid, kõik appi meetodid te väljondid ja põhimõttelselt see ongi mõnesmedes kõik. Natuke sarnaselt nagu eelmised XML-id, aga samas lihtsustatult. Ja ta on rohkem inim loetav võrraldes XML kirjeldustega või spetsifikatsioonidega. Me kirjeldam ära kõik resursid, nende lõppunktid kirjeldused, mis iga mis meetod, hated ja operatsioonid, kas ket, post, delete, put on lubatud nende resurside peal. Me genereeme ära, või kirjeldam ära, mis on sisendid ja väljondid. Open appi specijik on, et see onis me ei pea kirjeldama, mis on sisendid ja väljondid. Me võime tegelikult ka sisendid ja väljondid täiesti kirjeldamatuks jäta. Ja see ei ole küll hea standaard, aga põhimõttelselt me ei pea olema nii ülikirjeldav, kui soupi ja XML-i puhul. Lisaks me saame ära kirjeldada asjad nagu autentimne. Me saame paikapanna, et see meetod, et selleks, et teha ketpäringud või deletepäringud, peab kasutama appi võtmeid. See meetod, et sisse logida peaks kasutama kasutenime ja parole või midagi muud. Me saame isegi määrad, et kus need autentimis info peab olema, et kas on näiteks mingisuses kindlas, Http, header-väärtuses, mille nimi on, appi minus key näiteks. Ja tihti saab seda spetsifikatsiooni kasutada ka lihtsalt rest-appi dokumentatsioonina, et arendaja saab minna ja lugeda jambli ja aru saada, et mis on meetodid, mis tootadakse, mis on sisendid, mis on väljundid. Ja ta on selline suhteliselt inim loetav. Natuke rohkem inim loetav, kui ta on jamblikujul, aga nii jamblikujul, kui Jason on tänapäeval täitsa tavaline anmete kirjeldamise standaard arendatele, nii et ta on suhtselt hästi inimia masin loetav. Ja üks väga suure eliseid, miks swaggerid kasutati on see, et selle open-appi või swagger spetsifikatsiooni põhja saab genereerida täis väärduslikku serveri kodi, et te kirjeldate jambli sõna need meetodid, endpointid, mida soovite ja siis kasutad, annate selle sisse genereerijale, genererijal kirja, implementeerib teile jaava spring-kodi, kus on ainult meetodide sisud puudu ja oleneb sellest, mis keelde, mis raamistikude genereerite, te tihtisaate ka teatud meetodid, nagu kuidas parsida Jasonid, kuidas valiteerida, kas Jasonist on midagi puudu, kuidas autentida näiteks fast-appis, genererib ka sellised autentimise meetodid, mis kontrollivad, kas appi võtja on olemas või mitte. Et see teab tegelikult väga palju tööd arendate ja aks ära, kui seda spetsifikatsiooni kasutada. Sellega on omad nagu sellise puudused ja probleemid, aga ideeliselt väga tohutult kiiresti saab lihtsa prototypid ja me mõnesmõttes mängimegi selle praktikumis läbi. Me kasutame peame Jasonid ja Jamli open-upi puhul, kus XML kõist kasutati pigem nende varasemate standaardite puhul. Ja näid erinevse on põhimselt täpselt samad, et meil on mingisugused tagid, meil on mingisugused, tavaselt iga reapeal on mingisugud üks väärtus. Ja kui Jamli ei ole kasutad, siis Jamli on üks ühele sama, mis Jason, aga sellist sulgutasemel kasutatakse pigem nagu ridasid ja püütanis arnas sellist neid tühikutatud tasemet, et samal tasemel olevad väärtused on põhimõtteliselt sama bloki sees. Kui meil on siin Jason, kus on serverite list ja serverite listis on üks Jason, alam Jason, milles on neliväärtust, siis Jamli näeks sama välja niimoodi, et meil on servers ja siis meil see miinus määrab, et see on list. Et iga miinus on siis järgmine listi element. Et kui me siia paneks miinus, siis me saaksime järgmise listi elementi panna neljaga. Ja kui meil on siin list ja listis on üks miinus ja neliväärtust, siis järgmine list on oma korda üks block, ehk üks mõnesmõttes Jasoni block, mis on ühe listi elementi. Et kui servers on list, siis siin ei ole listi neliväärtust, siin on listi üks väärtust, mille sees on neliväärtust. Et kui te ei ole Jamli väga kasutand, siis ta võib natuke keeruline algustus olla, aga ta on võimõtteliselt üks ühel aru saada, kui Jasoni on mõnikord natuke raska aru saada, mis on miinused tähendavad ja muut sellist asjad. Ja näiteks komasid ei pea kasutama, aga me kasutama täpselt samasugused kooloneid, aga reaal öpu komasid ei pea panema. Et Jasoni saab teha ühereaaliseks dokumentiks, et te võite kõik tühikud äraemaldada, noh tühikud pead jääda, aga kõik reaa vaahetsud saada äraemaldada, et Jason võib olla ühereaaline, aga Jam peab olema mitme reaaline, et Jamlis on see rida siis nagu kirjet eraldaja, kus Jasoni see nagu komad või sulud kirjet eraldajad. Ja see on Open Appi specialkatsioon, näb välja niimoodi, siin on sada rida, rohkem kui sada rida, ütleme, et 110 rida ja ma olen jälle natuke kombineerinud teatud read, aga mis meil põhimõtteliselt siin on, et meil on siis Open Appi versioon, et siin on 3.0, kõige viimana viss 3.1, siis on meil Appi info, et meil on Appi versioon 1, siis Appi peal kirjan Swagger Pet Store, see on selline tüüpiline Swaggeri näide, me võime siin defineerida licensi, et näiteks meil on MIT-licens, täiesti vabavaraline, see nüüd tegelikult natuke oleme, millele see licens on, et kas see saab olla Appi koodile, kui Appi koodi seal avalik, et pigem, et on sellel specialkatsioonil licensi. Ja siis on meil, et kus asub server. Ja see server aadres on tegelikult väga kasulik hiljem, kui ma näitan seda interaktiivse dokumentatsiooni, siis see tegelikult ütleb, et ma saan siin aadresil siis hakkata tegema slash endpoint päringud ja saadma sinna ketvui postpäringud. Siis pääsid alla meil kõik endpointid, et näiteks pets ja pets pet ID ja nende endpointide või otspunktide alla on siis need meetodid, et pets toetab siis ketvui postmetodid ja pets ja siis mingi konkreetse koduluoma IT alla on siis ketvui meetodid, et me ei saa koduluomi kustutada, aga saame uusi koduluomi luua ja allaatamata. Me saame koduluomade. Nüüd kui te siia peale vaatad, et kas keegi oskab mulle vastata, et mis meetodeid see appi toetab? Litsad nende otspunktidele ja meetodid peale vaatades. Mida? Aga mida see ket teab? Et küsib kogu petide nimekirja. Mida teab post? Teab uue koduluoma ja mida teab see ket? Otsib siis koduluoma infoeles. Seda ma elm, et puhtalt ilma teadmata, mis on sisendid väljundid, ilma teadmata, mis on kirjeldused, et ihti saate loomulikult aru, mida need meetodid teevad. Koduluomade. Koduluomade. Võraldes nende soap-metodid, et see on selline hästi kokku pakitult, hästi lihtne, nagu aru saada, mis see on. Aga see oleneb ka sellest, et kas arendaja on siia õiged nimed pannud ja et ta ei ole siia midagi väga segast kirutanud. Et sellisele juhula asjad läheb keeruliseks ja tänapäeva appidel võib siin tegelikult olla. Toys slash transactions võideks sellist ja võib palju-palju keerulisemaks minna. Aga põhimõtteliselt selline lihtne appi on hästi aru saadav, kui me kasutame HTTP ja RESTful lähenemist. Iga selle blokki sees on selle kettikirjeldus, selle postikirjeldus, selle kettikirjeldus. Ja siis meil on komponentid all sellised linkitavad infot, et me saame siis defineerida, mis on kodulooma objekti-alamväärtused. Ja see on hästi selline objekto-orienteeritud lähenemine, et me defineerime ära, mis on kodulooma-alamväärtused. Võite kirjalda seda, et meil on pet-klas, meil on pets-klas ja meil on error-klas. Ja siin defineeriteks ära, et mis on siis tavaliselt kodulooma sellised omadused, midada appi kaudu edastate. Et kui me loome uue postiga uue kodulooma kirja, ja siis siin skeemadal defineeriteks, et kui luoks uus koduloom, mis need alamväärtused peaksid olema. Et kas seal peaks olema kodulooma nimi, vanus, mingi muu infokodulooma kohtad. Mis tüüpi koduloom ta on? Kas ta kass või koer või mingisuguna muu koduloom, et ja mis on tolle kassi omakorda tüüb näiteks. Võimust, et võite mõelda, et näite, nagu Anne Paasi jaaks siin, ega vajalikult, et defineerid ära, et kui meie appi tegele koera, et mis on siis kodulooma kirjed, mis Anne Paasi peaks kirjutama, kui appisse tuleb uus post pairing. Nüüd vaatame natuke lähemalt, mis siin nende igasees võiks natuke olla. See peamine meta on, et block on täpselt samamise enne, aga seal saab olla ka näiteks kontakte, et kui tal on küsimusi selle appi koht, et kelle ka ühendust võtta, kus on mingi dokumentatsioon. Litsens võib ka olla keerulisem, et näiteks saab padse konkreetne litsens koos linkiga. Kui me hakkame serverit alla, vaatame, mis võib meil ei ole ka kolm serverit, näiteks, et meil on development server, staging server ja protraksion server, et me saame need aadres isegi meeldese jäta selle spetsifikatsioonis. Eriti siis on kasulik, nagu developerid teaks, et kui te ojate oma GitHub'is sellist spetsifikatsiooni, siis developer saab arjenda minna vaadata, kus on staging ja kus on development server. Ja päevside all on siis meil kõik sellise resto-info, et kui meil on siis üks endpoint kodspunkt pets koduloomad ja seal on ket, siis keti all kirjaldama tavast ära üldise kirjalduse, et siin onki, et return all pets from the system that the user has access to. Ja tavast on neid partitsioneeritud kasutaja kaupa, et kasutel on teadud õigus, et näiteks enda poolt sisestatud koduloomi näha või siis on vastupite, kõikikoduloomi, et see olema siis implementatsioonist, et kuidas partitsioneeriteks need andmed. Ja siis pärast, kui meil on description, ketipuul meil tavastat sisendad ei ole, meil võivad olla parametrit, aga siin näiteks meil parametrit ei ole, et me siin defineerime, et kui sa saadad ketpäringse hapisse, mida sa vastusena saad ja vastusall on tavastat plokid koodidest. Et kui tuleb kood 200, mis seal all vastu tuleb, kui tuleb kood 404, mis stiilis vea teade, siis on, et kas tagastab sulle mingi chase ödi või ta on täiesti tühi vea teade, aga 200 puhul on see tavalselt, et see on okei kood, ehk päring läks läbi ja siis selle omakorda selle koodil võib olla kirjeldus, et siin sees on list of pets ja siis kontent ja all on, misse list siis sisaldab. Siin kontent ja all on, et meil on jason ja jasoni sees meil on jasoni schema ja see jasoni schema sees, et meil on array, nii et meil on jason, kus on siis list ja sest listis on itemid, kus iga item on selle skeemaga. Ja siin me veel ei ütle, et mis selle kodul oma vääritus, et me lihtsalt linkime eraldi skeemale, mis on selle dokumenti põhjas ja see on ka senne objekto-orienteeritud stiilis, et me ei pea seda kues kohas muutma, et me saame seda ühes kohas muuta ja siis lihtsalt linkida sellele. Ja et meil on lihtsalt põhimõtteliselt jason list jason list jason list jason dokumentid, kus iga jason dokument vastab siis petile ja meil ei ole selle listil nagu võtit, et meil ongi lihtsalt list jasonitest. Põhimõtteliselt põres mõttes me jätame selle jason võtme listi võtme nagu abstraktieks. Ja lisaks, kui meil on nagu, et ket, siin on mis võib-olla väike viga, a, siin ei ole väike viga, see ma olen lihtsalt endpointi ära unustanud, et on selle üksliid ja ülelpohle, et ma olaks võinud seda endpointiga näidata. Et endpointis on siis lisaks petile ka PetID ja seal on siis kirjeldused, et me saame konkreetse kodul oma info ja seda otsib kodul oma ID järgi ja me paneme paikaga ket-pets-paj-ID, et kui siin on, siin seda metodi nime millegi põres lihtsalt ei ole, aga see ket-pets-paj-ID see määrab, et kui genereeritakse selle spetsifikatsiooni põhjal püütan metod, mis on selle püütan metodi nimi? Et see määrab siis nagu koodi metodite nime ära, et meil tekib operatsioon, mis on püütan metod, kui me generin püütoni ja selle metodi nimi on siis tavasalt ket-underskor-pets, underskor-paj, underskor-ID, et tavasalt tehakse selline konverteerimene, et kämel keissist underskor-tybis konverteerteks ümber püütanis. Siin on ka, et mis vastuseks saame, et me saame siis, siin tundub väike viga-ale, et siin tegegütaks üks pet olla mitte ära ennendest, võib-olla ma olen siin kogamata vea teinud. Ja siin sellel metodil saavad olega parametrit, meil onki ID-parameeter ja see ID-parameeter on siis selle URLis, et kui genereeriteks püütan kood, siis püütan kood teab kus seda ID-väärtlust võtta, mis andaks selle ket-pets-paj-ID metodi argumentiks. Mõnesmõttel see info on siin vaelika koodi genererimiseks. Siin on siis kodulooma loomine, et samamoodi, et meil on vaja teada, mis on sellel metod, mis on selle metodi nimi, siin petID. Ja siis me defineerime kärgad, kui postmetod tehaks, et mis Jason ei püaks selle postmetodiga kaasa saadma. Siin tegelikult vist ei öelda, et Jason, pigem me öelda, et see anmed tulevad HTML-vormist, et ta on HTML-form, URLin kooded väärtlust, ja selles vormist oli siis kodulooma nimi ja kodulooma staatus ja need oli kaks vajaliku väärtlust, võib-olla seal on veel midagi, aga põhimeks kodulooma loomiseks ta anma kaasa lihtsalt nime ja staatuse. Ja vist selle postmetodiga nad vist toetavad ka ta staatuse muutmist, et neil vist ei ole eraldi put-metodid, mis väga restful ei ole, aga open up-i spejekatsioon lubab kasutada. Ja see vastu võib tulla kas 200 kodiga vastus, et petupdated, kus needJation kui XML puhul on see vastus nagu tühjad stringid, ja kui te teete postparing on võimalik anda kaasa hetereväärtlust accept, ja selleks saate märd, kas ta tahate Jason sõnumit tagasi või tahate XML sõnumit tagasi. Et see võimalatab nagu mitut stiilis saada anmaid tagasi ja postparingu tegiall ise otsustada, kas ta tahab Jason vastust või XML vastust. Et kui tema rakendus pigem tegeleks XML parsimisega, siis võimest, et on võimalik, et saab mitut tüüpi vastust saata. Vist mitte, et ikkagi üks on seal minu teada. Näiteks, kui me tegeme anmet, tegad, kas ma tahan Jason stiilis anmet või CSV stiilis anmet saata, et näiteks mingid anme kogu alla laadimisel. Aga see on jaa, et lihtsalt mitte aaks. Ma ei ole kindel, et võib-olla saab mitu anda ja sista kudagi prioriteetsalt vali pesimise, mis on võimalik või midegi sellist. Aga ma pole päris kindel. Minu teada on üks, aga võib-olla ma ei ole, ma ei lihtsalt teada nii täpselt. Ja siis siin on errood, et me võime ka saada 405 ja siin on isegi kirjeldus, mida sa 405 täpselt tähendub selle appi kontekstis, et ma etad natta laud ja see ka määrab, et vastus on tühi xml või tühist Jason ja see ka tegelega juttab, et vastus tuleb tõennauselt. Või no, vastus tulebki tühi Jason tagase. Mõnikurv teid pea asiagi saadma tühja Jason, et võib lihtsalt kontenti mitte olla. Ja open appi komponentsi blok al saab olla siis väga palju onnev, et juba on juba, et juba on juba, ja open appi komponentsi blok al saab olla siis väga palju erineid asju, et meil võib olla siis keemad, meil võib olla mingit kategoriad, meil võib olla mingit tagid, meil võib olla mingisugud responside kirjeldused, et see võimaltaab näiteks siia linkida, et konkreet see responsiasemel me võime selle responsi ükskord ära kirjeldada komponentid al ja siis siia pana linki sellele komponentile, et meil võib väga palju erineid asju olla näiteks mingite sõnumide struktuurid skeemas, mingite objektide struktuurid, näiteks mis on user väärtused, mida useri loomisel peaks maärama, operatsioonide parametrid, mingisugud näited, näited on väga kasulikud veepi, interaktiise veepi dokumentatsiooni aaks, me vaatame seda vasti igasugused sisendid ja väljundid, vastused, väisevärtused, mida me mitmes korras kasutame, et näiteks kui me taham ära märata, et nende apide puhul tulub kasutada, api token based, siis me saame seda ükskord kirjeldada komponentid al ja siis meetodid al linnkida sellele heeder tüübile. Ja ka sellised security schemes, mis defineerib ära autentimis info, näiteks, et see meetod peab kasutama api võtit ja tal peab olema mingit teatud lugemise ja kirjutamise õigused, seda meetod läbi välja kutsuda. Ja siis peab kasutama speciaalised api võtit, mille on nii lugemise ja kui kirjutamise õigused, aga sellised asju saab defineerida open appi speciaalised. Siin on mõned näita skeemadest, et meil on petid ja peti al, meil on mitu võimalust, me defineerime need näidete, me defineerime need näidete, meil võib olla näiteks cat näide ja dog näide, kus cat on, et name on fluffy, pet type on cat, color on white, genderized male ja predispersion cat ja siis koeraal on name on puma ja siis on ka frog, aga frog pool on omakorda viide ja mingile teisele frog näitele, mis on omakorda komponentid al ja me saame sellist linkimist kasutada, kui me soovime mingit asja ainult ükskord kirjeldada ja me ei soovime mitmes kohastakirja. Ja neid näiteid, miks on näiteid kasulikud lihtsalt dokumentatsioonina, et kui luakse uus kas, siis millised väärtused võiks olla ja mis neid väärtuste näiteid, nagu aidata kasutajad, aga neid näiteid saab ka kasutada interaktiivses dokumentatsioonis ja mida ma vasti teile näitan, et see lihtsustab selle appi testimist selles dokumentatsiooni veevi lähele. Ja skeemasboksis defineerib ära sellised väljaad, mis siis nendel olemitel või resurssidel on, et skeemade peal mõtlet, et me defineerime siis need appi resursid, mida need appi metodid modifitseerivad ja kui meil on PET resursina, siis PET on objektyp, eht ta näiteks kas XML või JSON dokument, tal on mingisugused deskriminatoreid, mis põhimiseks ütlevad, mille järgime need paika paneme ja siis tal on väljaad, et properties, väljaad on meil name, mis on string-typ, ja PET-type, mis on string-typ ja väge määram, et name ja PET-type peavad olema. Ja see on ääriskasulik, sest kui me genererime koodi, siis siia koodi genereriteks validaatorid. Ja kui keegi proovib meile saata meie appile JSONi, kus need kahteväärtost ei ole, siis genereritud kood kohe vastab kasutale, et teil on see väärtost puudu. Ja meie ise ei pea implementeerime seda loogikat, et kuidas kasutale vastata, kui need väärtost on puudu. Et näiteks Pythonis kasutatakse bytantic teeki selleks, et valiteerida neid sisse tulevad väärtosti JSONis. Ja TEOks on jälle lihtsam implementeerimine, kunade saate skipida selle ise valiteerimise ja isekoodi kirjutamine valiteerimise jaoks. Ja siis see struktuur peav olema kui siis XMLis või JSONis vastavalt sellele, mis dokumentistruktuuris appi nagu nõuab. Ja security skeemad alve, me märat, et meil on näiteks, kas appi võtikasutuses autentimiseks. Juhu ta on appi võtikasutuses, et kust asub, et ta peab heeteris olema ja mis tüüpi ta on, et ta on tava appi võtti ja mist teema neima vist appi alamb krips ki. See on tegelikult väga halb viis, kui te spanna, et reaalselt paljudele webi raamisti, kelle ei meeldja alamb kripsud heeteriväetust. Minul tekis sellega reaalne probleem, mida ma ei oskanud väga deep-hugida. Koot töötas, kõik töötas väga esti, kui ma kasutasin appi alamb krips kiid heeteriväetusena, aga ma kasutasin reverse proxid, selleks, et kui serverse tuleb päring teatud alamb hostil, siis ma suunan selle edasi tocker konteinerisse, kus asud mina appi ja millegi pärast see ei töötanud. Ja tuli välja, et see reverse proxy kustutas ära kõik heeteriväetust, milles oli alamb krips ees. Et kuna need ei vasta standarditele, et heeteriväetust ei tohiks alamb krips olla, siis minu genereritud koodus ja minu implementeeritud koodus kõik oli okei, aga ngenicsile ei meeldinud, et heeteris on alamb krips ja kustutas selle ära. Ja siis mina pidi teepakima, et kus see viga tuleb, et miks ma autentida ei saa oma appisse ja tuligi välja sellest, sõv käid vastuseda HTTP-appid, et heeteriväetust ei tohiks alamb kripsuga olla. Is ma pidin ngenics konfiguratsiooniselle ära muutma, et lubataks alamb krips. Võib ka siis kasutada OAuth, et me defineerim ära, et me kasutame näiteks ülikooli OAuthi oma appis. Me ütleme, et meil on siis tüüp OAuth 2 ja meil peab olemes Authentimis Flu. Seda me palati üst välja kutsuma. Authentimis Urla asub siin, et see on mingi ülikooli OAuth sisteenus pakkuja. Ja siis määramäärad, mis skoopist on, et seda peab olema sisse. Selle kaudu tagasi saadud objektil, mis käib mingi kasutakoht, et selle kasutale peab olema write-õigused ja read-õigused, et seda OAuth edukas oleks selle metodi haaks. Me saame sõeld, et selle metodi haaks on vaja ainult kirjutamisõiguseid, ma selle metodi haaks on vaja lugemiseõiguseid või vastupit, et teatud metodid jaoks lugemiseõiguseid on vaja, et teise metodid haaks on vaja, et OAuthigaudu saame tagasi, et sellel kasutale on lubatud ka muutusi teha. Ja kuidas me siis kasu saame, et teatud tüüpi generaatorit, teatud veebiraamistikele oskavad seda ise automaatsa teeaks valmis genereerida tee, peab siis implementeerima, et kuidas OAuth 2 autentimis teha. Flaaskissa ei tööta, et kui me Flaaski genereerimist, Flaaski generaator ei oska seda teha, aga fast API generaator oskab neid asju teha. Vähemalt ma olen ise ära testinud API võitmedega, et genereeriteks siis kood, et kuidas API võitmed lugele siis heeterist ja ise ei pea selle pärast väga muretsama. Ma vaatan, kas ma olen veel mitte kära unustusinud. Ja basic auh ka, et kasuta nimijaparool. Ja ma olen seda juba mitu korda mainind, et eksisteerivad mitu generaatorit. Üks on selline KitHubis olev open upi generaator projekt. See toetab väga palju keeli. Serverit saab genererida 15. keeles, klente saab genererida kuni 30. keeles. Seal on ka sellised puhtat klendikoodid nagu JavaScript. Aga tegelikult serveris on ka Node.js teesti olemas. Ja serveris on mitte ainult 15. keelt, aga 15. keelt korda mingi arv webi raamistiket. Näiteks Python jaoks on nii Flask kui ka FastAPI jaova jaoks näiteks Spring. Et genereriteks see koot mingisuguse webi raamistiku jaoks. Ja loodud serveri koot siis näiteks Flask jaoks sisaldab kogu selle serveri koodi skeletoni, kus on puudu näiteks metodete loogike. Selline business loogike on lihtsalt puudu, mille teie peate implementeerim. Kui tuleb get planning, mis listib kõik loomad, kuidas siis anmebasist võtta need loomad ja kuidas saad station genererida on siis teie implementeerida. Aga genereriteks siin lisaks kogu serveri kootile ka selline Dockerfile, nii et seda appid on hästi lihtne ülesseada. Lissalt DockerBuild, DockerRun ja kõik. Selleks saad testida. Dihti seda on vajalik fastapi puhul, sest Windowsis fastapi alati ei tööta, kui te kasutate teatud, kui on vaja teatud teke, mis Windowsis millegi päris ei tööta. Ja lisaks, mis on väga huvito, genereriteks see veepi liides appid dokumenteerimiseks ja testimiseks, mille on umbes sama funksionaasus kui Postmanil. Ja teie appi jaoks genereriteks see teie serveris näiteks slash toks või slash UI, kus all on siis selline interaktiivne dokumentatsioon ja liides, et kui sa appid kasutada. Teie klientide on hästi mugav sinna minna ja proovid appid kasutada enne, kuid need midagi implementeerim hakkavad. Eesik kasutaja või arjendeva peab implementeerima ainult nende rest metodide sisu, näiteks putket, postelit ja need asiga endpointi jaoks. Aga näiteks flaskis peavad ka implementeerima mingisugused autentimis asjad, anmebaasisuhlus asjad ja muut sellised peate tihti ise implementeerima. Teatud tegid võib loskad ka anmebaasi osa ära implementeerida. Sellised anmebaasi ühenudust autentimised integratsioonid ja muud asjad tihti jäävad nagu arendele. Ja on võimalik siis genereeta niis klient kui server, kui serverist tuleb midagi implementeerida, klientid on tavalselt täiesti kasutatavad. Leijate mingisugus keerulise appi ja soovite Pythonis metodeid väljakutsuda, siis saate open appi specijokatsioonipohjal selle Pythoni tegi valmis genereerida, mida teie saate omakoodist väljakutsuda, kui sa Python tee kuskap tolla appiga suhelda ja ütleb teile näiteks Python tasemel, et mis need sisendid metodeidle ja mis need väljundid metodeidle täiks olema. Ja ta on selles mõttes palju lihtsam kasutada, kui mul endal tavasalt meiti ise hahatatab appi metodeid kirjutada, aga kui on keeruline appi, siis on mõnesed palju lihtsam klient genereerida teie teiele vaelikus keeles. Ja neid näitet siis, mis keeled on serveri jaoks toetatud ja mis webi appide. Näiteks Ruby jaaks on siis Sinatra ja Rails 5, raamistikud Python jaaks Fast Appi ja Flask, skaala jaaks on erinad, Akka, Finch, Lagorn, Play ja Scalatra, PHP jaaks näiteks Laraveli, serveri koodi Lumeni, Slim, Silek, Symfoni ja nend on päris erinad Java jaaks, Spring ja MS4, 4J ja Underdough ja jaaks ja CXF ja Inflector ja nii edasi, et Java jaaks on päris palju. F jaaks and 1, K jaaks on mitmed, kolm tükki C plus plus jaaks on ka mitmed ja Häskel jaaks on isegi mõned ja Erlang jaaks on vist üks, puhas Erlang vist lihtsalt, Ada jaaks on ka ilma raamistikud. Node.js on ka lihtsalt Node.js, et ei ole konkreetne Node.js alam raamistikud. Klienti jaaks on rohkem, et näites puhas Java script Type scripti, et kui te teete angularirakenduse ja soovite mingisust apid väljakutsuda, siis saate angulari tegi genererid selle appi jaaks, et kui te edasi angularis selle appi meedad, et väljakutsuda, et tegelikult päris mugav. Et angularist soovite Twilio appid kasutada, saate siis Type script klienti Twilio open appi speksiooni põhjal genererida, siis oma Java koodistis seda Twilio appi teeki kasutada. Tihisteliselt Twilio appi klienti teeki eksisteerib ka Twilio enda kuski GitHubis, aga põhjumistelt selle open appi speksiooni põhjal saada ise selle genererida. Ja lisaks tegib siis sellest muga webi dokumentatsioon, mida saate post mani asemel kasutada, ei pea käsurialt ketja postpäringu tegema, oid saate neid teha läbi selle webi liidese. Ja ta lihtsustab teie klientidele, et kui teie starteapile mingi klientid ja soovite, et näidata, kui saapid kasutada, on väga mugav, nad tegelikult saates jo interaktiivsese dokumentatsioon, et saavad proovida neid. Ja näevad, mis andme tüibid on, saavad, vaadate, mis vastus, et appi kauda tulevad, saavad neid proovida ja seda saab suhtseid hästi kasutada. Näiteks open appi generaatoril endal on webi dokumentatsioon, mis võimalda peal üles laadida oma speksiooni ja kasutada open appi webi appid selleks, et genererida pyütun kood, see pyütun kood allat oma ja kasutada, mis on natuke naljahkes, aga põhimõttel, et open appi generaatoril endal open appi speksiooni ja webi liidese, millega autus saate proovida open appi webi liidese meedlade välja kutsuda. Kui ta klienti koodi genererida appi gen clients või serveri koodi appi gen servers koodi genererida või siis konkreesele keeled, et näiteks appi gen clients, Python flask või Python fast API, peate natuke uurima, mida see language tegelikult tähendab, et seal on mitu. Ja siis kui on genereritud, saate sellel allat oma, et saate vastuseks file ID ja kui see on valmis, siis saate siit kaudusele pyütun sipitud allat oma. Meie praktikumis saate kas seda kasutada või saate lihtsalt üste java teekid övanta meiväenist ja Jarriga otse oma arvutes generereeld seda koodi, et teid peastada webi liidest kasutam, et see on natuke eba muga on seda webi liidest kasutada, kuna te vist ei saa hästi üleslaadida jamli, et see jamli peab kuskil webis olema. Ja siis see vastus näeb välja selline, et ma ei tea, kui hästi see siit näha on. Ja võib-olla nii paremini, et ma saan ka siit nüüd proovida seda väljakutsud, et ma klikin seda post appi Gen Client Language peal ja mulle tekib. Ja ma seal on ka Trynup, ma jahütan seda Trynupu. Pärast seda ma saan hakata parametrit ja sisse panu, et mis see language on. Ja siis siin on ka näite, et mis see vastustavalsed tuleb välja. Ja kui ma jahütan seda Try ja Execute nupu, siis ka reaalselt, tehaks see selle päring läbi. See on nagu postman, kus ma defineerin ära, et mis see päring on. Aga see on nagu postman, mille sisse on ehitatud selle appi jaoks selle collection, et mis need metodid on. Et ei pea isegi ise näid collectioneid looma. Ja näite, vastus on ka see, et see on successful 200 koodi, siis on linked, kus see genereritud kood siis alatõmata. Et see on teine appi metod, mis on alatõmavana. Võib-olla konkreetslem näite on selline, mis me ise oleme loonud, mis on see targa linnan anmebaasja appi, kus ma olen loonud sellise appi targkora, mida üks tudenk implementeeris. Ja seal on selline seadmete halduse metodid, get, boost, device, elite, konkreetne device, get, correctne device, ja siis muuda mingis kus device anmed. Ja siis saab evente sündmusi saata, et näiteks bussivaliteerimis event või auto ära tuvastamis event. Ja sit on nagu hea ülevaade saata, et mis on need resursid, mida hallatakse ja mis on see resursiala metodid. Ja seal on ka kirjeldus, ja kui ma soovin, siis midagi välja kutsuda, siis ma saan proovida sinna post metodi peal teha try. Ja siis saan siia panna selle jason sisendi, mis ma selle metodile saadan. Ja saan execute teha sinne, et see reaalne metod läbi proovida ja saan ka autentimis info sit sisse paned, et näiteks appi võtme, kirutan see sisse, et ta ajutiselt jätab meeld, et mis on selle kasutaja appi võtti selles säsjonis. Ja te ise proovitega seda praktikumis läbi selle raamatute halldusappiga, et milline siis teie dokumentatsioon välja näeb ja saate ka testida seda nii veebi liidesest, kuidas teie raamatud appid kasutada. Lisaks on ka selline Sväger editor, mida te praktikumis saate kasutada, et kui mina annan teile selles spetsiokatsiooni, siis te saate minna selle laadresile editor.sväger.io, pasteida se spetsiokatsiooni siia ja see pool genereriteks teile automaatsot. Ja see on nagu live editor, kus te siin midagi muutate, siin automaatsot midagi muutub. Ja te ühes ülesandes peate nagu ühe metodi juurde tegema ja siis te hakkate siin kirjutama seda, et te näete, et mis siin juhtub. Ta üleal näitab vigasid, et kui teile Jamlis on mingid vead, et see on see hästi mugav viis, kui ta siis nagu listasti kirjutada ja näha, mis ne muudatsud kohe teevad. Ja ka siin näidatakse teile vigasid, et näiteks, kui te siia panete midagi valesti või midagi on puudu, siis punasega natuke näidatakse, et olete valesti teinud. Elmiste aastatel me seda ei kasutanud ja siis tudenki natuke sattusid hättada, et nad ei saanud aru, kun nad Jamlis liiga palju tühikud kasutasid või liiga palju tääbe kasutasid, et siis tekisid väga halvasti tepakitavad probleemiid. Ma loodan, et selles väger editori, kes saab selle palju paremini aru saada. Ma isen olen seda kasutanud, et nullist sellised appi spekikatsioone kirjutada, et haad, et appid on suhtsealt lihtsalt, et lihtsalt saab võtta ühe olemasle lappi näite ja seda ümber kirjutada enda appi jaoks, et suhtsealt lihtsalt saab blokke, kopia, beistida ja asja teha. Ja angi, et selled nädalab praktikumis, siis mis me teeme, me võtame siis minupolt ettevalmistatud open appi spekikatsiooni, kus üks maetod on puudu. Te testite seda, genereerite koodi, panete ta tööle lokaalsalt või tokeriga, kui soovite ja siis vaatate, kuidas ta töötab. Siis te implementeerite selle serveri koodis puudu olevad metodide sisu ja siis ka lähete takas ja lisate appi spekikatsiooni ühe puudu oleva metodi ja genereerite selle koodi uuesti ja teete muudatused läbi. Et te näete, et üks tüütuma asi on see, et kui te spekikatsiooni muudate ja koodi uuesti genereerite, seda mõnes mõttes genereerib sinna kaustaned failid üle. Olge ettevaatlikud, ette oma vanu muudatusi üle ei kirjuta, et te teed kas genereerite mingisse teise kausta ja peate mingisseks mergil läbi tegema, et kuidas ta oma varem loodad koodi nagu tagasi vite, et kuidas asendab need failid ära. Olge sellega ettevaatlikud. Praktikum juhendis on selle kohta ka sellene punane tekstet. Ja siis järgmine kord hakkame rääkima siis pilvetehnoloogiast ja praktikumise hakkame natuke asure ja pilvetehnoseid kasutama, millel ilgipäästates oma ülikoolikonto ka. Loodatavasti ei ole kõik oma krediidi elmises semestrid arra kasutand. Elmne kevad on okei, et asures, kui teil on ülikooli tudenegi kontost, te saad iga aasta uuendada seda uue kredidi. Aga nad kalb, on kui pool aasta tagasi kasutasid ära, siis on nad kalb. Aga õnneks me kasutama ainult, me peamiselt kasutama tasutateenuseid ja on teised viisid, kuidas ilgipääst saada ka. Aga eks me vaatama. Ja see ongi tänasüks kõik. Kas kelegi on küsimusi? Põhimiselt teeme täpselt sama asja praktikums läbimise elmnekord ja te saate oma elmise korra koodi kasutada, et ei pea loogikat nullist uuest ehitama, aga te peate natuke ümber tegema sellest. Sisendid ja väljundid on natuke täist sugused võib-al täiste nimedega natuke, aga põhimatselt kogu loogika, raamatu allatõmpavis loogika on sama, raamatu otsingu loogika on sama. Ja tõna vähem kõik asjad on samamoodi nagu elmist praksist ja lihtsalt genererite serveri koodi ja siis täidata need lüngad elmise praktikumi lahendustega. Aga see ongi siis tänasüks kõik. Tänan, tänan.