 Tere tulemast siis kolmandasse lohen, kus Peepi teenustaja hajussüsteemid arendusaines. Ja täna jätkame hajussüsteemidega. Tänna räägime siis hajussüsteemide komponentide vaalisest suhtlusest. Et kui me seame üles samas arvutis mitu prozessi, siis me soovim ka, et nemad omaval suhtleks. Kui me seame üles mitu prozessi, mis on hajussüsteemi komponentid, mis töötavad siis erinatas arvutides, siis on meil nende prozesside vahelne suhtlus ülevõrgu. Kui me eelne kod rääkisime natuke nagu sellest, et kui meil on lõime, et sama prozessi sees, siis nad jagavad mälu, aga prozesside vahel, mis jooksevad erinevad prozessiden arvutides või ülevõrgu, siis seda võimalust tiht ei ole, et seda on võimalik ainult sellestes hästi suurtes superarvutides või kallites paralel arvutides siis võimaldada, et tekitatakse jagatud mälu. Aga tänna räägime siis pigem nendes prozessides, mille vahel nagu sellist jagatud mälu ei ole. Ja räägime siis erinevatest andmeted edastamise viisidest ja räägime ka täpsemalt natuke nendes protokollides, mida te ise hakkate, siis oma praktikumis kasutama, mis on siis MQTT ja AMQP. Kui me peame otsustama, et kuidas me paneme prozessid oma vahel suhtlema või hausüsteemide komponentid oma vahel suhtlema, siis me peame mõnesmõttes vastama sellistile küsimustel, et kuidas on üldse hausad komponentid oma ühendadud, kas saab teha IP-aadresilt IP-aadresil ühendusi, kas komponentid saab ülesseada serveritena ja nendes saab ühendada ülevõrgu. Ja kuidas meil on võimalik siis seada ülesandme vahetus ja sünkroniseerimene nende komponentide vahel ja mis andme, et meil üldse on vaja sünkroniseerida ja kuidas me siis need vahelsed liidesed protokollid konfigureerime siis ühiseks hausüsteemiks ja kas meil sellised hausüsteemi komponentid, mida me oleme ehitad või mida me tahamme välja asendada, kas need on selget märatetud liidestega, et kui lihtne on meil võimalik vahetada välja mingi hausüsteemil komponentid, kas meil need hausüsteemide suhtlus on disainitud niimoodi, et meil on lihtne vahetada välja üks komponent, et kui meil on näiteks mingisugune tavalne HTTP või REST API kasutuses, siis me saame panna seda teise komponente, mis implementeerib selle sama REST või HTTP API liidese siis. Ja kuidas siis defineerida üldse protsesside vahelise side on see, kui üks protsess saadab mingisugust andmed teisile protsessile, et kui see toimub nagu ühe arvuti sees või ülevõrgu, siis seal suurt vahet ei ole, et me nimetame seda protsesside vaheliseks kommunikatsiooniks või ingliskeles interprocess communication ja see oli üks lühen, mida me elmises loohingus ei mäletanud, mis ei ole. IPC on, et see on interprocess communication, eks see on siis kahe protsessi vaheline kommunikatsioon, et kuidas siis andmed vahetadeks kahe protsesse vahel. Et seda on võimalik teha mitmel viisil. Üldiselt ei looheta jagatud mälu selliseks IPC tüibiks, aga on võimalik lihtsalt jagatud mälu kirjutada andmed, mida teine protsesse on võimaline sest lugema ja selle me jätame nagu tänases loohingus täiesti välja natukene aruts meelmise korral. Aga see läheb pigem nagu paralel arutuste valdkonda. Kõige tavalisem viis on otsa jöhendus soklite kaudu, eht me tekitame kaks soklit mõlemale protsessile, eht protsessid hakkavad oma arvutis või lookaalses arvutis kuulama mingisugus porti ja teine protsess samate kuulab mingisugus porti ja üks nendest ühendub teise protsessi sokli kaudusis ja hakkab andmeid saadma kahe sokli vahel. Me räägime järgmiste slaidile, mida täpselt tähendab sokel ja kuidas see käib. Teine võimalus, et me natuke abstraheerime seda, et mida me saadame, et me defineerime sellised nagu sõnumid või teated ja hakkame saadma teateid kahe protsessi vahel ja see enam ei prugi toimuda sellise otsa jöhenduse kaudu. Teateid võib saada läbi soklite, aga võib ka saada läbi selliste sõnumi vahendajate või selliste brokerite või maaklerite või sõnumi ärekord. Meil tegelikult võib tekida täiesti mingisugune server, kuhu me saadame sõnumeid ja siis teine house systemide komponent ühendub ka sinna serveris ja võtab sealt. Otsa jöhendust on meil võimalik teha siis, kui üks protsess saab kuulata näiteks oma arvutis olaju porti ja teine protsess saab sinna arvutis jöhendada nagu IP ja porti kaudu. Aga alati me ei tahas seda võimaldada, sest sellised portide lahtitegemised on natuke problemaatiselt asjad turvaalises ovaatest. Sest sa võid saata sinna suvalisi pakete ja kui sulle on näiteks sellest tarkvarast, mis ta porti kuuleb mingisugused vead, et ta ei oska korralikult näiteks mingid buffreid hallata, siis võib sinna saata sellised sõnumid vahendad, mis tekitavad näiteks buffer overflow ja siis võimalik tuss selles arvutis mingisuguse suvalise koodi käivitada. Nii et alati ei taha usaldada, et see tarkvara, mis sellest porti kuuleb, see on nii hästi ehitatud, et seal mitte ühtegi viga see seala. Ja kui sa vaad väljas polv portid kinni, siis sa ei saagi IPv6 pakete saata sinna. Kui sinu rakendus on näiteks mikrokontrolleris olev tarkvara, mis ise ühendub näiteks kindlasse kesksese serverisse, aga ise ei luba ühtegi, siis sa tulad ühendust, siis sa saad kaitsta selle vastu, et sinna ei saa midega otsa saata. See küll ei kaitsa 100% võrgueest, sest see rakendus või see mikrokontroller või see arvutimis võrguga ühendust võtab ise kuskil serveriga, siis ta ikkagi paketi peab kuulama, et otsustama, et mis on näit paketid, mis on seotud väliatehtud ühendusega tagas seotud paketidega. Aga üks kõik, mis ühendusta protsesside vahel teed, see ikkagi mingisugus tohud on seal peidetud isegi siis, kui sa ise ühendud anmebaas ja tõmbad dokumenti alla ja kui dokument on disainitud niimood, et see ka tekitat mingisuguse turva olukorra, et samuti dokument on liiga suur või kudagi disainitud niimood, et see parsimistarkvara ei oska seda hästi parside ja tänu sellele on seal mingi väiked security bugi, siis ka sellest tegida problem, et üks kõik mis sugun ühendus on problema niikord. Alati on problem tarkkorras, aga mida vähem port on avatud, seda väiksem, kui sa seda Ingiliskelle sueldaks, et itse on attack surface, seda vähem võimaluse on seda rünnata või sa nagu ei luba kellegil sinu süsteemi ühenduda. Litsad, et portid on alati kõige selline lihtsam viis, kui täst midagi rünnata, et hakkata kas suist scannima, et vaatama, mis tarkvaras sul on, kas sul on sellel SSC-tarkvaraga, sul on mingisugune open SSL-tarkvaraja, siis uurida, et mis bugid võivad selles versioonis tarkvaras olla, et võidi seeegi mis küskile mustale marketile minna otsida, kas selle tarkvaral on bugisid, mida sa osta ja siis on ära kasutada ründajaaks. Seda prooviteks siin tihti karab eet, aga näiteks SSH-tava protokoll ütleb, et ma olen SSH-Versioon ja see on tihti vajalik, selleks, et SSH-tarkvaraga saks oma vahel ühilduvalt ühenduda, et sul on vaja teada, mis protokollid ja mis versioonid kasut sul on, sul on vaja teada, mis krypteerimis protokoll on kasutusels selleks, et võitme krypteerimist, et lihtsalt krypteerimised ei luba, aga sa pead ütlema klientidale, et mida sa lubad, et tihti on vajalik selleks, et tarkvaral üldsetöötakse. Aga selle sa ennest me väga turvalisest ei puuduta, lisama mõtsin idee, et on huvitav, siis selle kohta velda, et teatud stiilida mõnda tüüpi haussüsteemide komponentia teaks natuke paremad, et võib-olla vähendavad natuk sellist ründala, mis on avatud rünnetele. Ja järgmises loengus räägime natuke sellest kaugprotseduurides ja haussuobjektidest, et see ei ole tegelikult nii palju erinev sellest, mis siin on, sest tihti see toimub ka soklite kaudu, kaugprotseduuride või haussuobjektide selline suhtlus, võib ka teadete kaudu toimuda ja meie praktiku, mis tegelikult teemegi kaugprotseduurid teadete edastuse kaudu, et see on pigem nagu veel üks abstrahärimise tase, veel üks abstraktioon, siis elmiste peal, et kuidas sa tead. Soklite jöhendas on kõike madala tasemel, teadete edastuse on natuke kõrgemal tasemel ja kaugprotseduurid ja haussuobjektid on veel kõrgemal tasemel. Aga kui meil on ühes arvutis kaks prosessi, me võime näid ka nagu sellist torude kaudu suhtlama panne. Et üks prosess võtab mingisuguse anmet sisse, töötleb ära ja teine prosess kuulav esimese prosessi väljundid, et selliks Linuxi torud, et on see ülakriips Linuxi käskudas. Et ka seda saaks teoreetselt kasutada kahe prosessi vahel suhtlusele, kui me teame, et ühe prosessi väljund alati lähed teise prosessi sisendiks. Või siis teoreetselt me saame nagu failid et asemel teha, et üks prosess kirjutab kõugi fail ja teine prosess kuulab, kas sinna fail on uue tread tekkinud, et ka selle kaudu. Aga see on tegelikult väga sarna asi, kas sul on toru või sul on failid. Idee on tegelikult täpselt sama, et toru või Linuxis vaadata ku faili, mille see tegib uusi ridasid ja kuiki failid tavalist jääb rea talle, see torust see mingi et kaoplist ära. Ja loogiliselt on selline tehniliselt asemeli prugi olla, et ja, see tavalne toru abstraktion sulle luba tegelikult väga mittmel prosessil seda kuulata, aga failidele on palju lütsem lubada seda, et sul on mitu prosessi kuulata. Ja Linuxid asemel on soklid tegelikult ka väga sarna aset failidele, failipidemetele, millest ma ka natuke räägin täna. Räägimeski natuke soklidest, et mis siis soklid on või ingliskees soket. Sokel on sideots punkt, et kui meil on kaks serverid või kaks prosessi, mis oma val taad suhelda, siis me identifitserime need prosessid, et mis arvutist ta jookseb, et mis selle arvuti IP-aadress on ja mis portida kuuleb. Et me teeme kombinatsiooni siis IP-aadress, call on port ja see defineerib sellisa võrgu asukoha, et kus teine prosess kuulama hakkab või on üppal kuulamas, et see on nagu võrgu asukoha, kuhu saab siis soklite kaudu ühenduda. Tihti on tähtis ka see, et kas ta on TCP või UDP port tüüpi protokoll selleportis kasutusele, et mida kuulatakse, kuna see suhtlus on päris erinevse olenevalt selles, kas sul on TCP või UDP kasutusele. Ja see IP-aadress võib-olla lokaalne IP-aadress samas arvutis olev IP-aadress ehk localhost näiteks, selleks, et kaks prosessi saaksid soklite kaudu lokaalsees masina sõhendada, et seatu öelas näiteks anmebaasi ja paneta anmebaasi kuulama lokaalsed porti 5762 näiteks lokaalses arvutis ja samas arvutis se installeerite püütunprogrammi, mis ühendub siis üle lokaalse võrgu selles anmebaasi. Siis anmebaasi hakkab teatud kombinatsioon IP-aadress ja portist kuulama ja iga klient, kes soovib selle anmebaasi ühenduda, tema peab samuti hakkama ühenduse tegemisel, teeb ühenduse, aga tema peab kuulama mingisugus porti samas arvutis, kui tulevad siis põhimselt vastused sellest soklühenduses tagasi. Ja Linux siis on sokel põhimõttelselt selline speciaalselt tüüpi file pide ehk sinna on samal madalalt asemel võimalik lihtsalt anmeid kirjutada ja lugeada, nagu process kirjutab file ja loovad file-ist, et nagu Linuxi, Kernelii, systeemi operatsioonide või metodide või käskuded asemel on ta põhimõttelselt teatud, speciaalselt tüüpi file pide, aga madalalt asemel käib suhtlus samamoodi nagu file-ist lugemine, file-ist kirjutab, ne lihtsalt sinna anmed jõuavad kohale üle võrgu. Ja põhimõttelselt me saame kirjutada ja lugeada pinaalsed file-e. Sokli ühendused siis võimaltavad processidel oma vahel suhelda, ta on suhtselt madalalt asemel, selledat, et on ka sinna peale erinad abstraktion ehitatud, mis teevad nagu selliste hajustarkkuvara programeerimise lihtsamaks, nagu me ei hakkame ka praktikumist kasutama sõnumite põhist suhtlust. Ja me loome side kahe sokli vahel samas või erinevas arutis ja neil on sellest andartised liidased. Ja me saame kasutada kas paketside, UDP või VOOC side ja TCP-ed, et ka sellest nendest protokollides me selles ainees väga ei räägi, et pigem anmed või operatsioonisjusteemides ja võrgutehnoloogis räägiteks nendest protokollidist. Ja see nõuab natuke madalalmat asemel programeerimist ja saad jälle vastuvat, jolle on oma kohalikud puffrid, mida nemad kasutavad, kui põhimustad failid, kuhu anmed kirjutada ja kust anmed lugeda või kujutad ette, et väliu fail ja sisene fail, kuhu sa kirjutad anmed ja need anmed viaksid kohale sinna servers, ja mis kuulab seda sokliyhendust. Sokliyhenduseapuhul meil on alati nagu klient, kes alustab ühendust ja server, kes kuulab ühendusi ja server tavalsed kuulab ühenduses paljudelt klientidelt. Ja server enne ühenduse võimalda, mis peab server olema tekitanud oma lokaalsa soketi, kuhu saab siis, kas lokaalsest masinast või ülevõrgu ühenduda, ta hakkab kuulama, siis seda soketid lues sellise pand käsu tulemuse na soklisidumise mingisuguse kohaliku aadressiga ja liseng käsu põhjal hakkab kuulama, siis see tulevad ühenduse. Siis see tulevad ühendused võib tulla mitmelt klientilt ja ta peab algatama sellise ühenduste vastuvõtmise kasutada sääks hääpks käsku. Kui server on need nelisamul läbi teinud, siis saavad klientid hakkata ühenduse võtma selle serveri sokliga, siis IP-aadressiga ja portikombinatsiooniga. Ja klient siis samuti loob oma soketi, loob põhimselt soketi ja tekitab siis ühenduse võt, kasutus Connect käsku, et võttes siis serverga ühenduse ja kui server võtab sellise ühenduse vastu, siis tekibki soklijühendus kahe nagu otspunkti vahel, kus on klienti lokaalne port ja IP-aadressi, siis serveri port ja IP-aadressi. Ja pärast seda saab siis näiteks klient kirjutada sinna soklise anmed ja samuti saab siis server vastu kirjutada sinna soklise soklijühendusse mingid anmed. Näiteks ma saadan päringu, et ma soovin mingid metodid väljakutsuda ja siis server saab vastata mulle oma moodi. Ja me saame seda korrata riid ja writei mõne mal poolt ja kui klient saadab close metodi või käivitab close metodi, siis saadateks end of file notifcation, et selle soklijühenduse selle file lõpes või see võimest file ei lõpetu saadateks end of file, mis serveri ütleb, et ühenduse file on nüüd läbi ja siis server loeb seda end of file notifcation ja pärast seda panad ühenduse kinni. Ja see võimalda siis oida sellist ühendus lahti ja saada soklijühenduse kaudu mõlemas suunas siis anmed. Ja te võite ette kujutada, et madalal tasemel on. Siin arutis see process kirjutab sokli file anmed ja sit serveri poolt loetakse sokli file-ist anmed. Ja põhimestel tekitatakse kahe suuran lühendus nende kahe processi vahel. Kas nad on samas arutis ja võinad on täiesti erinevates arutitus? Ta on põhimestel saa-moodi nagu file pide. Sul on file arutis ja kui process tahab seda file kasutada, siis Linux siis tekitatakse nagu file pide. Ja selle file pide me kaududa saab kutsuda välja Linux kerrali meetodeid file-ist anmedte lugemiseks ja file anmedte kirjutamiseks. Et ta nagu otsed ligipäe su file-ile ei saa, et processi on nagu file pide. Siin on saa-moodi, et tegi file pide, et meil on teoreetile file, mis on nagu see sokli adressid ja file pide me kaudu saab processi kirjutada ja saab tugega sellised meetodeid välja kutsuda. Aga nagu file ja otsedlite eksisteerid nagu lokaaselt puffrid, mis on nagu aktiiselt selle sokklyhendus ajal ja selle file pide me pühe. Siin võib-al asjas näites võiks tuua detailsemad näit, et mis näit lokaaselt portid ja IP-adressid on. Sest muidu võib jääta natuke abstrakseks, et kuidas mõlema suunaline liiklus toimub, aga saate näiteks hotsid vaadata, kas seda adressi või natuke lugeta soklite kohta juurde, et kuidas toimud. Siin on oma lokaalne adress, portia ja siin on oma, et võib-mõlemad poole saavad teise poole sokkli adressil saata anmed. Anmeid. Ja kuulata siis oma lokaalses adressis anmeid. Ja see on siis selline otsene suhtluse, aga see on tihti selline natuke madalat aseme, et me ei taha pyütonis alati programeerida sellel tasemel, et me hakkame kirutama file tess lugema. Me tahame näiteks pigem saata sellised JSON-tyübi sõnumeid, kus kõik nagu parametrid ja väärtused on olemased, et oleks rohkem asin loetav, sest proveem on see, et siin olev server pead teadma, mis tüübi anmed saadetakse. Saadetakse küll pinaarsed anmed, aga tema peaks teadma, kuidas need parsidad. Ta peaks teadma, et kas saadetakse XML, kas saadetakse JSON. Ei ole hea teha sest täiesti tünnaamist parsimist, et ma proovim parsida kõigepealt JSONisse, siis XML-le siis aru saad, et mida saadetakse. Tihsti ikkagi selle targvara põheal paneks paik, et mits tüübi anmeid see klendil on lubatud saata, et kui me teame, et me tegeleme mingisuguse serveriga, mis saadab meile näiteks HTML-lehes sisu tagasi, siis klend peab teadma, et see sisu on texti file näiteks UTF-9-as formaadis ja tema saab seda HTML-lehene kasutada. Aga tihti ongi see kerukus, et kuidas me siin lepime kokku, et mis need anmed on, mida saadetakse, või mida kirutatakse ja mida saadetakse serverilt tagasi. Ja sellest tulebki nagu kasab välja selline normaalne või täiesti tavalne aftraktsioon, et defineerime sõnumi tüibid. Kas me saadame JSON-i, kas me saadame integeri, kas me saadame mingisugune listi integeridest, et mis on see sõnumi formaad, mille me kokku lepime, et klend saadab serverile, et näiteks me lubame, et JSON-id saate, siis JSON-i sees on kõik nagu sõnumistruktuurik olev info sisse ära eitatud, et me ei pea eraldi erinevaid metodeid kokku lepima. Ja sellest tulebki selline teadete või sõnumita abstraktsioon, et me lepime kokku, et me saadame teatustruktuuris sõnumeid. Kuigi sõnumid ise võidata olla ka pinaarsed, näiteks meil on pildi file saadame sõnumi, kus on pildi file sees, mis on piraarne pildi file stream, siis näiteks base 64 ka encoditud, kui me tekstina saadame või siis meil olevaja encode, kui me pinaarsena saadame. Ja tead, et edastus ongi, et me lepime kokku, et me saadame teatud struktuuris sõnumeid protsestid vahel ja me peidame ära nagu sellise madalataseme pinaarse sokel-sokkel ühenduse. Kuigi me ei vahet seda välja, et sisemisel tõenaselt ikkagi kasutame sokl ühendust. Ja olukorras, kus sokli ühenduse on liiga madalatasemene ja selleks on kaks peamis tüüpi, kas meil on sõnumi ootse edastuse abstraktsioon, kohe protsessi vahel, et me tekitame iga uuesti näiteks sokl ühendused ja üks protsess saadab teisele protsessile teatust struktuuriga sõnumeid. Ja me lepime kokku, et mis struktuuris sõnumid on, kas see on näiteks MPI's tegelikult võib samutel üks kõik, mis struktuur kas integer või array, aga sõubi puul tavaselt me lepime kokku, et see on XML, HDB või REST-i puul me tavaselt lepime kokku, et kast on XML või JSON, mida saadetakse. Ja RPC puhul on tavaselt XML, RPC JSONi puhul JSON, et me lepime kokku siis teatud sõnumide tühibid. Ja teine peamine erine võimalus on, et kui me ei saada otsa kahe protsessi vahel sõnumeid, vaid me paneme kahe protsessi vahele mingisuguse sõnumide järjekorra või näiteks sõnumid, kui asja hästi nimeda täiesti, kes postkasti. Me ei saada sõnumid protsessilt A, protsessil B, vaid me saadame sõnumi postkasti, ei B, mida kuulab siis protsess B. Me tekitame vahele sellise vahevara või vahetarkkvara, kuhu me saame sõnumid saata ja protsess B võib võta ome ühendust ja küsida, et kas talla on uusi sõnumid. Et see võimalatab teha sellist asymkroonsed ja natukene sellist ühendust, kus mõlemad protsessid, mõlemad osapooled ei pea olema sama aegselt otsa ühenduses soklitegaudu, vaid näiteks me saame panna mingi sensori kogu aga andmeid saadma, aga siis mingisuguse tarkkvara, mis soovid need andmeid kasutada, ta võib ome ühendust võtta küsida, et mis seal järjekorras need sõnumid on ja need sõnumid töödelda. Ja ja ja Linuxis on samamoodi, et sa võid teha IPC niimoodi, et on otsa kahe protsessi vahel võid võid Linuxist tekitada nagu postkasti või mail boxi, et kuhu saata sõnumid, et ka Linuxis on täheelne protsessida vahelne maili box täheelne olemas postkasti, mida saab nagu abstraktsioonina kasutada. Ja selleks kaks peamist on nagu MQTT, mis on tihti nagu IoT-s asjad interetis, aga nagu rohkem on kasutuseliselt Advanced Messaging Queuing Protocols, nagu rapidMQ stiilis, mida tihti kasutatakse mikroteenuste puhul või selliste suurte mauliste anmete ruutimise puhul, kus on vaja nagu otsustada ka, et kuhu edasi suunatakse. Tänna räägime natuke MPI-st ja nendest kahest protokollist. Järgmises loohingus räägime RPC-st ja ülejärgmises loohingus lähme WebI-teenustu juurde ja siis räägime Soopist arrestist. Nii, et järgmised kolm loohingud hakkavadki olema koos tänasega siis nende erineot tüüpi nagu sõnumid te edastamine siis hajusalt töötavate protsesside vahel. Ma vaatan, ega me siin kaamers liiga kaugele ei seisa. Sõnumide põhjine ühendus on siis ingliskeeles message-oriented, et me pigem tegeleme selliste sõnumidega, kui madalat aseme Pinaars anmete striimina ja nagu ma enne mainis, onki, et kas me saadame otsse sõnumid kahe protsessi vahel, aga see võib olla nii synkroone kui asynkroone, et me võime nagu vältida seda, et me saadame otsse sõnumide ka. Võib tegita sellise lokaalse pollimised, kas ma sain sõnumid kohale, kui ei saanud, siis tegelem millega muuga, kas ma sain sõnumid kohale, ma tegelem millega muuga, siis hiljem jälle kontrollin, kas ma sain sõnumid kohale. Või siis synkroon, et ta jääbki ootama, et kuni teine protsessi sõnumi saadab, aga tihtis on problemaatiline. Ja teine võimalus on, et me saadame, tegeleme siis postkastid või teadate järekorad või tööte järekorad või sõnumid järekorad, et järekordasid on erinevaid nimesid nendel ja eesmärkongi siis tekitada selline kõrgema taseme püsi vasukroone suhtlus, et meil protsessid võivadki mingitase järekoradade saanud meid saata ja teiseed hajus protsessid lihtsalt nendeaks vajalikest järekoradadest otsivad sõnumid ja ei kuulavad sealt. Et näiteks meil on mingi kamera, kes tuvastab ära, et on inimese näku pildi peal, aga ei tea, kelle näku tol, kui on näkud, et on sõnumid, et on järekorad, et näiteks meil on mingi kamera, kes tuvastab ära, et on inimese näku pildi peal, aga ei tea, kelle näkud on, aga ta lihtsalt pildist tuvastab ära, et on üks inimene, kellel on näku. Ja ta võtab sellest näpsot ja panab kõugi järekorda ja siis teine protsess, kelle ülesanand, tuvastad ära konkreese, et mis inimese näkus on, et see järekorda võtab sellest file ja proovi pärast tuvastada, kas see on pelle või see on keegi teine näku. Ja siis panab teise järekorda, et see oli pelle, keel 12.30 oli pelle seal toas ja siis mingi teine protsess, kuskit veebiprotsess näiteks järekordast võtab selle ja saadab alerted. Me saame järekordada põhise suhtluse tekitada hajussisteemide komponenteid vahel. Ja see on tihti kasulik, sest see tähendab, et kõik protsessid ei pea oma vaal otsesuhtluses olema, nad võibad ise otsustada, kui tihti nad vaatavad neid järekordi. Ja see võimalda palju paremad skaleerimist, sest me saame tegelikult panna kümme samasugus protsessi kuulama täpselt sama järekorda. Ja kõik pildid, mis järekorda saadatakse, me saame nende kümme protsessi vahel ära jagada, et siis see tekitab väga lihtsam mustri, et kuidas skaleerid arvutusi me lihtsalt paneme palju protsesse sama järekorda kuulama ja nad jagavad oma vaal sõnumid ära. Aga kõik see omadus onki, et saaja ei pea enam ootama ühendust, vaid ta saab lihtsalt vaadata järekordas, kas seal midagi on või mitte. Ja tihti selliste sõnumi järekordade vahevara, see tarkvara, mis implementeerib neid postkastid, see on siis vastutav nagu tõrke taluvuse, anmete püsiva salvestamise eest, et neid sõnumid kaduma ei läheks või et neid sõnumid kiiresti kohale toimetataks või et neid sõnumid oleks nagu vajaliku sellise, kuidas sa räälda, quality of service inglis keeles, et neil oleks vajalik, kas 100% karanteeritud kohale toimetamine või estisuur jõudlus, mis ei karanteeri 100% kohale toimetamist. Ma rääkin sellest natuke iljama. Ja selline kõige klassikalisem hajussusteemide või isegi paralel arutustes, protsesside vahelse sõnumid te kohale toimetamise tarkvara või pigem tarkvara asemel seda nimetada liideeseksest. See on selline liides, mida erinevad tarkvarad implementeerivad, on MPI, Message Passing Interface, implementatsioonid on näiteks OpenMPI ja see on hästi vana tarkvarad, seda kasutatakse 80.-90. sellises suur arvutustes või paralel arvutustes arvutukriidides sellist arvutussimulationide implementeerimiseksis suur arvutust. Ja põhimatselt ta muudab sellise lokaalse protsessid vahelse suhtluse globaalseks, et on võimalik defineerit, et mul on 16 arvutid, kes teevad koostu, et nimiod, et nad jagavad oma vahel sõnumeid, näiteks mingite matriksite arvutuse korral nad jagavad matriksitükkideks, väiksemateks matriksiplokkideks, iga matriksiploka näiteks sõnum, mida siis paralelselt töötavad protsessid oma vahel jagavad. Ja ta ongi nagu selle gruppi suhtluseks paralel arvutuste raames ja. Ja et ma pigem räägin näidete ka. Sõnum ennepjäis võib olla üks kõik, mis sugunne tüüpilline programeerimise objekt programeerimis keele objekt, et see võib näiteks olla integer väärtus üks väärtus, see võib olla mingi int ärei int list, see võib olla ka string, näiteks mille see on json objekt või xml objekt, see võib olla ka lisapinaarne mingisugune objekt, mida hiljem parsime näiteks mingiks java klassiks või puton klassiks. Klassi instants objektiks. Et samuti peab tegelikult klienti ja server omaal kokku lepema, et mida me saadame, et kui üks osapool saadab integeri, siis teine peab põhimõttelselt otsustama, et tema sellel hetkel võta pastu integeri. Et see teeb selle programeerimise päris keerukaks. Kui kirjutada programmet C-s või Fortanaris, siis pidi isegi paika panema, et kui ma saadan ärei, kui pikse ärei on, et kas seal äreis on 16 elementi või seal on 128 elementi. Ja seda tihti pandi paika vastavad näiteks maatriksi või maatriksis suurusel, et kui maatriks 1000x1000 maatriks ja me jagame nüüd 10 processi vahel, et teeme võib olla 10x10 väikselt maatriksiplokid ja jagame nüüd processid vahel ära. Ja siis sanumid olid neid väiksemat plokid. Ta on suhtselt selline madala tasemel programeerimine eriti varasamates programeerimiskeltes nagu Fortran ja C. MPI-t saab kasutada ka Pythonis, on selline openMPI-t ka Pythonile. Siis on natuke lihtsam, sest automaalsed arvutadakse need bufrite suurused ja ei pea käsit siin, et ei ta ole paika panema, kui nagu C-s või Fortanaris pidi panema. On sellised tüüpilised metadid, mida saab välja kutsuda, võite kujutad, et meil on 16 processi, kes nüüd peavad koostööst tegema mingid maatriks arvutusi, et siis nad saavad oma vahel saata MPI send või MPI receive sanumid selleks, et üks osapool siis ütleb, et mina tahan vastu võtta maatriksid ja teine osapool ütleb, mina saada maatriksi ja nad panad üksteisei nagu process ID-t argumentideks, et siis process 1 saadab maatriksi process 2, siis process 2 peab kutsuma välja MPI receive ja process 1 peab saadma MPI sendi ja nad peavad samal ajal nagu mõlemad tegema seda. Ja kui seal läheb cyklist või synkroniseerimist välja, siis võib juhtuda, et program on hästi ebaefektiivne. Et see oli selline madalat aseme, paralel programeerimine, ja IP-adressat asemel kasutati nagu process ID-sid, et kui meil on 16 programmi või 16 processi, mis teavad paralel arvutsi, siis meil on processid 0-15, kes saavad siis oma vahel saata sanumid, et process 1 saadma saata sanumid process 16-le, ütleb 15-le, kui 15 samal ajal kuulab. Aga kuna see oli natuke eba meeldiv, siis tehtiga sellised mitte blokkeerivad sanumidte saadmised, mis olid siis asynkronsed, et ma sain saata sanumi, aga ma ei jää seda ootale. Ja ma saan öelda, et ma olen nõus vastuvõtma maatriksi, aga ma ei jää ootale. Ma ei jää ootale, ma hakkab midagi muut tegema. Ja siis, kui ma taan seda asynkronsed saadetud maatriksid vastuvõtta, siis ma saan kas testida, kas selle muutujal, mille väärtus panaks selle meetadi põhjal, kas selle muutujal on väärtus kohal või mitte, või siis ma võin tõesti ootama jääda, et veit või veit eniga, et ma jään kõiki sanumid ootama. Ja sain imade asynkronsed oodata sanumeid selleks, et vältida sellist olukordagus. Mina küll proovin saata, aga keegi vastu ei võta, et ma ei saagi sanumid saata. Ja lisaks oli sellised kollektiisid operatsioonid, et oli broadcast, et näiteks selline pealik programm võtab maatriks ette, jagab selle 10 blokiks ja saadab skatteri abil iga, et kõigile processi lüüa selles 10 blokist. Et skatter võtab mingi listi objektidest ja saadab iga objekti erineatel processidele. Broadcastiga saab siis näiteks võtta mingi vektori ja saata kõigile processidele täpselt sama koopja vektorist. Ja en peahe ikäteriga saada teha niimoodi, et kui nüüd mina pealik programmina olen jaganud maatriksi 10 blokiks ja saatnud kõigile teistele processidele ja kõik processide oma arvutus ära teid näiteks mingi maatriksikorda vektori korutise. Ma saan en peahe ikäteriga küsida kõikide processide käest, antke mulle tulemus ja koguda 16 tulemus ühte processi kokku ja panna see näiteks arvutatud maatriksi vektori arvutuse tulemus, mis on hajusalt arvutatud, siis tagasi kokku näiteks üheks vektoriks või pealik processis. Aga see oli ka selline suhtselt madalatasemet programeerimine, mis tänapäeva on järjest vähem populaarseks jäänud, kasutatakse peamised sellistes superarvutites ja ästi arvutusmahukate arvutuste pool, kus on hästi tähtis, et optimeerida ästi madalatasemel nagu jõudlust. Pige mingi big data arvutust, siis kasutatakse palju kõrgemataasemeliseid tarkkavaraad. Vältida sellist madalataseme programeerimist, kus me peame tegelema üksikute sõnumite saatmisega. Ja see on ka üks põhjus, miks on kasutusele võetud hajus objektid ja hajus meetodid, millest ma räägin siis järgmise lueng. Võib-olla natuke huvitavam osa teeaks, kuna seda kasutataks ka tänapäeva hästi palju erinevates mikroteenustes ja webitehnoloogite puhul, on pigem need teatate järekordade suhtlused. Idee on siis, et meil on mingisugused protsesid, kes tekitavad anmed, kes saadavad anmeid ja meil on neid mõepall erineva tüüpi ja meil on mingisugused protsesid, kes on huvitatud anmedte kätte saamisest, et näiteks neid panavad selle anmebaasi ja meil on mingit IoT sensori, mis genereriood need anmeid võib-olla mingi mobiil programmiid kasutate telefonides, mis saadavad mingisugused hetke asukohtad, näiteks kus kasutate asub, et demageografist, koordinateid ja midagi. Ja selle aseme, et need anmeded toodjad otsse saadaksid anmed soovietele, me kasutame sellised vahe vara, ingliskelesis message oriented middleware, kus me tekitame postkastid, kuhu saab need anmed saata, et näiteks ühe rakenduse klendiid siis saadavad topik A-se, anmed teise rakenduse klendiid näiteks saadavad topik B-se ja kui on nüüd mingisugused, teised programmid või processid, kes soovivad need anmed kätte saada, siis neimad lihtsalt peavad teadma, millises selle postkasti need anmed saadatakse ja kuulama seda postkasti. Ja siin on erinevad mustrid, kas kui on sellel postkasti nelikuulejad, kas nad saavad kõik samad anmed, kas anmed replitseeritakse, kui on nelikuulejad ja siia saadatakse sõnu maa, kas kõik saavad sõnuma jaa kätte. Või siis, kui me tekitame sellise tööde järjekorrat, me soovime pildi töötlus teha nelja, et meil on kolm klendi, kes saadavad see piltte ja me soovime, et hajutada pildi arvutusi nelja, konteeneri nelja programmi vahel või nelja protsesi vahel, siis me saame tekitada siia, et kui tuleb esimene pilt, see läheb esimesele, kui tuleb teene pilt, läheb teisele, kolmas pilt läheb kolmantele, neljas pilt on neljantele, viies pilt läheb oost esimesele, kas või selline round robin lähenemine anmed hajutamisel. Seda saab tihti defineerida vahevarat asemel, et kui meil on mingisugune topik, mingisugune postkast sinnet, kuidas need anmed jakatakse kuulete vahel, kas kõik saavad koopia või jakatakse vahel ära. Ja siis kohel erine rakendusele meil võibki olla kaks erine topikud ja need isoleeriteks lihtsalt loogiliselt või tarkku arv asemel, et tihti klientid saavad ise otsustada, mis teemat nad kuulavad või mis postkast, mis järekorda nad kuulavad ja see meie klientid, kes toodavad anmed ei peagi tegelikult mitte midagi teadma klientides, kes anmed kuulavad ja üks hea elis on, et siin peavad kõik poordid lahti, olnud et internetis saaks jää ühenduda, aga tegelikult need klientid ei pea nagu luba ma ühtegi välis ühendust, mida nad ise ei ole algatagud, et nemad algataad nagu ühenduses selle vahevaraga. See võimaldeb natuke turvalisemaid lahendusi luua, aga võib-olla see 100% karanteerid. Ma tahan, et kuulaja saaks anmed kätte hästi lühiks aja jooksul, siis tegelikult sul ei ole võimalus kontrollida, kas kuulaja on elus või mitte. Sa saadad selle anmed siia ja loodad, et kuule ja praegu kuulad. Otsesuhdlus, mis on sõnumid otsesaadmene võib-olla võimalda natuke täpsamad kontrollida, kas teine osapool sai sõnumikätt või mitte. Kuigi ikka tihti pakutakse erinevaid võimalusi selle kontrollimiseks selle vahevarapolt. See võib-olla näiteks niimoodi, et saadatakse ainult nendele, kes on hetkel aktiivselt ühenudunud. Et neid on erinevaid mustreid, kudas on. Me nägime natukusest rapid MQ kohta ka, et sul on võimalik tekitada järjekord, kus sõnumid saadatakse kohal ainult nendele hetkel kuulejatele, aga sul on võimalik ka selline püsiv järjekord tekitada järjekord, kes on tegelikult. Ja siis on kõik, et tegelikult on järjekord, kes on tegelikult on järjekord, kes on tegelikult on järjekord, et nendele hetkel kuulejatele, aga sul on võimalik ka selline püsiv järjekord tekida sõnumid peab alles, et kuule ise küsib, et Anna mulle esimene sõnum järjekord, sõna teine, Anna kolmas, ma olen hetkel seitsemante juuras. Et järjekord on seda sõnumid, aga ma ise nagu kerin niöelda järjekordade vahele. See lisati vist suhtselt hiljuti paarast takas rapidis, et seda võimalik teha. Ja see vahevara otsustabki seda, mida ta võimaldeb ja kudas. Ja siin kasutane saad tihti valida, et mis järjekorra või poškasti tüüpise kasutada. M-kütiti puhul sulle seda valik, et tihti väga ei ole, aga rädid või kafka võimalda, et väga sellised keerukad mustreid kasutada sõnumidne kohale toimetamisele. Ma vaatan, kas ma midagi ära omustunud. Ja tihti ütleme, et me soovime teha mingisugust webi tarkvarad, et siit tuleb päring ja siin on mingisugun webi tarkvarad, mis peakse oleva päringul vastava. Kuidas me seda tegime sinna? Seda on suhtselt keeruline teha, aga põhimise, et kuidas sa töötab niimoodi, et meil on klient, kes adab päringu, aga ta tekitab siin järjekorda enda eaks. Ta saadab päringu, mida peaks mingisugun webi server töötlema, aga ta tekitab siin ka enda järjekorda, kui tema nagu selline töö või sõnum jõuab kuhugi töötlejasse ja töötlejab peaks nüüd selle kudagi tagasi saadma originaal sellise klientile. Ja kuidas see töötab, et see protsest tekitab siin enda unikaalse järjekorda ja saadab selle järjekorda aadressi kaasa oma sõnumiga. Kui see sõnum töödelteks ära, siis vaadad ka sõnumise eest, mis on see järjekord, kuhu peaks tulemuse tagasi panema ja siis publiseeriteks see tulemus ja teise järjekorda ja see protsest jääb kuulama seda järjekordad. Ka sellised mustraid on võimalik teha, et tekida sellist aasünkroonsed suhtlus, kus me tahame, et vastus tagasi jõuaks originaal selle klientile. Kõige madalal tasemel teadate järjekordat, et primitiivid on sellised, et me võime järjekorda mingisugus uue sõnumi lisada. Me võime kuulata, kas sõnumi järjekorras on mõni järgmine sõnum ja jääda kuulama niimoodi, et anna mulle sõnum ja kui sõnum tuleb, siis ma käivitam mingisuguse metodi, et see on selline callback-metod, et iga ma jään kuulema, kas on uusi sõnumid, iga sõnumi kohta ma käivitam mingisugus püüta metodi ja see metod on siis vastutav sellest, et mida selle sõnumiga teha. Ma võin ka pollida, lihtsalt käia küsimas, kas hetkel on sõnum, võtas see sõnumid kätte ja siis väljude, ma ei jää kuulama, aga ma isa otsustan, kunama uuesti, siis lähen ja küsin sõnumid järjekorrast. Või siis ma tekitam sellise notify, et mu process võib jääda täiesti magama, aga ma saan signaali ja minu program või process käivitatakse Linux kernel-poled uuesti üles, siis kui sõnum tov järjekordad. Ma defineerin, et ma jään sõnumi tootama, aga ma ei pea jääma aktiivselt tootama, on okei, kui minu process panakse pausile ja ei kävitada enne, kui tuleb mingisugune üles sõratamine sõnumipolt. Et see võimalatab sellist natukene targemad või efektiivsemat processid töötlust, et ma ei taha tegelikult pollima jääda igavesti, et meie process kulutab, processi raega lihtsalt selleks, et kontrollide, kas seal midagi on, või jääb kuulama aktiivselt ja jääb tööle ja aktiivselt kuulama. Ja siis on võimalik ka sellist notify põhist eratamist kasutad, et me lubaame arvuti processoril selle processi magama panna, kuni tuleb uus sõnum ja siis saame notify signaali ja siis eratavadks selle processi uuesti üles. Ja kui me ehitame hajus rakendusi vajus sõsteeme selliste teadate järjekordadega, siis meil on tihti vaja defineerita, mis on sellised lähte järjekordad, kus me anmeid kuulame, mis on siht järjekordad, kuhu me anmeid saadame. Me peame meeles pidama, mis on järjekordade aadresid nimed, kus on see anme paas, kus sa asub. Ja see järjekordade nimed on suhselt keeruline, mida te isepraktikumis ka näet, et kui hästi te aru saata meie praktikumikireldusest, et kuidas need järjekordade nimesid kasutada. Meil on vaja üles jääda kusakil siis see vahe ja vara järjekordahaldurid, mis samuti peab jooksma teenusena kuskil serveris. Mõnikorda on meil vaja nagu mingisugust edasisuunajad, mis kuulavad mingit järjekordaja, otsustavad näiteks, et suunata, sinna tulevad teatud tüüpvisõnumid kuhugi mujal. Näiteks, et meile tulevad sisse pildifailid, aga kui on png-failid, siis me tahame töödelta neid ühe processi poolt ja kui on näiteks jpg-failid, siis me tahame teise tarkvara poolt näid töödeldasime, võib-olla teeme järjekordade vahelselt sellised ümper suunajad. Meil tekelikult tekib selline järjekordade võrk. Selle asemelt ma ainult mõtlem selle peale, mis on neid processid, mis jooksevad ja kuidas nad omavahel ühen tuvad. Me peame ka naku haltama järjekordade võrku, et kas kõik järjekordad on loodud tekelikult sell vahe varas. Muidu meie processid ei prugi töötada, kui midagi on puudu. Ja nagu loogilselt asemel sellise programeerijana, kes on vastutav arhitektuurie, et nemad peavad siis mõtlema ka nende järjekordade võrku peal, et kust kuhu anmeid saadetakse, sest te ka näete praktikumiseb, see on suhtselt selline keeruline olukord, kus te peate kontrolli, et ega kokemat, et mul kaks erinevat processi ei saada samas viis järjekordanmed, et siis seal lähevad need sõnumid, erinaat tüüppi sõnumid sassi ja mina arvan, et selt tulevad ainult sisendanmed, aga millegi päris saadetakse sinna ka alerte ja siis ma proovin töödalt anmed, aga need ei ole sisendanmed, ne on teist tüüppi anmed, siis minu tarko oli tööta, aga koodis mingid probleemi ei ole, probleem on järjekordade nimedes, et valesti on järjekordade nimed konfigureeritud. Ja järjekordade see vahe vara tihti nimetatakse, kas Englis käis näiteks brokeriteks või estikeles makleriteks või halturiteks on sõnumid järjekorad või anmed brokerid. Meil on probleeme anmedte tüüppidega, et SQL anmedbaaside puhul me paneme paika, meil on tabulaardad anmed, meil on anmedtel tulpad, tulpadel on tüüpid ja nimed, aga sõnumides seda tihti nagu paika väga panna ei saa, et me võib-olla paneme paikat. Meie tarkvara saadab Jasoni ja kuule, et teavad ette, et meile tulevad Jasonid seld järjekoras, aga mis siis, kui järjekorad ta tuleb mingisugusid pinaarsed anmed lopiselt? See tuleb tegelikult kokku lepida klientide tasemel ja sellised maklerid ja brokerid tavasti isegi kontrolliseda, et kas järjekoras on Jasoni mitte, nemad lihtsalt vaatad need anmed kui pinaarsete objektidena, mida siis klientid peab parsima Jasoniks enda tarkvara parseritega. Tegelikult sõnumid võivadki sisaldada üks kõik mida ja brokerid tavaltsid seda ei kontrolli. Klientid peavad siis või see tarkvara peab kokku lepima, mis formaate kasutatakse hajussüsteemide komponentide vahel ja arvestama, et kui lubatakse erinele formaate, et kudas seda kontrollitaks. Kui me lubame samas see järjekord saada erinaid tüüpi pildifailid, siis kes kontrollib seda, mida tahaks see PNG-ega ja mida tahaks see JPE-ega formaatika pildidega. Meil võivadki tekida speciaalsed sellised hajussüsteemi komponentid, kelle üle saan ongi valiteerida või kontrollida või ruutida neid sõnumeid vastavalt nende sõnumide struktuuridega. Hea on neid tavalst vältida kui võimalik. Aga isegi, kui me teeme nad, siis hajussüsteemi mõttes on tavalised komponentid, mis kuulavad järjekordasid ja kirjutavad või publiseerivad mingitase järjekordatasse. Kui meil on mingisugused sellised valiteeriat, kes kontrolli, jõudkas sõnuma on õigest formaatise mitte, ja see otsustavad kuus seda edasi saata, siis hajussüsteemi mõttes või süsteeme arhitektuurimõttes on nad tavalised protsesid, kes samuti kuulavad ja saadavad sõnumid järjekordasse. Üks selline lihtsam sõnumid järjekordade põhine protokoll on MQTT, selleks on mituimplementatsiooni, ma näiteks Mosquito on kõige lihtsam MQTT implementatsioon. Pilvedes on erinevad võimsomad implementatsiooni nagu ActiveMQ ja RapidMQ ei ole MQTT. MQTT ja RapidMQ, te MQ on küll väga sarna asja, MessageQ või põhimestel on need erinud asjad, et RapidMQ ei ole MQTT. MQTT kasutab sellist anmete avaldamise ja tellimise mustrit. Meil on anmete loojad, kes publiseerjavad anmeet ja meil on anmete lugead, kes tellivad siis anmete kohale toimetamist. Ja üldjuhul seataks MQTT üles eraldi servelete, nad me ei embedi seda kui tegama tarkkora sisse, vaid me seame üles mingisuguse IP-adressi ja porti peal ja hakkame sinna sõnumeid saadma ja selt sõnumeid kuulama. Me saame siis hajusesteemide komponente panna sinna ühenduma, et kõik IoT sensorid paneme näiteks sinna publiseerima anmeed. Ja kui meil on mingisugun tarkkora, mis soiv visualiseerida anmeed, siis me tegitame tarkkora, mis on võimelne MQTT teemasid või teatete järjekorda siis kuulama ja võib-olla visualiseerib siis JavaScripti abil näit IoT sensoridte poolt saadetud anmeed. Ja ta soovib väga hästi A-sünkronseks suhtluseks. Sünkronset suhtlust ongi raske nagu tegelikult tekitada MQTT abil. Meil on siis mingisuguna hulk sõnumite tootjad, N-sõnumite tootjad ja mingisuguna hulk M-sõnumite kuulejad. Et see võib-olla näiteks 10 000 ja see võib-olla üks, et kui meil on selline IoT elahendus, kus on üks server, mis anmete kuhamisega tegeleb ja 10 000 sensorid, mis saadavad. Ja me saame jagada nend kõik sõnumid, mis tulad siis N-sõnumid, siis M-kuula vahel ja meil ei ole vaja mingisugus keerukad sünkroniseerimist tekitada, et kes saadab mis ajal või kes kuulab mis ajal või kes peab vasta õtma võid. Meil ongi lihtsalt, et mõnevõt ühenduvad MQTT-tise ja kas saadavad või kuulavad anmeid. Lihtsustatud ilustraksioon, kuidas see töötab, on see, et meil peab olema mingisugune anmete saatja, meil peab olema siis see vahevara, kes tegeleb anmete saatmise või vastuvõtmisega ja meil ei pea olema anmete kuulejad. Kuulejab võib olla ilmas aatjada, aga siis ta ei saa mingid anmel käete. Ja anmete publiseeria ei pea eksisteerima ja anmete kuule ei pea eksisteerima, et põhimõtteliselt võib akata tööle siis, kui andüks nendest on. Aga eheldem, et ta saatja on esimene, et tema teb ühenduse brokeriga, et proovib ühendus saada ja siis teeb põhimõtteliselt saab vastu, et jah, ühenduse tegemine õnnestus ja tal tekib ühendus, kus kaududa saab anmete siis saad makata. Siis näiteks meie IoT-sensor teeb ühenduse brokeriga ja siis alustab tööd, aga sensoritelt veel mingida väärtase ei kuula ja ei publiseeri veel anmeid mingi aeg. Ja samal ajal pärast seda võtab siis ühendust mingisugune mingi anmete tahtja, kes samuti võtab ühendust brokeriga, et ma soovin ka ühenduda brokerisse ja saab samuti vastus, et ühendus õnnestus ja tema nüüd saadab teat, et ma sooviksime mingisugust teemat kuulata ja tema võib olla näiteks delta punkt kolmas korrus punkt ruum 3040 punkt temperatuur. Tihti kasutadaks sellise mitmed asemelisi teemasid, kus me kirjaldame ära, et mis anmetega tegu mingi asukoht ja mingit sensori või anmete tüüp. Meil võib siis olla näiteks delta punkt korrus punkt ruum punkt anme tüüp, et ma soovin oma kontoritemperatuuriväärtust siis kuulata. Ja ma ütlen, et ma olen siis kuvitatud sellest teemast ja ma saan vastu nagu kinnitus, et ja, see õnnestus ja siis ma jään nagu kuulama seda teemat. Ja idee on siis see, et mqtidiprooker saadab sellega teemaga seotud anmed tagasi, kui need tekivad siis mqtidisisse. Et ma panen paikse, ma taan delta kolmanda korrus ruumi 340 temperatuuri kuulata. Ja kui see sensor on siis minu toas või ja tal on ühdust sensor, stakab näiteks iga ühe minuti oksu, iga ühe minuti tagant saadma temperatuuri anmed näiteks. Ja siis sensor ise defineerib, et mis teemag anmed ta saadab. Et ta saa võib oppi saata mingit muud anmed, aga eheltev, et meil on sensor siis sama topikuga, et selle korrusse, selle tuatemperatuuri väärtus oli mistas on 22 graadi. Ja kui see topik vastab sellele topikule, siis need anmed, mis siia saadatakse selle teemaga, saadatakse edasi siis nendele klientidele, kes on sellest teemast huvitatud. Ja selline anmedte kohale toimetamise loogika ongi siis teemade põhine. Et mina defineerin, mis teemast ma on huvitatud ja kui selle teemaga seotad anmed tulevad, siis need saadatakse mulle kohale. Ja siin ma ei pea koku panema sellist e-maili postkasti adressi, et kuhu ma soovin sõnumeid kohale toimetada, vaid ma defineerin sellise loogilise patternmatchimise põhise teema, et ma olen teatud anmedest huvitatud. Ja selline subscriber klient võib tegelikult defineerida mitmed teemad, et ta võib olega teistest teemadest huvitatud, vajadusle kasvõi sada teemat. Et ta defineerib, et mis teemadest on huvitatud, et mis teemadel ta nagu subscribib. MQTis pigem mitte rapitis ja, aga rapitis see töötab ka teist moodi. Rapit on suhtse tereinev sellest, kuidas see MQTis töötab. Aga MQTis ma defineeringi niimoodi, et ma saan kasutada selliseid teema, alam, stringid eraldade, mis on kaltkripsud. Ja nendelt asemel ma saan defineerida sellised wildcardid. Näiteks ma olen huvitatud, kas my home ground floor living room temperatureist või ma olen huvitatud my home ground floor üks kõik, mis toa temperatuurist. Või siis ma olen huvitatud kõikidest andmetest, mis on my home ground flooriga seotud. Ma saan kas ühed aseme sese wildcardi kasutada või siis mitmed aseme wildcardi kasutada, niimoodi, et ma defineerin, et minu sensorit sada tundus sellise struktuurikandmeid ja siis ma saan kuulata sellised teemased. Ja see võimaltaab defineerida sellist grupid andmetest, kui ma olen hästi designinud teemadestruktuuri. Aga kas see on siis midagi, mida rakenduse arenda ja päris väljamõtlem hakkama, et mis on see teemadestruktuur, millisugused sellised päringuid ma tahan defineerida nende teemade tasemel, et ma ei saa tegelikult andmebaasi päringuid teha, ma saan lihtsalt kuulata teatud struktuuriga sõnumite teemasid. Is kui ma kuulan my home ground floor, cult creeps ja seda trelle, siis kõik, mis algavad selle prefiksiga, jõuvad kohale. Kui ma seda teemad kuulan, siis mulle saadadks kõik andmed, mis on seotatud teemadega, mille on selline prefiks. Ja tegelikult MQTC's ei olegi nii väga erinevad järjekordi, pigeme nagu üks järjekord ja te partitsioneerida andmeid siis põhimõtsalt nende teemade põhjal. Kuigi loogiliselt tekivad nagu järjekord, et mul on selline järjekord, mul on selline järjekord, mul on selline järjekord, aga siis implementeerimised asemel on nagu üks hiigel sur järjekord ja lihtsalt partid, teemade filtreerimined või andmete filtreerimined nende teemade mustrite põhjal. Ja ma saan ka defineerida nagu quality of service, et kas sõnumid viiakse kohale kõige rohkem üks kord, et karanteerid, et mingisuguna alarm näiteks ei jõua kohale kaks korda, see on nagu nul kvaliteetitase, kvaliteetitase üks on sõnum edastataks alati vähemalt üks kord kohale, et see vahevaras siis karanteerib, et kui ma olen sõnumi saatnud vahevarale ja ühendub sõnumite kuule ja siis ta saab vähemalt ühe korra sõnumi kätte, aga ei karanteeri, et ta ei saa mitukorda seda kätte, et võib-olla korraatakse seda, et näiteks, kui klendi käest ei onestund saada kinnitust, et sõnumi jõudis kohale, siis saadataks uuesti, kuni saab kinnituse. Ja siis on võimalus ka defineerida vahevarad asemel, et ma tahan karanteerida, et sõnumid jõuad kohale täpselt üks kord, et kui ma olen sõnumi saatnud ja hiljem ühendub klient, siis see klient saab sõnumi kätte, et eht kontrolliteks üle, kas ta sai sõnumi kätte ja karanteeriteks, et ta ei saa kunagi rohkem kõikskohal seda sõnumid kätte. Ja see toimub taustal, et vahetatakse paket, et küsiteks kliendid, kas sa oled sõnumi kätte saand, kui klient ütleb, et ei ole, siis saadatakse sõnum ja küsiteks, et tema kas koko aeg kas oled kätte saand. Ja siin on sisse eitada sellised kontrollid ja acknowledgemendid, et karanteerida, kas sõnumid saadatakse vähemalt üks kord kohale, kas sõnumid saadatakse kõige rohkem kõikskord kohale või siis sõnumid saadatakse täpselt üks kord kohale. Ja kui teid huvitab, nagu server jõudlus või selle vahevarajõudlus, siis 0 on kõige lihtsam ja 2 nõuab palju rohkemad võrguliiklust, et karanteerida, et anned tõesti jõudsid täpselt üks kord kohale. Ja vastavalt sellele toimub see protokoll, siis kuidas täpselt need sõnumid kohale toimetatakse. Siin on üks näide, et kui ma tahaksin implementeerida mqtj brokeri abil lampide sisse väljal ülitemist, et kuidas ma saaks saa teha, et ma näiteks tekitan siis mikrokontrolleri, kes on ühendatud lampidega, tema saab saata analoog signaali näiteks lampile, kes lampe sisse või väljal ülitada või on digitannesignaal mis ikanes. Tema on võimelle, siis lampi toas sisse väljal ülitama ja tema subscribib siis, ta hakkab kuulama, kas talle on uusi lampide sisse või väljal ülitamise operatsioone ja ta hakkab kuulama sellist sõnumid teemat nagu home slash office slash lamp, et see on minu kodu officei lamp ja kui siia tuleb sõnum on, siis ta saadab sisse lampile signaali lüüta sisse, kui siia tuleb sõnum off, siis ta lüültab ta välja ja nüüd sel eks, et seda lampi sisse väljal ülitada, peab mingi klienti ühenduma ja mqtitiseja saadma siia selle topiku ka selle teemaga sõnumi, mille sisu on, kas string on või string off. Ja nüüd klient saab seda teha, klient peab teadma, kus asub mqtiti broker, aga klient ei pea teadma, mis on sellega mikrokontroller IP-adress, ei pea teadma, mis on selle mikrokontroller port, tema peab teadma, kus asub mqtiti broker ja mis on see teemade struktuur, et mis on näiteks lubatud asukohad, mis on vajalikud sõnumid, mida saata ja nüüd saavad siia üks kõik, mis klientit nagu põhimõtteliselt spamida näiteks need on ja off operatsioone ja tarku ära mikrokontrolleres võib-e lihtsalt isegi otsustab, et kui siia tead, et mingi mingi mingi mingi mingi näiteks kolm off järjest, mida siis teha. Senna ja sa pautentimise siin peale pan, et on kasvutanimia parooli näiteks ja jagada nendele klientidle siis kasvutanimesest parooli, aga siin peab olema kasvutanimeid paroolid. Sa võid ise seata ilma kasvutanime paroolid ta üles mkittiti broker, kes ei ole hea mõte. Ja rapidis saab rohkem nagu kontrollida, mis suurkust kasvutad ja mis nende roolid on, aga mkittiti siia saab lihtsalt kasvutanimesed ja proole defineerida klientidle. Ja mõlemad on tegelikult klientid, ainuke server ongi siis mkittiti broker ja klientidel siis ei ole vaja portte lahti hoida, et teevad ühenenduse ja selle ühenenduse kaudu põhimistad saavad vastuseid mkittitigest. Jah, aga seal saab kontrollida seda, et sa lubad ainult. Kelelt sa lubad sinna pakete? Jah, sa saad sinna tulemyrii tasemel pana reeglid, kellel on lubatud avaliku portte almet saata. See vahe on see, et sa ei pead seda ette paikka panema saa tarkovaratasemel otsustad, et sellel tarkovaral on lubatud ise teha ühenendusi, aga ühtegi sisse tulad ühenendusti olla lubatud ja sa lubad ainult need ühenendused, mida see tarkovara ise on teinud. Ja sa ei pea tulemyrit tasemel midagi muud konfima, kui panad kõik portit kinni ja lubad ainult need ühenendused, mis on seotud välja minem ühenendusega ja siis rohkem reeglet seal vaja ei ole, et sa ei pea ette teadma, okay, ma luba sellel arvutil Tallinnast ja sellel arvutil Soomeest ühenenduda. Sa lihtsalt lubadki ainult nendel arvutil tüül ühenenduda, kus siit on välja minev ühenendust tehtud ja see on nagu see on hästi lihtne tulemõri reegel, et sa lubad väljavad ühenendused ja selle väljavad ühenendusega seotud tagasi tulevad ühenendused. Vist operatsioonid süsteemid aines ka seda nagu võrgu ruutimise praksis nagu prooviti, et mis on see IPT plus rule, mis lubab selle tagasi tulevad ühenendustega seotud paketid. Et me panime üles ühes projektis anmebaasi ja praeg on lubatud sisse tulevad ühenendused ainult Tartu linnavalitsuse võrgust ja Tartu ülikolivõrgust ja muualt ei ole lubatud ja iga uue regli me lisame sinna pohjumist käsitse, et kui me luba mingi partnerlikasin anmebasi ühenenduda, siis avame näed poordid nende jaoks, et seda on alati võimalik teha lihtsalt lihtsam on turvata, kui peaselis speciaalselt regleid juurda panema. See otsaselt ei karanteeli midagi, et kui keegi proovib männende midale täki teha ja kuulab pealt, mis see sõjandust toimud ja alati on võimalik röönaata. Aga see musta selles mõttes lihtne, et nüüd ei pea enam teadma paljude mingite väikeste seadmete IP-adressi ja me võime sellist hajussüsteemite vahelise ühenenduse ehitada selle mqt-brookerid asemel, et me ei halda serverite komponentide asukohta vai sellise vahevara asukohta on ainult ka vajalik informatsioon meil. Ja natuke võimsam protokoll on siis Advanced Messaging Queuing protocol, mis on siis alkatatud 2006 aasta ja esimene versioon, selline ready to use versioon on 2011. Üks kõige tuntumaid implementatsioon on RapidMQ, aga ka näiteks Apache ActiveMQ ja Pilves on palju erinevad nagu Azure Service Pass, Amazon MQ implementatsioone sellele. Rapidid kasutatakse dihti mikroteenuste puhul, selleks et teha sellist asunkroonsed ja järekordade põhist ühenendust mikroteenuste vahel, et kui meil on hästi keerukad mikroteenuste põhised justiemid, et siis on hea nagu selline anmete buferdamine ja anmete jagamine teha nagu sellise vahevarat asemel mitte panna see nagu protsasside enda kaela, et kudas seda täpselt teha. Ja ta on seda avatud standaard, siis sõnumitele orjenteeritud vahevar ajaks, ta on täiesti asunkroonne kui seal saab natuke nagu asunkroonsed suhtlust teha ja täiesti nagu järekordade põhine. Ja tegelikult te võisite märkata seda ja ma isegal seda ütlesin, et siin nagu mõnes mõttes võib-olla ei tekigi paljusid järekordasid ja meil see subscriber tegelikult ei ühen tou järekordada, aga panep paika sellise anmete partitsioneerimise ja filtreerimise operatsiooniselle nende teemade põhjal. Aga rapidis tekivad tegelikult konkreese järekordad ja klientid saavad ühenud olema järekordad, et anmete kuulata, nad ei saas suvaliselt defineerida, et mis on see anmete päring või niimoodi. Kuigi tegelikult saab saavud tehtseelt sama tulemuse, aga see toimub natuke erineval viisi. Ja seal on nagu anmete krüpteerimine, anmete autentimine või kasutate autentimine ja seal on väga erinevad viisid, kui saab kontrollida, et mis kasutatel on lubahtud teha. Isegi võimalik märjata, et see kasutaja ei saa rahkem saada anmeid kui näiteks 200 megabaiti päevas, midagi sellist, et saab anna isegi sellised piirangud peale kasutatele, et mis on lubahtud korraga saata. Ja IMQB on palju selline keerukam, et meil ei tekki ainult nagu järjekorda, kuhu me saadame anmed, järjekordi, kust me anmed loome. Et mul on täiesti erinevad anme, ütleme anmestruktuurid või olemid, kuhu me anmed saadame, et me saadame saata ainult exchange anmed, mis on sellist ühenudusõlmed serveri sees ja me saame saata näiteks IoT või Delta maja exchange anmed, et siis seal exchangei sees on kõik Delta ka seotud anmed võimõtselt. Ja järjekord on ainult anmed kuhulamiseks, et exchanges on siis anmed saadamiseks ja järjekord on anmed kuhulamiseks. Ja teemad asemel on meil sellised väga sarnaased asjad nagu rootimis võtmed, et kui me saadame mingisugus sõnumi, siis me defineerime, et mis on selles sõnumi nagu rootimis võtti, mis kirjaldab ära, mis anmed tegab tegu. Ja see on põhimõtselt sama asi, mis see teema MQTD sees, et see on selline string võt, mis on mitmed asemelne võt, mis defineerib ära, millega on see anmed seeotud. Ja selle põhjal teaks anmedte rootimis, siis exchanges ja kiuude vahel, ehk anmedte saadjade ja anmedte kuhulete vahel, siis rootitakse anmed, dynamiliselt nende rootimis võtmed põhjal. Aga see võtti võib olla meil saamoodi, et näiteks myfloor.calcgripseasemel on meil nüüd punkt, punkt livingroom, punkt temperature, et see struktuur on põhimõtselt samasuguna. Ja me tekitame nagu rootimistabeli, et misugused sisse tulevad anmed exchangei, me rootime misuguses see järekorda ja selleks kasutatakse sellised asjid nagu bindingud, et nagu rootimistabeli reeglid või rootimisreeglid, mis defineerivad, et misuguse mustriga võtid panna misuguses see järekorda. Ja neid saab dynamiliselt luua, et põhimõtselt sellest exchangesist, selle mustriga rootimis võtimega anmed panna sinna järekorda. Ja sõnum on siis mingisugune sõnum, mis saadatakse exchangei, rootiteks see bindingu põhjal mingisuguses järekorda ja sõnumil on mingisugune sisend anmed, mingisuguseks pinnaase tanmed näiteks, tal on ka heederväärtused nagu HATTP pool, et me saame seadistada, kes oli klient, kes sinna tanmed saadis, mis on objektiis suurus ja siia saab juurde nagu heederväärtusi panna, mingisuguseks võtti väärtustilis meta info ja rooting key on üks meta info, mis on seadud selle sõnumiga. Ja sisu on lihtsalt mingi pinaarna objekt ja samuti klientide tasemelise otsustadaks, et kas meil on JSON, mida me saadame, kas meil on XML, kas meil on mingisugune string väärtus, et klientid isa otsustavad, et kuidas nad parsivad seda pinaarsate objekti ja seda tavast ei panda mitte kuiidagi paikaa, kas exchangei või Q tasemel, et mis objekti on lubatud sinna saata ja see on tehti mõnikad probleem, et kui sinna saadatakse vale tüüpi objekti, et siis JSON või XML parsimine klientis siis feilib võib-olla. Ja peame erinevselt on, et me saadame andmed exchangei ja me kuulame andmed siis järekorrast. Ja peame erinevselt on, et meil on sellised exchangeid või ühendustölmed, et andmed ei saadata otsa järekorda ja meil toimub selline reglite põhine marsrootimine ja enam ei ole, meil on üks muster, mille põhjal me marsruudime, või meil on olla sada reglit, mille põhjal me saadame või kogume mingid andmed kuhugine. Ja järekord on päris erineva asja sellest MQTT teemadest. Ja pigem meil ongi teemad on samad, mis ruutimis võiti ja meil on palju järekordasid ja palju nagu exchange, kuhu andmed saada. Ja meil on ka sellise tüpilid operatsioonid, mida me saame bytonnist näiteks väljakutsuda, et me saame luua ua exchangei, et me looma näiteks delta andmed exchangei ja sinna hakkavad meie klientit delta ka seotud andmed saadma. Me saame tünaamilselt püütonnist luua uusi järekordasid ja me saame järekordadele defineerida, et mis suguste ruutimis võitmedega on, et me tahame sinna järekorda saada. Me saame püütonnist ise defineerida, loome exchangei, loome järekora ja siis loome reglid, kuidas näide järekora ja exchangei pahel andmed ruuditakse. Ja näid bindingud võib luua meie oma tarkvarat tünaamilselt reaal ajas, mis iganes ajal võib neid eemadada, võib neid lisada, et meie tarkvaram võimeline kotsustama selle ruutimis üle, et ei ole administraatoreid, kes ruutimist defineerib, vaid tarkvaravõib isene defineerida. Et kui me mk-tidis puhul pidim panema, et ma kuulan selle mustrig andmed, siis nüüd me võime defineerida, ma kuulan selle mustriga, selle mustriga, selle mustriga, selle mustriga andmed niimoodi, et ma tekitan järekorva ja panan selle järekorval paik, et mis exchangeist, mis andmed kohale juovad ja siis ma hakkan seda järekorda kuulama, et ma saan nagu tünaamilselt tarkvaratasemel selle teha. Ja siis ma võin publiseerida uusi sanumeid, siis ühendus salme näiteks delta exchangei ja siis ma võin resiiviga agata mingisugused järekordased kuulama ja võttaja järekordast järgmised sanumeid. Ja meil on ka erinevad exchangeitypid ja erinevad järekordate tüibid, et neid mustriid tegelikult on päris erinevad. Aga need on nagu sellist baas operatsioonid, mida ma pean tegema, et exchange peab kas eksisteerima või ma päen selle looma, järekord peab kas eksisteerima või ma päen selle looma ja kui järekorda loon, siis ma pean ka panema paik, et mis need routings regli teht, need bindingud on selle järekora jaoks. Sest muidu ühtegi andmed kohale jõua, seal on mõned agad, et teatud tüib järekordat on nagu defineeritud baas binding reglitega. Ja muste rongi, siis selline, et meil on mingisugud publisseerijad, kes saadavad andmed exchangei, meil on mingisugud konsüümerid, kes kuulavad andmed järekordadest ja keegi peab olema paikka pannud, kuidas need routimine toimub. Et kuidas siis exchangei vahel routiteks järekord 1 ja kuidas routiteks järekorda 2 ja selle jaoks on igal järekoral mingisugune hulk binding regleid, mis siis otsustab, et mis mustriga andmed liiguvad siia või siia. Ja neid bindingud võib tegelikult olla ka erine tüüpi, et ma võin rootida mitte ainult nagu rootimis võtme põhjal, aga ma võin rootida ka näiteks nende sõnumi heederväärtuste põhjal. Ma võin näiteks öelda, et mul on siin regel, mis rootib kõik teltandmed siia, aga ainult siis, kui filei või selle sõnumi suurus on suurem kui 10 MB. Ma võin ka sellised regleid teha nagu sõnumite metaandmed heederväärtuste põhjal samuti tekitada nagu sellised rootimis regleid. Mis natuke lihtsustab asi, et ma ei pea defineerima näiteks rootimis võtme see, nagu filei suurustu midegi sellist. Et ma ei pea kõike selle rootimis võtme siis ära peitma. Aga sõnumite marsrootimine toimus saa muudi, et meil on selline, me saame kasutada neid rootimis võtmed, et meil on tartu punkt delta punkt välisvalgustase või tartu punkt delta punkt korrus kolm punkt room 340 punkt temperatuur. Ma ei tea, miks ma siin on tartu, et ta pani nagast olla. Ja siis ma saan nagu defineerid, et ma soovin tartu delta korrus kolm kõikide kontori või kõikide ruumide temperatuuri kuulata, et ma saan tekida sellise bindingu, mis kuulab näiteks tartu delta exchange-i ja kõik sellise struktuuriga andmed siis suunab minu järekorda ja siis ma hakkasin seda järekorda kuulama. Ja samamoodi siis tärna on nagu üks sana ja trellid on siis kogu selline prefix. Trellid tavalselt vist väga pahele panna ei saa, et ta peab viimane väärtus olemat. Ja meil on mitu erinaat ühendustõlmede tüüpi, kolm peamist on selline, et meil on direkt, fan-out ja topic-stilis exchange-id. Topic-stilis exchange on põhimiselt sarja nagu MQTT, kus ma kasutan näid routing-key mustreid. Et kui ma tahan sellise mustreid kasutada, siis ma pean looma topic-stilis exchange-i. Ma saan kool uua direkt exchange-i. Direkt exchange-i mõtta on see, et kui mul on klient, mille nimi on Pelle, siis mis igalne asandmed tulevad routimise võtjaga Pelle saadadaks mulle. Ja see ongi kõik põhimiselt. Et seal, kui on järekord, mille nimi on Pelle, siis sinna järekorda Pelle saadadaks kõik anmed, mis tulevad routimise võtjaga Pelle. Et see on võib-olla natuke parem selgitus. Et kui ma loon, et klendi, mille klendi-i idea on Pelle, siis mulle luaks ka automaalt see järekord, mille nimi on Pelle. Ja tekitatakse binding, et direkt exchange-i, et kui direkt exchange-i saadatakse sõnum routimise võtjaga Pelle, siis see saadatakse järekorda Pelle, mida kuulab klient Pelle. Et see võimalatab saata otsa ja anmed klendidele näide klendi-ide põhjal. Ja sinna saab tekitada uusi kiusid ja uusi binding-ud juurde, aga see põhimiselt võimalatab saata otsa klendile anmed, kui sa tead tema ideed. Ja seal on siis speciaalne direkt tüüpi ühendustsõlmed. Ma saan siis sellest, et ühendustsõlme saata Pelle võitma kanmed, siis Pelle klents saab selle kätte. Ja fan-out on siis natuke speciaalne exchange, et ta põhimõtteliselt saadab anmed kõikides järekordades, mis sinna on tekitatud. Meil on fan-out exchange, sinna tekitan kolm järekorda, mis iganes anmed sinna järekorda saadatakse kõik lähed kõikides järekordades. Mis iganes anmed sinna exchange-i saadatakse, kõik saadatakse kõikides järekordades. Et see on speciaalne viis, kuidas ignoreerida ruutimis regled ja saata kõikile järekordadele kõik samad anmed. Et see võimaldeb repliceerida anmed kõikide järekordade vahel. Et see on kaks aesti lihtsalt mustrit, kuidas anmed kohale toimetada, kas klendi nime põhjal või siis kõikidele järekordadele, mis on loodud ja ignoreerida sellised ruutimis võitmeid üldse. Ja siis topik on, mis mokib natuke saama MQTTid, et ma saan siis võitme põhjal saata edasi. Ja MQP protokoll üks peamele, et implementatsiooni on, kus RapidMQs on vabavaralne, saate minna GitHub'i näha, kuidas on implementeeritud. Seel on palju selliseid plagineid olemas, näiteks MQTT jaoks, et RapidMQ saab otsa kasutada sama protokolliga, mis MQTT saab ajastada sõnumite kohale toimetada. Mis näiteks, sa ei taha sõnumite öösel kohale toimetada, sa paned paika, et sõnumite toimetataks kohale töö ajal näiteks. Et kui sul on mingil põhjas vahelik karanteerida, et mis ajal sõnumite kohale toimetatakse ja neid varem mitte kohale toimetada, sa võid ka defineerida, et sõnumite saadatakse mitte kuulajala või totse e-meeli. Et sa on selline huvita 50 saad e-meeli kohale toimetamist defineerida niimoodi, et sul ei pea olema mingi tarkkuna, mis kuulab sõnumeid ja saadab ise e-meele, vaid RapidMQ enda tasemel on rapid võimelne edastama sõnumite lihtsalt e-meeli. Ja seal on ka teisi blokina, et teiste selliste tüüpide jaoks. Või siis defineerida prioriteesed järjekorrad, et teatuda anmed nendes järjekorrades saadataks kohale enne ja mitte vastavalt saabumis järjekorrale, vaid teatud tüüpi, teatud heteri värtsu näiteks, kui heterkii prioriti võrdub 7 juhab kohale, siis tema saadataks enne, kui heterkii prioriti võrdub 2 näiteks. Lisaks on RapidMQ-d võimalik ülesseada klastrina, et me paname rapidi kolme serveri peale tööle niimoodi, et nad jagavad nagu anmed oma vahel ära. Tal on väga hea selline administreerimis liides, mida te praktikumis vaatate, et saate sellekasutajad luua, saate sellekas virtualseid, servereid luua, et näiteks igale rakendu selle oma virtuaalse rapidi oma rapidi sees. Ja on ka kasutajad aseme juurde pääse kontroolle, et saated defineerid, et sellel kasutajal on lubatud ligi peast sellesse exchangei, sellesse järekorda ja saada defineerid, et millele, mida siis kasutajad teha saab ja mida ei saa. Ja ta töötabks siin umbes niimoodi, et kui meil tekivad klendid, siis klendid loovad ühenuduse ja sinna tekivad nagu ühenuduse sellist kanalid, mille kaudu klend saab saada anmed. Kui klend saadab ühti exchange anmed, siis tekib klendi ja exchangei vahel nagu kanal. Kui klendil on kaks kanalid, kui klend saadab kahti exchange anmed, siis on kaks kanalid. Ja need kanalid on võimalik vaadata reaal ajas administreerimis liidesest ja ei seega need kinni panna, kui vajal läks. Aga põhimselt, kui saada kahti exchange anmed, siis käivad kolme kaks ühenudust ja anmed tuleb and exchangei. Ja kui meil on näiteks kolm klenti, kus või, püüta meil on kaks klenti, üks klent, kes kuulab kolmandast järjekorrast anmed. Ja siis meil on üks klent, kes kuulab näiteks kahest erinevast järjekorrast anmed, et siis ka tekivad, iga klendiaks tekivad sellised channelid ühenudused. Ja ruuti, mis reegljad kasutatakse, siis kuidas ruutida anmed järjekordada ja kiuuda vahel. Kui ma näiteks tahan, siis tekitada video töötluse sellise pipeline või video töötluse selline, et mul on klendid, kes saavad videosid saata üles. Ja meil on siis mingisugused hajus anmedöötluse komponeti, mis tegelevad videoöötlusega. Ja meil on siis anmebaas ja me ehitame nagu sellise vahevaran nende vahele, et nende peaks omavalu otsööhendama. Et me saame ehitada selle niimoodi, et klend saadab mingisuguse videoöötluse sõnumi, et mul oleks vaja video töödelda. Aga sellase, et back-end hakkakse iseneid videosid töötlema, siis back-end panev selle töötluse järjekorda. Siin on nüüd kaks võimalust, et tegelikult esimene võimalus ei ole hea. Ei ole panna hea videosisu järjekorda. Tavallest sa salvestad video sõnumi, et meil on kaks võimalust, et tegelikult esimene võimalus ei ole hea. Ei ole panna hea videosisu järjekorda. Tavallest sa salvestad video kuskil ära, et ta näiteks mingi block story, siis minna joos, või kuhugi salvestatud. Ja sa ei pane videot järjekorda, aga sa näiteks paned selle video asu koha järjekorda, et mis file oleks vaja töödelda. Ja sa defineerid järjekorras nagu videoöötluse sõnmused oleks vaja see video ära töödelda. Ja siis sa annad klendile tead, et video pandi töödlemis järjekorda. Ja siis meil on teime hajussüsteem komponent, kelle ülesanam siin videosid töödelda. Tema kuulab, kas on mulle uusi videoöötluse tööd, võtab selle vastu ja teeb selle töödeluse ära. Võib-olla tõmbab selle video alla kuskil teisest asukohast mingist videosalvestus asukohast näiteks Minna Jo või Amazoni CS3-s. Ja teeb see töötlemis ära ja siis saadab tagasi nagu sünnmuse, kiused nüüd või exchange-i, et nüüd on see videoöötluse ära tehtud. Ja samal ajal meie back-end võib-olla kuulab, kas on uusi videoöötlemise lõpetamise sõnumeid siis väljund järjekorras. Ja kui on, siis võib-olla kirjutab anmebaas, et video on töödelud ja video asub siin asukohas ja saab tagasi vastuse, et video on töödelud. Ja see on üks selline lihtne viis, kuidas me saame kasutada sellist vahe järjekordasid, et vahe, kui saadad vahe, vahendada neid suhtlust mingisuguse back-endi ja näiteks videoöötluse. Kus me ei pea panema, et back-end peab saadma otsa sõnumeid videoöötlusele ja videoöötluse ei pea nagu vastuvõtma sõnumeid, vaid töötab videosid ja siis kui videoöötluse lõpendis, võib-olla läheb ja vaatab, kas järjekorras on veel mingisuguse tegevusi teha veel mingisid videoöötlusi ja tihti, et ta kuulab ühte järjekorda ja saadab sest tulemused exchange-i mingisel teise ruutimise võtma, mis suunatakse mingisuguse väljundi järjekorda, kus saab kuulata, et kas videoöötluse on lõpend või mitte. Meil on näiteks mingisugune uue videoöötluse järjekord ja meil on lõpened videoöötlusti järjekord ja me saame neid kasutada selleks, et sellised asynkroonselt väljakutsuda mingisugust operatsioona. Ja siis ei pea meie back-end, polymame baasia võib-olla see video töötus ka ei pea polymame baasi, vaid lihtsalt kuuleb järjekord, et kas tal on mingisuguse uusi töid. Ja tavalsed seda nimetataks ka tööde järjekorra näed, meil on mingisuguse tööt, kas pildi töötlus, videoöötlus, mingisuguse arvutused ja me paneme näiteks 16 videoöötluse protsessi siis töötama ja paneme näiteks 16 videoöötluse protsessi töötama. Ja paneme nad kuulema sama järjekorda ja nad saavad neid videoöötluse operatsioonid oma vahel ära jagada. Ja see ongi tegelikult hästi lihtne või kõige lihtsam viis, kui täs paraliseerida arvutusi sellistas hajussusteemides, et panna tööd nagu ühti järjekorda ja siis lasta tööde tegiate lihtsalt kuulata selt järjekordas uusi töid ja jagada neid tööd nende vahel ära sellise vahevarat asemel, mitte nagu oleks mingi progamm, kes otsustab okkuma. Kelle andas ja kes peab selle töö käevitama? Ei ole sest orkestraerijad, kes ütleb, et sinu töö on see, sinu töö on see, vaid töötajad ise küsivad järjekords, kas mul on uut tööd või ole, kas mul on uut tööd või ole. Jäävad kuulama, kun uus sonum sinna kohal jõuab ja siis hakkavad seda tegema. Järgmises lainkus on näiteks tegev, et järjekorda on järjekorda, mis on tegev, mis on järjekorda. Järgmises laingus, paljem mulle aega meil on, räägime siis hajus suhtlusest edasi, räägime siis, kuidas protsesid saavad teiste ja protseside meetodeid välja kutsuda ülevõrgu. Kui meil on kaks protsesi, kes töötavad kahes erias arutus, et selle asemel, et nad omavals sõnumeid jagaks või kustile sõnumi järjekorda asja saaks, miks mitte võimaldada ne lihtsalt teises arutus oleva klassimeetodeid välja kutsuda? Üks protses kutsub välja teise, protsesi klassimeetode lihtsalt välja koodi sees. Koodi sees, protses 1 ütleb, et protses 2 käivita see metod ja ongi kõik meie hajusprogrammet. Programmid saad lihtsalt teiste protseside meetodeid välja kutsuda. Teine võimalus seda teha nagu hajusobjektid, tekitama hajusobjekti, mis on täpselt sama objekt, näiteks mingisugune matrix, aga see matrix ei asu meie arutis, asub teises arutis, aga ma saan selle matrixi mingisest operatsiooni välja kutsuda siin arutis ja see operatsioon tegelikult kutsutaks välja seal, kus see hajusobjekt tegelikult asub. Et on võimalik siis teha sellist hajusarvutusi või hajusüsteeme niimoodi, et meil on hajusobjektid, mida ma küll saan adresseerida sellest programmis, aga ta ei asu lokaalselt meie mälus või ta asub kuskil teises serveris teises mälus. Ja on võimalik nagu püütanis või teistes progameerimskeltes kasutavad sellist hajusobjekte või siis otsa teises programmis meetodeid välja kutsuda. Ja ülejärgmises loengus ma siis lähen webiapide rest ja subi juurt ja räägime webi teenustest ja teamesest räägime HTTP ja rest appist, HTTP protokollist ja rest appi sellise spetifikatsioonist või standardeist. Me etan kaks järgmisladi vahele, kuna nad räägivad pigem neid asjad üle, aga ma räägin ki, nendas siis järgmise loengu alguses. Ma mõtsin, et ma panen nad siia vahele, kui ma nad küle aeg jääb. Ja sellene järgmise sellene nädala praktikumist teete sellise hajussusteemi, kus te kasutate rapidMQ'd mitme komponentid vahelise suhtuse vahendamiseks. Ja me tekitame sellise püütanirakenduse, mis kasutab ühte piko teeki siis rapidMQ ka suhtlemiseks. Igal teil on oma rapidMQ server ülesseatud, mis on naljakalt niimoodi, et mul on üks hiigel suur server, kus on hästi palju rapidMQ kontainereid. Vaatame, kas see server elu jääb ja ei jää. Et see on natuke lihtsam mul teha, kui hakkata teile tegema alam selliseid virtuaalsed keskkondi sama rapidi sees, kui kui kas ei oleks võimalik. Eemil aasta see töötas 40, jätu utenki ka, vaatame, kas see aasta 60. aga saab hakkama, et ühes suuramas serveris 60 rapidMQ kontainerid. Esimene üleks on umbes selin, et me teeme ühe programmi, mis publiceerib IoT Unmade, näiteks IoT Device punkt, Jakovits punkt, TempSensor ja teine püütan program, mis siis kuulab Unmade järjekorrast ja tekitame tarkvaratasemelet bindingu, kus see tarkvara panab ise paik ka, et loomule järjekord nimega Jakovits, loosina binding, et kõik annemist tulad siia exchange, millel on mustere IoT Device punkt tärn punkt TempSensor, ma pole seda prosentikinde, kas on kõik õige, aga ja siis me oleme esimene programmi, mis lihtsalt saadab selle mustre kanmeets ja Jakovits exchange. Viimane üles, et teeme natuke midagi keerukamat, et meil on üks program, kes publiceerib sarnase temperatuuri Unmade, meil on üks program, mis kuulab need Unmade ja tekitab alarme, kui temperatuur on kõrgem kui 30°C, ja tähendis kontoris on 30 plus graadi temperatuuri ja kui on, siis ta tekitab uue alarmi uue mustriga ja saadab tagas exchangei, ja siis tekitame kolmanda programmi, kes nüüd kuulab ainult alarme, et teada saada, kas kuskil toas on liiga suur, liiga kõrge temperatuur, ja ma ei tea, mis ta jookseb sinna teha akna lahtu ja midagi. Põhimestel tekitame sest kolm programmi, üks, kes tekitab unmade, üks, kes kuulab alarme ja siis selline hajus rakendus, kes põhimestel kuulab unmade jootsustab, kuna on alarme ja kuna ei ole alarme ja kõik asutavad nagu sama exchangei ja saan me kuule, et ise tekitavad endale järjekorrad ja bindingud tünnaamiseks siis tarkorasees. Ja ma näitan teile ühe asja veel. Ma ei vist ole ikkinda, kas ma saan seda näidata, ma vist saan. Te saate oma rapidi leida üles korslas lähelt, et siin praktikumidi lähealt siia tekib üks selline tabel. Ma vaatan, kas ma saan sisse logida. Mina näen te kõiki kirjeid. Siia hakkavad hiljem ka need hinde tekima. Pärast selle nädalatähta, ega esimese praktikumi täht on, et siis see nädalat pärast nädalatähta hakkab meie õppaesisteneid hindama ja siis vaikselt hakkavad nad siia ilmuma, et see on istalt efektiisem kõik korraga hinata kui üksaval need hinata ja siis eksami hinde tuled siia ja siis see rapidi info on ka siin lõpus. Liselt see, et te peate skrollima sit paremalt, et seda reaalsalt ka näha, et muidu see ei ole sinna näha, et see tabel on väga lai. Ma ei tahnud seda ka ette panna, kuna see on ainult ühe praktikumi info. Ja eelmene aasta ma saad siin suulipi kaudu 40. adressi. See kord mõtsin, ma panendas lihtsalt see tabelisse kirja ja lihtne jagad seda infot. Ja siis proovitegi selle rapidi läbi. See on vist ainuke praks, kus me tegeleme iota anmed tege sellist asjadega. Järgmestest praktikumitse me jätkame selle raamatu kasvatuslooga ja kuni aine lõpunivist. Aga mulle ei õnestund parost tagasi välja mõelda hea tüljesanned, mis on seotud raamatut, aga siia praksini, et ma panin see asjade interneti anmed. Ja ongi siis kõik tänaseks tänan?