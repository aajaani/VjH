 Tänase teema sisuks on siis nanoteinusid, kus me harasamatest loandukes olemme räägit mikroteinustest ja erinele 15, kuidas me saame rakendusid ülesseada näiteks, kas manolympina või mikroteinustena. Tena vaatame, mis asjad on veen päiksematu mikroteinused estikilesele teematelubi nanoteinusteks, inglis peales pick and serverless või functionesa service. Estikilesele suhub ka neid tegelikult funktionid, teenustena või pilvefunktioonide nimekid. Räägime siis, mis on üldse nanoteinused, mis on nende platformid pilves ja implementatsioonid, kui soovit sagas vast ja ei tule teerideses oma keskkondades vabatakkuja, aga et ei sovi ennast lukustada pilveplatformidesse. Ja võtame siis loonikookunem pealist ja puudustega, et nende koht on väga palju viimasele ajal viimaste laste räägitud ja või keada mulle, et nanoteinuste hästi mugavad, skaleerivad ja odaamad, aga lihtsalt tuleb välja, et siit päris vimoodi ei ole. Nendele tuleb natuke alati ettevaatikolla, kui lukustate ennast nanoteinuste kasutamise peale liiga palju asja teavaks, siis võib palju kaljimata tegelikult. Ennast loonikookunem me räägime mikroteinuste, et tõeliselt näikud, et saame indistaks hapid jagada, et on väitsa mikroteinuste, kus osa hapid teinustast vägjad oma vahel, aga me võime ka sisse jäga pärinud hapid oma lära, et saame võib panna hapid peeperiks, siis kuhudid sisse paas pärinud erinele hapid mikroteinustele, maha, et millised mikroteinusteid on vastutavad seda tüutbi olemide halldamisees, et kontood või kellimused või maksev. Muidugi see maail on palju keerulisem, et saalt taga võib olla kõvasti rohkean mikroteinusteid tegelikult, mingi konkurenta amme paas ja halldamisega, ja need mikroteinuste võib oma vahel suhelda ja tihti pead kustu. Ma natuke nält peidaan seda tuumi asja seda. Me rääksime elmikult mikroteinuste elistest ja puudustest, et üks selline suurem puudus on see, et kui me hakkame suurt manuallised rakendust jagama väiksema tegideks, me tegelikult pihti peame rohkem, et susse kasutamus selleks, et meid ülev on hoida. Meil võib juhtustada osa mikroteinuseid, mis meil on loodud. Nii kasutada nii liht, et peaks tegelikult mingi mikroteinus igavast sooks määte, et meil on maksateinused ja maksed on juhtub 200 korda päevas. Eriti, kui meil on kuu maksed, et maksed ei tehta rohkem kui par 10, par 100 või par 1000 korda päevas. Meil on siis vaja üleval olnud na mindiskust konteinerid, mis tegeleb ainult ootamiseks, mis sisse tulevad mingi maksed. Me maksam näiks pilvesse selle konteineri oostamises ise, kui ta on hästi väike, sest võib juhtuda, et meil on mõned sellised teenust, mikroteinuste arkitektuuris, mis tegelikult ei piaks kogu aeg tööle jääba. Aga pilve platformides me maksame tavast iga sellest, et mindis mulle teenust on üleval, kas konteineris on võib ta oma asjad, me ootab, kui teile pärjelid tuleb, kui ise võltab järekorrast sõnumeid ja töötad neid ja me peame ikkagi maksam selle konteineri ooksumus aega eest. Ta võib-olla ei ole nii maksimum hind, et ta mingi väitikonteineri, et see ootab taustalt, aga ikka 24 tündi päevad maksam me selle. Ja kas meil on vajanud kogagi ooksumad isegi, kui sisel tandmeid ei ole, või saaks mingi, et see ei saa panhe. Nüüd on olemas lahendused, kuidas saab ka konteinerist jõtsad nuilis skaleerida. Kui per neete, siis on võimalik kasutada lahendusi, mis on nii-küks konteinerid, skaleerid nad nuilid. Ja siis, kui sulleks kusse, näed, et saapi keihu põisseb pärin, mida peab siia suunama ja selle suunamise pärin, siis see tulemusena skaleerid seda nagu tagasi nuilid ühele enne, kui kõikest pärin peale suunatakse. Näed, et need on G-ta ja G-neidid, kui per neetes sellised skaleerimis rakkembiselt võimalik, kui sa� pole on tegeval力 ta lenni Wing Rel, nii꾸你是 mink cabe tegeval l 소l Looney Balls. Juhu tead seda, et olime tervaks, hunting laisadab leo-otto Burger King koh haarajui, että te busesin seda poolぎ notification. ja aheadte seda aastap qui address Tram!!!! Sa ei mingi kohe need, kui skate viis on. päringust ja teenuust sees kaardistatakse, et kui tuleb siis see teatud tüübi päring, mis sugun püütani funktsioon, mis sugun jaava funktsioon käivitada ja see püütani või aava funktsioon ei pea olema kogu küleval. Selle asemel meil võib olla see timelik, külisnav funktsioon, mida käivitatakse ja käivitavad ainult siis, kui tegelikult tuleb siis see mingisugune päring, mis nõuab, et seda funktsiooni käivid. Ja sellest kasvuski sääli ja selline function as a service või funktsioonid pilve funktsioonit teenusena, olid te kindlalt kuulnud näid Amazon Lambast, Amazon pilves, et see on või see on sama mursta, et me ei jooksulta või hoia taustal jooks, vahe mingisugust funktsioon, mida me tahan, et käivitatakse. Me olidime, et meil on mingi raamistik, et see ostad, et funktsioon on väljakutsud siis vaja. Ja me saame nagu mõnesmates neid samu resursse ära kasutada, et meil on veel mingi konteeenerid, mis jooksevad, aga nemad on võib-olla vastutavadse erinevata funktsioonid jooksutavusevada. Ja see ongi võibas enne senditus, et kuidas mikro teenustest kasvat välja sellised väiksemad konteeenerid, mis väiksemad teenused, mis ei koko aegi jookse, või need käivitada allaks siis, kui neid vaja lähe. Ja need ongi sellised nanoteenused. Ja selle tõttuk nimetadakse mõnigult neid ka serverlessiks, mis ei ole mõige parem niisest. Taustal teavad olema serveri, aga see idee on see, et meie rakendus või meie funktsioon ei jookse taustal kogu aeg mingis serveris, või teda käivitatse ainult siis, kui see vaja on. Sellest tulik üle väljas, funksioonise service või serverless natuke halb kirjalduse mõelda serveri vabad rakendused või teenused, sest reaalselt servered on vaja, aga nendele ei alokeerita pidevalt taustal olevat serverid ja me ei maksa aja eestmida või meie funktsioon, mida midagi ei teed. Serverless funktsioonid või nanofunktsioonid on oma vahel sõltumatud, et nad on täiesti eraldiskaleeritavad, halvatavad, hinastatavad ja iga funktsioon võib olla eriliseks keeles, nii et nad jälgivad sellest sammast mikroviimaste mustrit, et neid saab täiesti eralduja arendedat, me võime mõned kirjutada kookeeles, mõned kirjutada lukikkeeles, mõned kirjutada kõitonkeeles ja ta on mõnesed loogini jätk mikro teinostud väiksematis minemiseks, et kui me teeme näiteks raamatute halvus appid, siis meil sama pyytoni rakenduses ees on et skettpärind, postpärind, selitpärind võib olla mikro teinostu maailmas me saaksime näid teha kolme erina funktsioonina, et meil ongi iga endpoint metod jaoks eraldu funktsioon ja me rekistreeerime need funktsioonid pilves ja defineerime, et kuna need funktsioone pealt käilitama. Ja idee ongi, et meil neid mikro teinostud ei oksa taustal pideval, nad ei ole kustis virtuaalmasinees võib konteineris kogu aeg siselt ei kuulamas, vaid nad käilitakse alle, et siistu sissepullad mingisugune sümmus, mis paneg selle funktsioonitööle, mis paneg mingi raamistiga selle funktsiooni välja kutsuma. Ja selleks pärin nagu elis on see, et me enam ei pea maksma aidil ajal. Et kuultakööta ette taaksute ülespanna mingisuguse rakenduse, mis kuulab, kas Amazoni file-i sistemi panneks üles mingi file ja kui see file on suurenku 1 gigabyte, siis palun käiviteki minu.jom, mis konverteerib seda palju täistama. Aga need ühe gigabyteidseid file-i võib-olla tegi päris ükskord päeva. Et mida te siis teete, kes te panad üles virtuaalmasinees, selleks et kuulata järgstu päevas ükskord tuleb üks sündmus ja ma siis päevitan selleks, et miks ma peaks raistamada seda virtuaalmasina aeg ja selleks, et oodate, et võib-olla tuleb mingisugun üks ästisumur file-i, nagu konverteerimaastas. Võib ma peaksin selle funktsioonalasuse sisse eitama oma mingis ja teise veepit teenuse rakenduse, mis ningu nii kogu aeg jooksad. Seda saaks teha, aga siin menelega tagas, siis monolistise maailma, et me hakkame lisafunktioonaalsest panema loogukasse, mikro-teenustesse, mis ei ole mõeldud sellest hoolitsevist. Ja need pilvapaksoonid võimalda, võib-olla siis hästi harva juhtuvad asju automatiseerida niimoodi, et ma ei pea neid taustal jooksma jätma. Et see on nagu see, et kaaptas kõige parin või kõike sopivam kasutus viis nano-teenustele, midagi mis ei pea kogu aeg jooksma. Väga palju näete näiteid veebis, kus kirjatakse, et kuidas micro-teenuseid või nano-teenuste katutad asjate aegs, mis on tavasad appid, mis koko aeg jooksevad, mis kohad midagi töötlevad. Ja ausalt üldes, need ei ole kõige paremad kasutuslood, sest kui te nii kui nii pead midagi koko aeg jooksma ja te ei olegi sellest haidel aega, siis tõenast micro-teenustele või need nano-teenuseid servelest funktionid näed palju väljumast. See on sopiv, et see staatuse karaksjegust jaoks, mis me ei pea midagi mängu, et üldeselt nad lõiksid väga lõidist aega töötavad. Ei ole hea, mingi västi pikkid video töötusrakendid nende avid teha, aga võib olla ka okei, kui see toimub näiteks paakorda päevas ja töötavad mingi minuutid või pari minuutid või 10 minuutid, et siis on okei. Ja näid siseliselt skaaleeriteks automaatselt, võrraldes micro-teenuste või virtuaalmaselete puhul, et kasutused tavalselt isegi ei pea midagi konfigureerimata ja skaaleeritaks. Ne skaaleerim natuke sisse eitadud enda see pilve ja funktionidesse ja tavalselt, mida te saate teha, on panna maksimum limikid, et te ei taha, et teie funktioni skaaleeritaks hopkem kõmme koopjat, mis saada töötavad. Lihtsalt see, et see liiga kaileks ei lähed, et saada limiid panna. Ja võimalt ongi selline väike visuatsioonet, kui mulle monolidist rakendisest, mis meil on mootulik põe rakenduse, see on ikka teed, et me jagame nad väitsevateks mootulik, et sa ka nad ikkagi jälgivad ja sama moose struktuuris, mis oleks olnud, aga nüüd nad on eraldi kontenerist ja see kooksad eraldi prozessi, et me jalgame nad väitsemaks funktionidest, kui te teed, et teed on iga kõrkna funktion appis, või et saaksime individuaalselt funktion registreerida, kui teenustena nad on ise oma keskkonnas, oma eraldähtud sellestis. Mini-containers, nano-containers, kust platformid autnud, tocker või kuperneetees või isiga. Et me jagame siis oma suurda näed mobiiliselt mootuliks, palju väitsevateks sellesteks funktionist ühtiselt. Ja tegivad samas probleem, et mit Mikro teenusta puhul, et uidelik funktionid peavad oma suhtama, sa peavad suhtama üle lokaalse kõrgu ja see võib tähedada, et kui me siin oleks võib-olla suurselt väikar väljakutsa, siis kui ma teame väiksemalik funktionel väljakutsamise, et näid individuaalselt teenusest, mida väljakutsutakse, siis lokaalse kõrgus näiteks kontenerita vahele, on kõvasti rohkem. Aga see olenne, et kui me jagame, kui me on appi ja ütleb, et neid on kõik nagu appi endpoindid, iga üks on eritud eraldu Mikro teenudas, et siis on kiinu see siis appi funktioni, kui me nad eraldi lieks appi funktionid saavu jagam, et kui siin appi funktion on eraldi kontenerist, otseselt see ei kruugi nagu lisaniiklus tekitada, sest võib-olla liiklus läks iga viie appi funktioni ja siia rüdev piide endasi kontenerist, et kui neid liiklus toimub välis, teg lendud ja appi funktionide vaalad, siis võib-olla see on väga palju epaeg, et niisemüüa. Ja ta ongi selline ajas väitsemaks mine selline arkitektuur, et meil jääres väitse vähem tüpt, et kui enna liib nagu hulb kontenerid, siis tõenas, et kui me prooveksime kogu Mikro teenuste rakenduse teha, et selle on tegud selle, et meil tegaksin veel rohkem kontenerid, veel rohkem väitsemaid teenuseid, mis jooksad kusagil tilves ja nende arkitektuurialdemid läheb misjagi keerulisemaks, sest meil peame nüüd hooma, mis toimub, mitte annud Mikro teenuste pahelvaid, mis toimub ka kuskil sünnmustes, et kui sisse tuleb nagu sünnmuste stream, ja iga sünnmuse erino tüübi jaoks on eraldi funksioon, siis tegelikult sellist rakendust ja hoomamine, mis on näitud servilevse funksioonide peal on päris keeruliselt pinna, keerulisemaks kui kontenerid ka pooru või Mikro teenuste puh. Mida tähendab sünnmuste põine käitused? Üldjuul me defineerime mingisuguse triggeri või päästiku, et kui sisse tuleb uus fail Amazon S3, kui Annenbassi tabelliselt tegi buuskirje, kui Annenbassi tabelliselt kasutajakirjat muudatud, kui keegi muudab faili, kui sisse tuleb uus sõnum järjekorda, kui poimselt üks sünnmuste, mis muudab mingit Annaid pilves, Annenbassis töödab teadati järjekorras, et me saame neid kasutada seiste päästikutlana, et toimus uus sünnmus lisaks sellele, et võib-pall, et kui fail on suurem kui 10 MB, siis me saame piste defineerida sellised e-singimused, et käivitame siis funktsiooni ainult siis, kui mingisuguse parametra on suurem kui mingi väärtus, kui logikirjes on temperatuur suurem kui 70°C. Ja siis on mingisuguse tegevuse, et funktsiooni väljakutsumene, siis näid on, et kui meil on uus fail laadid üles s3, on siis pärastik, keelt ingimus on faili suurem kui 10 MB, ja tegevuse on siis mingi püütunni funktsiooni väljakutsa, et vähend te pildi fail väiksemaset kui 10 MB suurem, siis kirutusid pildi fail üle väiksema pildi suurusega, et me vähendame resoluatsiooni, et me ei pea nii suurem resoluatsiooniga pitte hoidma. Või siis tekitada väiksema resoluatsiooniga fail asemel, aga siis monna suurem fail akhiweeril ja küski oda oma selle storid siis vähe palles, aga me ei maksa selle sinna palju. Ja nanofunktsioonid siis defineerivad sellised, mis on pärastik, mis on e-singimused, mis on tegevused, ja tegevuseid meil pole teerina mingisubes koodiga, et püütun funksioon, JavaScript funksioon, K funksioon, Ruby funksioon innsid ajast. Ja Amazon Lambda ei saa muodu, et kui meil kamera teab foto, meil on aktiveeritud automaatne foto synchroniseerimine pilve storidgisse, ja meile saame defineerivad, et Lambda funksioon kävitab, siis kui meil problemi on saadusti liigasuri pilted, me ei taha liiga palju makstani, et me saame automaatselt teha nüüd pilti väiksemaks. Ja siis see töötab hästi, siis kui meil pilted tekiv suurselt harva, kui meil pilted tekiv piisavalt, näiteks meil kasutat arvan liiga suur, siis meil oleks võib-pall parem mingisugune virtuaalmasini vaj mingisugune konteiner panna kogal peoksma neid piltekuulama selle asemel, et Lambda funksioone kävitab. Miks see on? Nii ma tulema tatke tagasi hinastamise model juures, et see maks mene kui läste maksate konteineri, versus funksioonide väljakutsete, on hästi hästi erinev, ja seal kui sa välja tuleb, et kunada kõige mukaavam, võib kunada kõige odaama kasutaja või mitte. Ja sündmused võib-a-t kõik midagi pilves, mis tekitab mingisugud logikirje kuski pilve teenuses, et alati on mingisugud limitatsioonid, et mis Lambda toetab sündmustena, mis Azure Functions toetab sündmustena, mis Google Functions toetab sündmustena, ja eriti kui te ise tekitate oma vabavaralise nano-tenuste plakformeid, siis on ka tavas limiteeritused midade saates sündmustena kasutada, aga neid ma juba teid näited, et näed, et see on uus fail, kuski pilved teed, see on uus annapaks kirje, temperatuurivärkis on kõrgemugu 100 kradi kuski, mis sisse tuleb jätete erekorda sõnumisees, uus kirjisaapus sõnumisees, erekorda uusi imeelturi kohale, või uus hatete peab pärin saapus, et tegime, tegimegi appi rakenduse põhjumist ta funksioonide pohjal, et me saame defineerid, et iga, haad, et tegime pärin ka on sündmust. Nel tõngimised me juba siis tavalselt olla kas sellan sündmuse meta annade pojal, et see on faili suurus, või teadud olukordat, et teadud sündmuste pool ka faili sisse võid näed, et meil on JSON, me juba defineerid, et JSON ei seeest olema mingusugune võitme, et te, mingusugune, point temperature on suuremne 80 m. Ja see ajalme siis väitida, et me peaame funksiooni käivitama iga sisse tuleva sõnume peal, ja sega täendab, et me ei pea olema loogika kusakul meie konteineris, mis kuulab kõikis sündmuse ja otsustab, kas käivitavad mingis funksioonia või mitte, vaid me põhimõtteliselt paneme selle vastutuse pilve teemist pakkujal kontrolli kontrollid, mis on objekti sisu ja alles siis käivitab meie funktioni ja meie maksame tegelt ainult käivitamiseks, et me ei pea maksma nagu selle kontrollie eest, kas midagi käivitada on itte. Ja see on üks osa, mille tõttusele võib-olla oda on, kui konteineris kõikides ünmuste kuulamine ja funktionite käivitamine, kui me saame vältida meie koodi kasutamist siis, kui tegad seda vajal ei ole. Ja tegevus on siis reaalne funktioni, mingis keskkonas ja mingis progameerimis keelega näiteks püütaniseb. Et luomame siis mingisus püütanfunktsiooni, et praktikumis me loomem püütanfunktsiooni, mis võtab sest teksti faili ja projekteerib selle BDEFiks. Et see on midagi sellist, midagi me peame pilves registreerima ja peame seda koodi looma, aga see on midagi sellist, mis vähemalt loogiliselt ei pea taustal pidevad töötama. Seal on üld suur, aga pilvet jäänustab pakku ja võita jätta jooksma, et see on põibst teeme otsustada, kas ta jätab selle taustal jooksma vii mitte. Et see on implementatsiooni küsimus, kas ta jooksab vii mitte, aga peame meie aks tähtmes, et me ei maksa sellest, kui taustal jookseb, et me ei enam ei maksa konteineritunni jooksimiseest või mitu minuutid konteineri jookseb. Nanoteinuste platform käibitab selle funksiooni, mida meie selle funksioonateerime, et siis, kui tuleb sisse sündmus, mille parametrit on korrekt, vastavad meie e-tinkimusele. Ja kui seda sündmus ei teki, siis meie koodi jookse ja meie selle koodi jookse peab teha maksaa. Siin on näide IBM funksioonid, IBM-pillas, IBM-funktsioonid teinustest, kus me saame, et defineerite sellese API-rakenduse, et meil on näiteks üks funksioon, mis on lihtsalt see, et ta näiteb HTML-vormi. Me teeme sellest püüttan funksioonid ja defineerime, et tema peaks välja printuma sellise HTML-leegine ja defineerime, et kui sisse tuleb kettspäeem meie adressile, siis käividelik see funksioon, mis printit välja HTML-li ja HTML-li siis see on vorm ja see vorm viitab välja teisele funksioonid, et sa post-typikid pärinud samale adressi pohjumad. Me defineerime ühe funksiooni selleks, mis kui tõb kettspäeengid näidata vormi ja teisele funksioonid, kui vormil vajutud, et saab midt tukkud sellisel vormil, kus meil on kajutaline nii nii sõnu, et send message saab midt tukk, et siis käiviselt see teine selveliks funksioon. Ja see on selline tüüpine viis, kudas proovida modeleerida nagu hot-dev appid võibilehte võimestse funksioonide. Ja siis meil on see teine funksioon, mis kuulab nüüd, kas keel ei saa et mis on selle visasõnumiselle message vormi kaudu. Ja siis see funksioon on teine pültal funksioon, mis põhimõttel võtab selle sisendi vormist, kus on message ja user, defineerib JSON ja paned JSON-annebasi selle kirje. Ja siis meil on üks funksioon, mis hot-emaili printi pärile, teine funksioon, mis võtab hot-emailist sisestel annmed ja paned JSON dokumentin annebasi, kus on kasutatud. See on kohoda annebasi, ta on siis couch-td põlin annebasi. Kaudat on sellep ütlemene commercial nimi ja IBM pilvas, aga sisemised on tovist couch-td vabatakka, mis IBM pilvas johtsut. Ja idean on, et ees arenda aina saab te minna ja pilve brousseris põhimõttel sellist asja programeerida, programeerida kirjat mingu funksioonid ja defineerida, et kuna neid funksioone käividad, et mis on siis trigger mingi suge siin selles olukorras on ta posttäreend tüutti, atte päril teatud adressile, saalt defineerida, mis on erineid parametrit, mis on randan, et mis suge sest küütun keskkonasta jooksama peaks ja mis on rengpoint, et kogu peab saab saab ma selle hard drive pärin, kui siin on send point näha, kui kui sa tead, et näeks nõigatud selle function's app domain cloud app version 1 webis funksioonid nimi ja veste paraustil. Ta on see, et põhimõtteliselt kiire viiskule prototypide või kirustada funksioone, sest rousseris ilmaate peaks, et te funksiooni keskkonda isel olma, või meie praktikumis loome selle keskkona oma arvutis või inuks vertaalmasseks. Ja need endpointid näevab välja sellised, et see on siis meie funksiooni selle app, et näiteks cloud funksioonid app domain cloud app web, jakovits, app.ut.de, dev keskkond, siis pelleform on selle funksiooni nimi, ta nagu minu keskkona sisemine funksioon pelleform ja saab defineerida, et täst avalid funksioon, et ta ei nõua mingist autentimist või ka siis on äna autentitud funksioon, et see on selle funksioon, et auavab appi vegid. Mina tegid avalikuks, et nagu inimesed saaksid minu webi vormis, siis sõnumeid saada ilma, et minu rakendes täks põldi appi vegid halda maha. Funksiooni implementatsioon on palju. Kuulite kettesuha, leist suurevat pilvi, pilv, teresta pakku, et pange otsa funksioon, sõl Azure funksioons, Google funksioons. Amazonis on tähinna Amazon Lambda, mitte Amazon Functions, aga on ka avatud platformi, nagu Open Lambda, mis on põhimselt nagu community, kui implementatsioon Amazon Lambda on, et saaks Amazon Lambda appid kasutaga oma serverite puhule, mis saab Amazon Lambda klooni panna üles, siis oma serverite, siis oma Open Lambda on avatud. IBM kasutab Apache Open List, mis on sammulti vabatargvara, aga nemad kasutab IBM funksioonid implementatsioonina, aga saab teise oma serveride panne open listi põhle. Red Hat funksioons jõuk on ka vist open fahas üks sellest avatud arkvara, mida saab oma serveridele peale üles jääda. Nano teenuste näilde, et kui meil on loodud raamatud halduse tarkvara, siis meil on erinevad appi funksioonid, kudas kasutad saavad, et raamatud üht alla tõmbata, raamatud lua, me saaksime teoreetilisevst lua fahas funksioonid iga ühtel metod jaoks, kus me välja kutsutakse mindiskuse REST endpointi metodi peale. Tiktud näiteks raamatude nimekriapunktiooni, raamatude kustutamise funktooni, raamatude vaatumise funktooni, raamatude vatsimise funktooni, raamatude loomise funktooni. Aga see läheb natuke mõtetuks, sest olukorras, kus meil tegelikult on vajadus serverida palju klientte, võib meil juhtuda, et meil kogu aeg meid appi mängadad, et kutsutakse välja. Ja kui meil ei tegi seda olukord, et sa on ajut või harva juhtuvad sõmmused, et siis väga ei ole mõteta, kui appid primodid esainida, et olukorras, kus kasutad ei ole, siis sellest, et kasu olla saab suhtsalt odavald implementeeridesese appi. Aga sellene hetk, et ju sa saab kasutama asjad, siis sa tekivad probleenid, et sa ei või liiga kaelliks maksamani. Ja igale funktoonile me saaksime tekituda sellise päeval, et meil on Vest Pellaraamatu Traktsjäännüse, Azure Web-side net, appi-essise raamatud ja sellegu see on tüütbiline appi-aadres, aga me defineerime unikaalse aadres igale funktoonine, igat funktoonisab eraldi nagu pilve funktoonine, pilve funktoonime implementeeride omas nagu keskkonnas. Aga saab kõik ostada appi värav, aga ei need teha nad käette saadavaks nagu ühe aadres sina. Kõik mõnesed onki see Pellaraamalute Azure Web-side net ongi maju suurksse naapi värav. Paatame ka nüüd, kuidas näide makstakse, kui me hakkame need kasutama, et näide saamas on lambdas, saab kävitada koodi ilma nagu infrastruktuuriläis panemis, et saate defineerida, mis on see kõutane ja heaadas grip funktoon, et see on klasikane nano-teenuste platform. Aga me enam ei maksa see jooksumus ajast, kui konteinere puul me ei maksma kõik tuundide jooksev, kui minuutide jooksev isegi sekundest, siis funktoonide puul me maksame käilitus ajast. Põhjimadselt ainult selle ajast, mis funktoon kulutab, et jooks, et kui panaks sa mingi protsas tööle kuski kestanas tavast konteinerist, et siikse kauas selle funktoon reaalselt jooks, ja seda mõõdik, et see millisekundides, seal võib olla mindisvõi nii minimum vaeg, et minimum maksimisev pikkus on 10 millisekondi kohta. Aga te ei maksa ainult selle ajast, te maksate aja korda siis mänuala peerimiseks. Et on sellised meetrikad kasutuses monitoriusi nagu gigabyte sekundid, et viitu gigabytei mälu oli alokeeritud korda, mitu sekundida jooksev. Reaalselt on ta muidugi jooksev millisekundid tegema. Teadud pilvedes nagu Alibaba-aifi pilv ja siis Google pilvesti peate ka tegelikult CPU aajaajast maksma, et siis ta on CPU kordasekund ja plus gigabyte kordasekund, aga tavaliselt pilveliselt ainult gigabyte korda tekka. See on selled üttu, et kui tead on funktion, mis töötab mingisugud väiksemaid anmeid, siis ta tahab väiksemat keskkonda ja kui te kasutab ainult 200 megabyte mälu, te maksate vähem, kui te jookseb sama kaua aega, kui te kallutad, kasutab 2 gigabyte mälu. Ja ta on o-o. Naga lineaarselt see sõltub nii, et te maksate põhimõttel, et kolm korda rohkem kui te kasutab kolm korda rohkem mälu. Kihki saab ka tasutada päringud, et igas platformist avalast saab umbes 1 või rohkem miljon päringed kuus, et te saate teha nagu oma funktionid panna üles, igas kuus valg ka kasutada seda funktion teelust, kui ta ei tasutada kui te kasutad rohkem kui 1 miljon päringed kuus. Pärast seda on see taks, et on maksma umbes 20 cent iga miljoni päringu kohta, iga miljoni väljakutse kohta. Need hidaat eril, nad erineetat platformidel lisaks, et te maksate päringu kohtete, te maksate päringu nagu jooksebu sajakoht, et te saab te tasutada 400 000 gigabyte sekund. Ja et kui teie funktionid kokkuvaada kuus, vähem kui 400 000 gigabyte sekundid, siis te sellest ei maksa. Et see näide on, et kui funktioni alokeerid 0,5 gigabyte, 500 megabyte, te jookseb 100 millisekundid, mis järeikult teidada talita, et teil siis 5% ühes gigabyte sekund. Aga peale seda maksate siis 0,007 dollarid Amazonis iga 1 gigabyte sekundi kohta. Et see arvutus enam ei ole selle põhjale, et kui mitu minutid või mitu sekundid või mitu tundine, et funktionid jooksevad kokku, aga nüüd peab ta nagu hakkama. No ei tegega, et te läheb peate korjutama nagu see on mõelo alokeerimisega. Enam te ei tea, et mul on virtuaal maasini jookset tundi aeg ja maks on nii palju, aga nüüd teid võib-al see tundi aeg teie rakendist kasutatakse, aga see tasu sõudub täiesti sellest, kui kaua teie funktion jooksevad ja kui palju kasutad on. Et kui kasutad on 10x rohkem, maksate 10x rohkem. Kui funktion on 10x aeglasem, et maksate 10x rohkem. Et kui teie k-funktsioon, ütleb teie püütalfunktsioon, võtab 100 milisekvõid, et teha kõik tehtudusrakenduse ära sistem ja homme te designete ümber näites k-rakendusena, mis võtab 10x vähem aega, siis te teate ka homme 10x vähem maks. See ka motiveerid tegelikult inimesi, vägutavad natuke optimeerima, et palju aega võtab. Lambas näib umbes sama välja, nagu IBMis, et te saate funktsioonid kirjutada otsi browseris. Te ei tee neist browserist kirjutama, te saate oma development keskonnast kirjutse ja lise funktsiooni ülets laadida, aga protosipimise mõttes on päris mugav, et saate testida ja funktsioone proovida otsi keskonnast. Ja teil on erina tõerist, et juureks kudest saad testida. Testimisaal tada saate panama, mis on see sõmuse metaanmed ja näites pildi paani sisu. Mõnikad on natuke tüütust, ta niimoodi testida, kui teate browseris defineerima ka, mis on see pildi sisu, mis pandi kusple annuva. Eerina tõeristatunud see juureks. Ja te saate defineerida sellise appi gateway, mis võimadsalt võtab vastu, näiteks hardtetete pärimku. Ja see appi gateway automatiselt konverteerid sellise hardtetete pärimku info metaanmed ja kaasa pandud data podi objekti jationiks ja teie funktsioon Amazonis alati saab siselik jation. Või enam ei saa siseltik nagu hardtetete headerid, hardtetete podid, vaid ta saab siseltik sellise teatustruktuurist jationi, kus see hardtetete pärimkust kaasas olev infoon sellise jationi alam võitmõttes kirjaga. Ja see on sellise tüpigine, nagu Amazon jationi, lambda funktsioonid alati tegele jation siselik jation väljandiga, aga kui teie tahad, et sünnmus, hardtetete pärimku asemel, xml dokumenti või midagi muud, siis tabast on, kui kas AQHL, kes selle ümber konverteerib, või teatud tüpis sünnmuse, kui on näiteks Anne paasis kirja, muudeti siis kasi konverteerib, sest sünnmus konverteerib jationiks, ja Amazon lambda saab teha stevis jasoni, mis sisängiks. Ja Appi Gateway saab ka teha erilad asjad näiteks, saab automaalsed konverteerida ketrakööste jationiks, ja siis jason teie funktsiooni jationi vastust saab näiteks automaalsed xmliks ümber konverteerida, Appi Gateway on sellist furgital teelus, et sinna saab sisseheetada sellise formaatide transformimist, et teetev funtsioonimis oska mainis jationist sissevõtta väljas, väljastada, aga teile on vajalik, et kasutada ketpärimkutene, et tegelikult väljastab xml dokumenti, või siis isegi näiteks midagi teatud steemis, hdml lehtvõm või muud, et Appi Gateway tasemel on amasomis võimalik, siis konverteerida mingisoks te rakenduste või funktsioonide sisjendid ja väljandud teistest formaatisse vaja. Ja teil on selle, kui konfigureerita, et kuidas siin oleb sellile string, et response ümber kongeliteerist xmliks, et panna tale mingist tagid ümber ja liigutada, no, põimsalt õiges formaatis dokumentistruktur vandite. Mõnikord on huvitav võib-lumalesena. Neid nanoteenused on võimalik kasutada ka sellise loogika workflowtena. Kui te käetete soovite luua mingistlus rakenduse, mis käivistateks siis, kui tuleb sisse uus kasutapäringed, näites kasutasoovi posta mingistlus toode. Ja see ei pärast otsustama talle, kuid palju lainad on anda näiteks. Ma saaksin teha lainarakenduse, panna seda virtuaalmasinast tööle, pannada tööle nagu konteeleerina luuaste jäävaast või pyytonis ja teha appi, et ma saan pilvast välja kutsuta, et kui sisse on päring, et tegis oed laina, et mis on see mikro teenus, mis uurib, kui seda lainad tähtiselt käelta. Aga on võimalik teha mitte ainult üks funktion, aga on võimalik teha ta funktionide selline jada või selline state machine või mõtsedu. Kui sisse tuleb päring käelita see funktion, aga pärast seda funktioni vastavad funktioni väljontüütle, tekitame nagu sellised loogilised otsuse, et kui if else stiilis või jüklide stiilis, on võimalik programmeerida pilvest täiesti pilvetõhine selline loogika state machine, mis teed teadud tegevase läbi. Selleks on Amazonist disaaniitud app functions või Amazon step functions teenus, kus on võimalik otsuseid programmeerida väljas panagi koodi pilve teenustana. See on natuke nalakas, aga võimalikselt meil on võimalik tegida teha AVST functionide selline loogilise teenuse, mis kontrollivad, kui näiteks üldse on võimalik ostamida, ketk on projekte sanda ka, et see on kirja, et praegu on näite objektide, mis oledes osta, ole rohkem kui nüüd. Siis on teel, mis proovib, et on võite, et nasastal raha pillida läbi krediitkaardi ammeta, mis on kasutakohta sallestatud. Nii kaua, kui ei ole võimalik teha, panaks objekti või sedeljumus omatele ja kui lõpuks ole võimalik roha kätte saada, siis minnaks elastud protsist, mis saada välja toorti, mida kasutaja ostab kasutasoi kosta. Muidugi me tekiteksime mikrotenuseb nende jaoks, mis oma suhtlevad, aga amas olis meil on võimalik teha sellised asja väljasponnud mikrotenuseb osaliselt funktionekasutades, aga osaliselt isegi ilma meie koodi kasutamata. On võimalik defineerida sellised, korraks me ei näed, edasi, sellised workflowed, kus meil on mingisugune sõnmus, mis alustab workflowed ja workflow lopput, et panaks saa kõik asjad kõik kinniga. Ja meil siin see on võimalik kasutada lambda funksioone, aga on võimalik kasutada lambda funksioonist väljas pole kisteerivad juba olemas olevad loogilsi workflowed samme. Näiteks me saame kasutada kontrolle, kas sisse tulevas sõnumis kasutahini on midagi või kasutaja, mingisugune mehta anneda mireg muud. Et siin on üks näide, et me saame teha sisse tulevas sõnmuse peal käib kõigeva lambda funksiooni, mis kontrollid näiteks, kas kasutaja anned on korrekt, sest kas selle kasutajaks sisteerivanne panist. Meil on võimalik selle kontrolli jäljel otsustada, et kui see kontroll on korrekte, siis minna siia teese, kui see kontroll ei ole korrekte, siis minna siia. Me saame kehitada pilve tasemel sellised work flowsid, kus see esimene kontroll on lambda funksioon, teine kontroll on Amazon Step funksioonida loogika ja siis panna siia selline eksisteeni plot, mis paned dokumenti, mis valiteerik kaasa tulid jäistu dokumenti, taelame tibia annemasa, ja saada viimeilid ja siis välja väljub. Ja kui selle kontroll ei ole korrekt, me siis saadame sns sanumid puugi, et viimeilime ei õnestu näite saada ja siis väljume sellest kontrollist, et kuna kasutaja annepaad, siis viimeil ei ole, siis me ei õnestu viimeil saada, et me tekitame uue sünguse ja kui kasutale on viimeil ja tema info on korrekt, siis me paneme annepaadis selle info ja saadame viimeil kasutale. Ja mis on sinu uvitav, et ainult esimene lampefunksioon üleajateiselt on loogiliselt samud, mis toimuvad Amazoni sees ja see ei maksa meile mitte midagi. Selline kontroll, et me jooksutame seda kontrolli, sellest me ei maksa, me maksame näite sellest, et me tainamust hoiame rotke mandreid, me maksame selle lampefunksioone kävitamisees ja meie võib-olla maksame viimeilis saadmisees, aga me saame niimoodi automatiseerida tegevusi pilves, et kui sisse tuleb mingis ümlus, mida selle sünguse pohta teha, et ilma, et me pääksime pea aegad tarkvarra ehitama, et kõik need asjad on parasamaa presteerilad, tarkvarra blockid me saame siis väljakutsuda ja võib-olla teatud asjad on kasutamistidis inkrementeerima, pyytanud või ei alastud funktionina, aga me saame pilves toimuvad tegevusi, mis toimuvad mingis ümlusa peale, siis nämne AVStep funksioonidega automatiseerida. Mul on üks pakka tude, päris hitved aast tagasi, kes ehitas asutusele kogu krediit, checkimise, mörkflow, siis ASURE, STEP funksioonidena niimoodi, et kui kasutajal päreidulad sisse, siis lambda funksioonid küsivad info tereinaates Eesti liigi registritest ja mingisugusteste teiste bankade registritest ja osustavad selle põhjal, kas anda krediiti või mitte. 8 on kindi, nagu nal oli asutuse kogu bisnetslogika eksisteeriski nende AVStep funksioonidega tõlise workflow-na. 8 oli ka teene probleeme, et workflow läks nii suureks, et need ei saanudki korralikult AA4 formadis lõpudöös korralikult visuaaliseerida. Aga põhjalist on võimalik, misseks logikat hakkab tehtama STEP funksioonideta tasemel ja ainult teatud asju peab koteerima, konkreetselt kutsustest ja teatud logikamide ei saa lihtsalt tasemide. Aga päris palju, kuidas ningist teenuseks midagi võrta, kuidas ningist teenuseks midagi panna, kui ta siin meil ei saata, nendeleks meil ei pärisid koodi kirjutama võid saama eksisteerioid logikasutama. Siin on ka näite, et kui te klikkite mõne peal, et siin on mis store account distribution in dynamotivite, saate ka tehtineerida, mis olevat stations kuttu, mis andra palju paljase, mis on parameetlis, mis mõeldes endustations ja mis on see järgkunele, et kui tehtineerid, et kui järgkunele staatsuse tuu isselgitse workflow stepida lähedne edas, saab niimoodi karameerida, et me põhjast konfigureerime, et mis just. Siin on näite, et on võimalik ka visualiseerida varasemaid väljakutuseid, et kui meil on seama workflow juba üks kas väljakutus, et me saame visualiseerida, et mis ta teatud klendi sisendi pool tegi ja vaadata, et mis oli meil klendi almed, kui see workflow käivitus üks kord, et siin on säite, kus ta on käivitud, et visi marga riita pealast, et mis sa teid need almed igas sammustad minna ja deepakime saada näiteks logitele ja vaadata, et mis need sammud olid selle käivitud ühele. Võib-olla seda käivitud ühele tuhandel kordi päevas ja siis vajalik on vaadata, et kui te roolid suhtiselt, mikse nad juhtusid, kas midagi tegis või mitte. Ma võimalik keerulisemad asju, et defineerid, et näiteks meil on mingisugune konkreetel chase on ja meil on tähtis, et see chase on niikuks läbi erinevades labra-funktioonidest ja straatise lõpuks või sellel ajal, et sühtli lõpuks peaks kõik mindist vahepeaselt tegevaks, et olema truud, et ta oleks suksess, kui ei ole, siis järeikud midagi failis ja peama või põpe uuest läbi tegemaas. Et on võimalik, et staati meed jääbda niimoodi funktionid vahel, et funktsioonid ise on statelessid, aga me anname edasi nüüd chase-onid, kus chase-onid seetakse meed, mis oli teimselt samud ja näide tulemusev, et me saame sellist ratkust stateful operatsioone teha, et niimoodi funktsioonid käivitadakse, et jäedas järgistav funktionid, et on võimalik, et funktsioone siis sühtlist chainida jadana, et jääks käivitada jätkselt neli-operatsioone. Ja siin on veel üks näide, kus on rohkem lambda-funktioone, mida välja kutsutakse nende workflow see, et näideks customer-info küsimine, sinna küsimine, kui mõnevad lähevad õnnelikult läbi, sest ta läheb alles järgmisevse staatuseks, kus on ningisuguse maksmisevse tõetamine. Ja kui maks on, et töötame ja läks õnnelikult ägastud, siis läheb selleteljumuse töötuseks, kui maks on ei näed läbi, siis saavad, et sa võib pala kasutada SMS-et, maks ei näed läbi, et mine poohu uud. Ja siis siin on nelisammu, kus me olemme implementeerinud sellise funktsioonid, aga nagu näite funktsioonide vaheise viikumise logid, et näite siimeli saamise saab, mis saame väljas pala funktsioone defineerida, et saab sellised keerukamad loog, et peame defineerida. Aga see on siis näite Amazonis, kui me sooviksime näiteks vabavaralist nanoteenuste platform ülesseada, siis üks võimalus on open listi kasutamine, mis on IBMi poolt nagu algatud, aga ta on Apache, vabatarkvara open source teenus, et teie saad seda oma serveltepeal ülesseada. Kahe üks on paljidel platformitel ka avatud tarkvara limitatsioonid, et ei kruugi olla kõik funktsioonaalsuseid avatud tarkvara kaasas, et mõnikord on avatud tarkvara alka sellise premium licensid, et te teate teatud funktsioonaalsuseid isa maksma. Ja ma olen märgand, et open fahsin näiteks, mis on teine nanoteenuste platform sellised limitatsioonid on, et kaheks ei saa alati eeltada, et vabatarkvara on täiesti vaba või täiesti talvata. Aga open list pooltat peab kõikki programeeniks teeli ja see on ka täiesti tavalne, sest tegelikult saab tihti võimalutavalt teile ja tegelti tegevõii funktsioonid panna docker container sisse ja defineerida mingi käesu, mida käisid otsi docker container sisse, ja tegelikult docker container sisse saab te panna suvalis programeenis teele, keskkonna, runtimei. Et tegelikult selleputtu ei ole programeenis teele, et tänapäeval enam väga limiteerikud nii mikro-teenuste kui nanoteenuste platformette puhul. Ja see näeb välja umbes selline, et meil peavad vabat, avad su tarkvara puhul, kui me paneme teenuste üles oma serveritesse, me peame olema võimelesed kuulama süllmus, olgu need siis annebasi kirjate, et uued kirjatekiad annebasi olgusesid, sisse tulevad mbtt või rabitent kui sõnumite, kuulame, et mingisugused teenuste pead eksisteelime, kes need süllmusi tekitavad. Neid tehakse siis Apache OpenMisc'i sellist, kuidas sa eestikere sest üheldad, sellist fiigida, kus me paneme üles tarkvara näed, mis oska rabitent piud järjekorda puulata ja tekitada meile OpenMisc'i tüüpi süllmuseid, mis annavad edas teatud struktuuriga chaseani. Aga need saab siis töölepana näiseks rabitentiu kohta, postres kohta, mingi pilve teenuste kohta või e-mailide kohta, et iga tuetatud süllmuse kohta saab ülespana sellise väikse teenuste, mis kuulab seda tõetud ühti süllmuseid, ja kui sinna tekist, midagi siis saadavad openMisc'i edasi süllmuse. Funksioonipuul me defineerime trigenid, et kuna funksiooni käimitada, iga erineva funksioonikohta saame aga defineerida reeglid, et kui pildi suurus on näiteks suurem kümme megapaitiks, käivitad see, kui süllmuseid ütval see ja mingi sekkone temperatuurivärkus on suurem puus, siis käivitateks see teene funksioon või kolmante korva käiviteks konnast funksioon, ja need funksioon on võimalik nagu ükst esi äral defineerid, et käivitateks sellise chaseani, et funksioon A käivitab siis, kui funksioon B on tööl õpetandu, ja funksioon B käivitab siis, kui funksioon C on õpetandu, et see on nagu selleks C,B,H funksioonil käib. Funksioonid ise võivad seda kutsuda mingist kolmanta osapolekeerused, et anna kaasimteid panna või file-i, süsteemiku, midagi kirutuda või nüüd. Kuidas see siseliselt on umbasiklemeteeritud, meil eksisteeleks selline ngenics reverse proxy, mis kuulab sisse tulevad näiteks HBP-päringuid ja näiteks, mis põhimõtteliselt defineerib selled, kuidas funksioon väljakutsutakse. Kui me tekib siin nagu trikke, siis me implementeerime kui seda funksiooni, aga meil on vaja, et kuidas seda funksioon nagu füüsist väljakutsud. Mida me saaksin teha, et käsurida kasutavad funksiooni väljakutsuda, aga põhimõtteliselt ta open list teeb, et ta paned siin vajal HBP-r5, et funksioone, peras seda on otsustatud, et on süngus, mille tõhjaal teaks funksiooni väljakutsuma, siis saavad hapete peab pärinud. Ja see hapete peab pärinku kuulamiseks on selline ngenics kontroller, mis on siis vastutav kõikide sisse tulevad funksioonide väljakutsat eest. Selle eest on selline open list kontroller, mis otsustab, et kuidas vastata sisse tulevatele hapete peab pärinku teha, mis on siis funksiooni väljakutsa. Kõik väljakutsad lähevad kahk ka teadud järe korda, aga neid puferletakse siin. Ja funksioonid ise töötavad sellises tokke keskkondades, niimoodi, et funksioon näiteks meie Swifties implementeeritudse action või node.js is tefineeritud funksiooni väljakutse, see on siis tocker as node.js tocker images ja funksioon ise näiteks see jaoskirt paimise väljakutsiseks. Ja see platform siis otsustab, millim suge sellised funksioonu olinta nagu elus, et kui funksioonil ühtikö väljakutsa te ole, siis ta saav näid konteeerid kinni panna ja kui sisse tuleb uus päring siel tööleta järe korda, ta peab seda töötle makama, sisse ta panem selle konteeerid uusti tööle, et see huppalist on võimaline, et on teeneerid nagu seisuma panema käima, panema nulli staleerineid meie edas, et nõid funksioonikonteeerid ei peab hoidma, neid võib hoida elus näiteks alles ainult siis, kui reaset on väljakutsaid funksioonil peab. Aga tocker pakub siis hea keskkondad, kuidas teha custom keskkonna igalat funksioonil. Funksioonid käibitamise järe, nad ei taakaan, et nagi vasta otsa, teed, et järjekorram vastust, nad kirjutad vastus annepaasi, võimest, et Compresssation annepaasi, kõik funksiooni väljakutsad, siis edastakse lihtsalt annepaasi ja kontroller, kui on sukrone väljakutsed, et see leid oodab vastust aata, et see kuulab, vaatav annepaasi, kas vastus on kohale ja tagastab selle, või siis, kui tuleb hilisev ketpärin, ket ma soovin nüüd funksioonitulemusi vaadata, et siis ta vaatab, kes annepaasi nii kohale ja ne vastab selle. See on suhtselt peerulline arhitektuur, aga pilves on umbes aamuodelt reaset ikkagi tehaks mindisust konteinerid, aga see erinevus mikro- ja nanoteinosta vahel on see, et konteinerid ei pea kohagi jooksmas hoidma, et neid saab kinni, panab ühtegi sisse tulevad funksiooni väljakutsed või üksiküks ümmus, ei olemas is vajaks sile funksiooni väljakutsed. Ja siin on üks keerulisem näide, et kui meil näid, et see on mindisugune kasutaleidese back-end, et kui meil näid, et see on mindisugune kasutaleidese back-end, siis see jooksab kasutaja brousseris, ehk kasutaja käibitab siiava script funksioone, mis asuvad kasutajendakauseris ja me saame defineerida näiteks, et see on mindisina HTML vorm, et kui HTML vorm ei pideks vajutukse, siis saadetakse väljakutse funksiooni põns HTTB Flickr-ele, aga siin on näide, et kasutavad see webhook triggerit, et siis tui siin lupu vajutukse, kutsutatse funksiooni trigger-välja, mis sa poeva stress standpoint või sloper visti serveris ja kõik järgnevad funksionaalised või selle saakalise on, on mindisugune funksioonite seelimise stiivis, et kui jooksab see jahvalt funksiooniste järgis, kutsutatse välja non-jailest funksiooni ja siis kui on teise pangra tegus, kutsutatse välja teise pangra teise funksiooni ja kui on vaja mingisugust näiteks anmebaasi, anmebaasi suhjadest, et jooksatudse välja mingisuguse anmebaasi tähad funksioonist. Ja vahepeal kõib lõu kasutatakse ka sellist eraldi SunStream jooket, opole päris timpel, kuna see märg ei puudu. Aga see on eraldi funksioon ka, mis tegeled, nagu versiiltide või siis tsekide kireneerimusega, et see on midagi ostatud. Ja siis salvestatakse minna hajost, et hiljem saab hard to do, go to, üle webis vaadata neid tsekkeid, andasest kas tege, tsekki link tagasi, kui te sellel mingi valata. Siin on üks funksioon, siin on üks annafunksioon, siin on üks annafunksioon, siin on üks annafunksioon. Või ole, saab funksioon väegi juurde, siis see mõe paketa anmebaasi, või siis see on mingisugune mikropenus. Et see on just annavoid. Asure funksioonid on siis midagi, mida me praktikumis kasutame. Väga sarnas, et siis Amazon lambda, aga Asure annab kasutale rohkem nähtevust, et mis teaselt toimub backpendis, et kas teie funksioon on tõesti päris. Serverlessed seal jooksad ühtegi konteeleer taga või te tekite te te oleid reaalise backpendi, et meil on kogu aeg nii konteeleer jooksmas, mis vastavad selleliga maksalt erinava modeliga. Saab ka funksiooni pisevalt pidevalt jooksma jäta ilma, et funksiooni muutmat, et siis on võimalus optimeerida, et kas funksioon on teed. Serverlessed seal stilis jookseb, et te maksalt iga käibitamiseest, või siis te jätate konteeleer jooksma, et maksalt konteeleer jooksma saaja, et ta on 240 jooksev, ei helle, et maksalt. Asures on võimalik paremi, nagu hallast, et ta reaalt kogu aeg maksalt pisevalt jookseviseest, et siis aina käibitamiseid. Aga on võimalik erinevalt triggered kasutada. Meie kasutame Asura Tile Storage blow-off triggered, et uus paili üleslaiteks, et siis teie funksioon fakturid mis käibitud, aga võimalik näiteks kosmoskiibid kasutada, et kui CSL arme baasi uus dokument üleslaiteks, et see on põhjad muudetakse, reep kukkide, et või tiksalt LESparend saadatakse, või event-crete, või event-hard-lose sõrum saadatakse, et nagu sõnum järgurid uus sõnum tuleb näiteks sii jõutas ja jääbma sensoreid, et siis on võimalikks funksioone käibitud. Või väga livitatsiooni ei ole, kui pealmuse toetat, keelt on C-sharp, F-sharp, jalost püüpt, jalost püüpt, nagu PowerShell kaudu, midis käsurja käsub käibitud, mis omakorda mingi teise programmiga käibitud, võib-alist käsurja meedlade kaudus uvalist, meedlade kaudust käibitud. Ja, ja sinna on üks väike selline lihtne näite, et kui me tuleb sisse näiteks võib-alist mingisugune rest request, siis on võimalikse suunata edasi tööd teadete järjekorda ja panne at asore ja funksioonist teadete järjekorda kuulama ja siis saadma dokument, kui asumast lihtviis, et meil ei peagi selline server kogati juoksma panema sellise teadete järjekorda sinna vahele buffina ja funksioon siis töötab iga korp, kui sa on uusalt teedete järjekordas ja kui neid teateid toutub palju ei ole, siis meil ei peagi ole minikontainer, mis koha kuula appi teenuse, sisse tulad appi teenuse päringud, seda saad kasut, siis kui näiteks päevas, püstu tuhald korva saadateks sõnum ja meil ei ole vaja kogu aeg kuulata ja me ei taha maksta kogad juoksma teenuseid. Või siis asjad interneted, kui mingit sensorid saadavad asure IoT teenuses sõnumeid ja me tagame mingit funksionaalsest väljakutsuda ainult siis, kui näiteks temperatuurivärtsis on suure kui 80 ja me ei taha kogad juoksmas hoida mingit teelust, mis kuula kõiki sisse tulad sõnumeid, vaid me defineerime asuret asemalsele preconditioni, et kui JSON-eis ole temperatuurivärtsis on suuremalt 80, siis käivitateks sa see funksioon. Siin on te defineeritud Logic Appsid, kus Logic Apps on midegi samasteb funksioonidele Amazonis, et siin seeis on funksioon, mis otsustab, kas kuulataas, kutsuda välja Logic Appi ja Logic App on siis tehnologika, et mis on need teadud tegevõist, mis me teeme näiteks, kas saada SMS, kas saada testoopis sõna või push notification näiteks ja viis. Siin kutsukates välja sendeski ja sendeski tehaks südmuse, et mine kontrolli sensori, et sensori temperatuur on liiga kõrge, et keegi peaks jääseb minema ja mingisugune tööline saab oma sendeski tegevuse, et peaks sensori kontrolliima minema. Siin saab kõik teedlain pana näiteks, et peaks mingis tunni jooksud sinna minema. Ja siis selle elis on see, et me ei pea tegida midagi sellist reausti track endust, mis kogu aeg kuulab meid IoT sõnumeid, me ei vaid saame pilvet asemel defineerida see loogike, kuna meie funksiooni tägitab, see funksiooni see saame custom loogike diplometeerida, ja Logic Appi, kes on me välja kutsuda teadada teise teinuseid näiteks sendeski sõnume saab mene, kuna Logic Appi saanaga sellel, sendeski prok olemas ja meie peab ainult defineerida, mis oleks isendida. Meie funksioon ei pea ütleb, et teere on püütanud, et kuidas sendeski mingis väreid, et saab teadad uus sendeski töö tegitada, või et me saame välja kutsuda Logic Appi, et nagu tegimus eksisteerivad sellised workflow steelist loogid, et kuidas sendeski mingi tuud hirja teha, kuidas Skype uus sõnum seada, saab ta kuidas Slack uus sõnum panna nii edasi, et on selline Amazon Step Functions arane teenud, põhimust ongi põhimust sama teenud. Nano teenuste sellised teamise teelis, et on hästi lihtne on funksioonne skaleerida, sest ei pea ise nagu nendest valda oma, et platform ise otsustab, ku palju konteinerid tahts juoksma ja teie maksata ainult nende käivitamise. Prototypin on kastikine, kuna saate pilves koodi kirutada ja koha proovida seda ja ei pea isegi nagu koodi kuskil pilve üleslaadima või kitti panema, ja reeds, et saaks koha pilvessa teha kui hea ei ole, et ainult pilvesta oidadest erinealt koodi versioonid võib koduma mingi. Lihtne modifitsi on ümberdesigelda funktion, et saab ühe funksiooni kaup parenduda. Üks elis on see, et me ei enam ei maksa aja eest mida ei kasutata või öösele ühtegi sõnumid ei ole, sest me ei maksada. Me ei pea isegi olnud, kas me panema lihtto olema siin seisma, kas ma panema korteene seisma, et kui funksioon ei ole, siis me sellest ei maksa. Ja saab kombineerida kurga väiksemaid funktioned tekitasest loogilisi rakenduse pilves. Täiesti pilve poistete teenustaned on tõukselopti pilves, mitte konteenerit ja mitte servete saels. Ja sellest ühtunad on defineeritud aga serveles teenustana, kui reaaliselt füüsiliselt ta peab servetiohkma, ja ka ta tohus kõik käibitu, nii et reaaliselt pilvesemist pakku ja peab servetise teogita. Peamiselt puudused on see, et on raskem vältida platforms sõttumatust, kui teie designerida mingisuguse asutuse, business process ja Amazon step-funktioonidena, siis seda on väga raske, nagu ümber progameerid, et te peate põhimiselt mitte külb nullis seda tegema, aga kõik integraatsioonid, kus oleksisterivad neid kuskund vabavalastis platformtise prüukiol. Õnneks Amazon lamda jaoks eksisterib open lamda nii, et saad täpselt sama funktionid samade sisenid ja väljul tüutte triggeritega külama servetes ülesseada, aga tahaks, et Amazon step-funktioonidest asure logic appsid ja peale minna siis tõnskõite suurem osa ümber designimad. Võib-olla oleks parem defineerida sellised asjad, aga kuberneteses ka tuhedab k-native functions või keda funksioon, et saate, kui põnedse see sees sarvast asjadega. Rastgeva monitorida ja aru saada, mis toimub servelase puhul, sest monitorime tihti on kõvasti raskem ja ei ole enam selg, et miks funksiooni käibikund, sest väga palju on asju logide sees, kata teie ei näed. Väga palju probleeme võib tekita servelas raamistiku enda logide sees ja teile ei toki tõlsse nähtavad olla, et miks? Miks võitis alajaga enne, kui funksioon käibitus. Te ei tea, ku kaua oodati enne, kui mingisem konteeleer ülespaati, kus pandi teie funksioon käibitus ja väga palju asja võib lehtsalt veidatud jääda, kuna need toimuvad. Mitte enam mingist stopkered konteeleerist, kus teie saada asures minna ja eses aga sisse vaadub, mis konteeleeres juhtub, siis näedelise konteeleerid see teie liik ei kõik muid pääse. Eriti amasaris asures te võite liikki pääsada, kui te valite sellest tidi, kus konteeleerid juoks seal taustad. Rakeidus teheitamine on juba keerukas, kui teile on mingi sada serveles funksioonimist järjest käibituvad ja väga keerulis rakeidus teheitada. Ja küll käitis võikki olla probleemen, mis juhtub siis, kui ööselt või omikul tuleb esimene sõlum, ühti konteeleerid juokse, kime teinud pakku ja käab teile konteeleer looma, alles siis, sunnatakse teie funksiooni käibidus ennäidasi, kaua võtab aegad konteeleerid üles jada. Et see olukord, kus me midagi oia taustal juoksmas, tekitab olukord, kus esimised käibidusad võib väga kaua aega võtta. Võib juhtuda, et kui te näest ajab riitiline tööselt omikul esimene sündmuseks koha ära töödeltud, kui te nii selleks seetmed temperatuur on kõrgem kui krasjokraadeks, kohedast kelle ei saadma, siis võib võtta kovasti rohkem aega, kuni see anned saavad tegelikult töödeltud. Selle vastu ainab, et te maksate rohkem, vajate ühe konteeleeride töös saada asures. Näiteks valitendale kaili-liima teenusne, mis garanterib selle iga funksiooni aastale mähem tüks konteeleer alles. Aga lõpude lõpuks siis sama mood, kui teha mikro teenuse või virtuaalmasine ülepanna. Kulusid on väga väga rastine ennustada. Kui teie funksioon mingil põhjusel hakkab kaks korra aega saada tooksma, maksate kaks korra rohkem. Kui teie klientid saadavad 10x rohkem pärin kõik mingil põhjusel, maksate 10x rohkem. Näiteks stritteris juhtus, kui elonvõttis stritteri üle ja nad hakkasid mingil mikro teenus teemal, juhtus see, et kasutaja javascript rakendustes, mis oli juoks teie browserites, ei saadud enam ühele teenusele ligi ja javascript browserites hakkas lihtsalt refreshima iga ühe sepelt aga stritterist maha. Iga kasutaja hakkas olema nagu tennaal servispot, võimest aga igas browseris hakkab lihtsalt spammi ma stritterit. Kas ma saan teenusligi, kas ma saan teenusligi, kas ma saan teenusligi ja põhjumest kogu teeterlalt maha sellate tõttu, et mingil teenusele te maha ja kui endi javascript rakendustes oli, et kontroli uuesti ja mingil sellest bräkingbox ei olnud, mis kontrolli kindi panaks. Ja mikro teenused võib selle tõttu olla palju palju kaljima. On tehtud uurintud, et kuidel on tavaselt töötama appi, mis kaljuta näks 10% konteeeneri või virtuaalmasine jõudlusest kestmiselt ära, ja kuidel teete selle ümber nanoteenuste põhjiseks, et ta kogu ööpäev on töös ja 10% CP-uuskandustab ära, siis sama asja ümber tegemiseks nanoteenuste peale oleb olla väljamud kaks korda kaljuma. Põhjist ei olegi mõned teha midagi nanoteenustena, kui ningu niinad sa peate midagi oks mehattma, et sellise liul võiks ikka teha mikro teenuste või virtuaalmasine tõne, et võib-pallel lahkene inna, mis ei ole, et asu mingi põhjendad vära, et rakendust peaks olema vähevalt 50% ajast aidul, et oleks kasu sellest, et on designistet nanoteenustena. Ja isegi siis ei ole mingit karatiid, et on oda. Nanoteenuste designistelisest rakendustelisest võib olla palju kaljivad, kui nad kogu aeg pajaavad funtsiooni käivitane. Kui te ei saa suurt kasu sellest, et te panete ikka natukus ajan tagant containeri kinni, kui sellist mustrit ei ole, siis tõenest te on, et võib juhtuda, et teie mikro teenuste või virtuaalmasinena sama rakenduse designi minu oleks tegelt oda. Igen sellist asjad, mis juhtuvad näiteks päevas 10x, 100x, 1000x võib-e liseb 10 000x, mingite pilti töötlaste võib-e lau 1000x päevas, 10x päevas võib-e lauks parem seda pilti töötlusena, teha siis nanoteenustena funksioonina, aga kui ta peate pidevalt iga minut on sünnmusi kogu ööpava juoksul, siis ei ole mõted, seda ka nanoteenustena teha. Päris paljud näitad, mis defineerid, et teeme appi ja elitame appi, need nagu sellist nanoteenustena, et nendest väga suurta mõtetust ei ole. Piga sellist asjad, mis reaasad on ka, eventi toisid juhtuvad mõnikord tunnijooksul, mõnikord minutjooksul, ja te näete, et teid ei tahaks virtuaalmasinate konteine, et kogu ajad juoks mus hoidas, aga tegevus teha, et siis on näidest kasu. Aga sa võtakse järjekordast asjad töödlapäeera, et see on üle, et see on kindi? Jah, aga kes on see, kes paljab selle konteeere käima uuesti järjekorda? Kui sa saa defineerid, et Scron tööta täitsed ööseltil kaks, tööta üks kordi peale kindi, siis jah sellist asjad nii olla päris. Aga kui sa ei tea, kunas sa sünnmusi juhtub, et sulle tuleb näiteks tööde järjekorda tulebu uus sanum, ja siis sa tahaks, et keegi seda koha ära töödleks ja siis kindi läheks. Et sellised asju on raske, nagu ise automatiseerida ja sellist asjadeoks on misse mõetud. Ja kuberneetises saab defineerida ka, et mul on mikrotenus. Kuberneetises on lubatuda 0 listkaleeride, et tõl puola 0 röpikat. Ja kasutada sellist tarkvaraga, ma ei nüüd ei mäletu, kums oli, kes keda või peinäiti, mis defineerib, et kui tuleb rabiti järjekorda sõnum, kui nende sõnumid arvan suuremkui 5, siis scaleerib mikrotenus ühe peale ja see mikrotenus ises ühendub sinna järjekorda, hakkab seda sõnumid töötlama ja kui tead, et järjekorros on tead, et arv 0, siis keda või keneetimine on õigus, konteeleer uuesti 0 listkaleeride. Sellist asjad, mis on defineerida kuberneetises. Et keda ja keneetim on samuti põimastud selline maksionasaserviisusraamistikud kuberneetis. Ja põimastud selliste mustrit jaoks ongi mõnedud, et kui sa ise ei oska, nagu ette arvata, kunas se sinnmuk jõutub, et näiteks tuleb alarme, kii saadad mingiduse ästi suure prioriteetiga send eski mingisõnumid sõnumi ja sa taadad kohes ära töödandeks just selliste sinnmust jaoks, mida sa ei saanud ette, nagu ennustada, kuna neid jõutub. Ma olen üksingamõeld, et näiteks ükskord tungi särkab teenus üles, vaatab, kas on midagi, ja kui oles läheb magama, tegis sellist, et kromni ka pannada, kontrolli nii ka natus sadaga. Aga siis võib-olla meil, kui paljem ta liiga kisti tööle, läheb ka palju maks, ma vii kasutada palju resursse, nii et pigem, et see, kui sa tõesti tahad, et mingi sünnmuse peale midagi käibiduks, mis näide mustrit jaoks on mõõdedne nagu teenuseks rohkem nagu kui mikro teenuseks. Aga see ei ole sünnmuse vai siit teie oks, et mis seda sõitlust toaltab? Jah, aga siis sa koondata kokku nagu üheks teenuseks, et sul on nagu kogu sinu asutus ja klastri peale nagu üks teenus, mis erinade tüüpi sünnmuse kuulab, ja siis otsustokas mitte käidita mitte. Et paljadki ühe open viskii nagu servere üles, ja siis tema otsustab, mis funktione kuna käib. Jah, sul peab olema mingi teenus, mis näite sünnmuse kuulad, aga nagu pilves on ta siis üks keskne teenus või üks keskne teenus iga tüüpi sünnmuse jaoks, ja siis kui peal näite, siis sa on nagu üks, mingis see on teda või geen eeti konteiner, mis on vastutav, sellest, et tema kuulab kõikki sünnmusi, kelle tema sa konfigureerid, et mis sünnmuste peal asa, mida tahad käilitada, et siis longi nagu üks konteineri otsad, mis need aetsa teeb, ja tema on siis see vastutav proces siis otsustav, et kuna funktione käib, kui kuna mitte. Nanoteenuste mõnesed on see nagu loog, nii jätku mikrodelast väiksemat, et see on vajalik või mitte, kas on optimaalnev mitte, kas on oda mitte, on täiesti erenev isk, siis sa võimalda peal väiksema, et selled, et hästi väiksev funktioni tasemel teenuseid pilve teenuste nagu tekitada, ehitada, ja teenuste on nagu mõnesed väiksemat või mikrodelast. Ja sünnmuste põhine käivitamine, siis võib olla oda, kui pidevad vingisuse konteineri või virtuaalmasine tahad juoksmine, ja seda tulebki nagu otsustada, et kui kudagi hinnat, et kumb on oda lomb, kumb kasutab pähemressuussa näiteks teie kuberneetist vastrist, kui kumb läheb pilves vähem maksma. Teatud olukordas võib olla lihtsalt mugavam, et lambda funksioone defineeride pilves, selle asem, et ise ei oksutada püsi palju konteinerid või virtuaalmasineid, aga tõenast läheb see päris palju maksmasuidel on lambda funksioonid, mis palju mõelu kasutab peale aeg kasutab. Mikro ja rano teenuseid võib arvistada pidevad tarjadust, et me saame CSCB pipeline'ides näiteks panna ajutiselt konteineri tööle või käivitada lambda funksioonid. Me saaksime näiteks mingisubliselt tegevuseid lambda funksioonid defineerida, ja siis CSCB pipeline'id kutsuor välja nende lambda funksioone triggereid, olguks see läks nii krestpärin või siis opis mingisubliselt sõnumisead mõne järekorda, et me saaksime näiteks idea hoidma mugid konteinerid elus, mis kogu aeg asju teevataid. Me ei taanud käiviteks siis näites kus nerds ja questulii või uus kommentuni. Mida on praktikumist teeme siis see kord? Te olete varasemalt teinud, et front-tendid, te olete appid, jõgavad kaheks konteineriks, ja meil see vasak poolne põhjimuselt juba existeeli. Me oleme ka salmestanud file asujut lot storidzisse, ja see nano teinudselt teeme on see, mis hakkab poolnud asujut, et kui siia tegid uus file, siis ta tõmbab selle file'is valmis talal, et me saaksime argumentina, et aga me oleme teelik textfaili pdf'is ja laevad üles pdf'i takasiv asujut lot storidzisse. Tulevikus on meil võimalik siis raamatu teksti, failina tagastamise odenud tagastus ja taga pdf-failina. Me meele ei tee muudatuseid, meie vakkanus hakkaks toetama ketraamatu slash id, kus on pdf'ina tõmataks, aga võib-olla võib tulevikus liidama, kes selle takase sinna ja veebilehtega. Aga põhjemist, et iga kord võib meie raamatud taludus appi uus raamat tekitada, siis nüüd on meil pärime teksti-failid pdf'it valda maatsud. See ei ole põhjame 50. kohe täha, sest me saaksime tegelikult ka siin sellest metodis, et me laev üles nii textfaili kui ka pdf'i, aga ta liikumi hea 50. saata harjutada sellist nanokultioonid loomist asures ja me teeme see siis klatsikumis jännabalt. Ja tulevikus me teeme veel mõned muudatused ja paneme ta täiesti pilvepõeise rakendusele tõrne, aga pärast seda nanofuksioonil liigamisten, nagu loogik osam, kea ka kõik ära imponenteeritest. Võib-olla teeme par muudatust veel, mõned meetodid või muudatud meetodid saaks ka pdf'aile vaadata ja üks, see on huvitavad, küll on see, et praegu meie tehtudad meil mõlemad raamatud apid isesuttavad annapasina, tegevõib-olla see parem teha, et see raamatud otsivap ei suhti annaparid otsa, või tõlma praamatud allasest raamatud metodid asest meie teised apid teised hapist. Meil ei oleks kahte apid mikro tehas, mis annapasimus uhtavad, et võib-olla see loogik oleks antada parem. Aga võib-olla sest liimast kaksist endesa natku pümma. Ja jäärekone loon räägid siis täiesti pilvepulist rakjandust, apitektuuridest, kus jään enda omadust oest, võib-olla see toodal natukasele pilve teema kokku. Kas on küsimusi? Zoomis ma küsimuspräeme näe. Tänas sais natku varem tehtud. Küsimus ei ole raamatud teisenmisega. Mis põdius oleks raamatud teist? VDF eks põe mää saane teksti teha sisse? See on selleks, et VDF kujuntav võib-olla seda raatata kui paremini. Ta annab meile teata struktuuriga dokumenti, mis ei ole puhas teksti fail. Näiteks mingites VDF e-raamatutel lugeades või-olla ees parem teisimormaati või teksti faili promaati luge. Otseselt on hea kasutus. Ma võib-olla oskord vimtuua. See on kigel näite, milleks nano-fuksoone sinna kasutada. Kuidas sais sinnmuse poist teha. Mitte kogu meid toimub, vaid siisku uus fail toimub, saame ma oma, kuidas see faili, ASRO-Po-failid nüüd kasutada funktioni väljakutaks. Otsesel vajadust, miks kagustajust edistaks VDF-i reaselt ei ole, sest me tegelikult VDF-id generiime suhtelisest taatbilgel. Hea oleks, et tegelikult oleks päris editor, kes korralikult vaataks, kas hea kikkused on korrektiselt ja neid VDF-id eetsikagi korralikult, et see VDF oleks natuke kasulikum, kui paas tehti fail. Siin on ta piges, et see praktik, et me näitän, et kodas see on. Kui sulle enda tuleb pähem, midi ideed, kuidas nano-fuksoone sinna huvital kasutada, siis täku välja ja ma järgmine aastalist. Huvitul on, et kui me hattemellii eraldaks teksti, et me selle ketteb, kui saame paneme hattemellile üle, siis sealt eraldaki teksti. Mis selle hattemelliga tegib, et tegelikult tegist, et VDF ei pole olevame. Jah, et tuleb suhessi, et sa arna, et juba see VDF tuleb natuke na epamugam lugevalt tegstifail. Kuna näitest tegstifaili lugemisel, me saame näiteks läpimist kasutada ise. Aga arknasuurist muut, aga VDFisse väga ei tööta. Teatud VDF luge, aga võib rost, et see parem teha. Aga meil samas ei ole hattemellid failid kasulikult siin, et kui meil olnud... Me saame panne selleks kirja viga teparendus, et meil ongi raamatud, et siide üle. Võib-pall, ja, et see läheb lähemale võib-pall sellest. Võib-pall, saaksime Eesti keeltet öökkida raamatud. Et me saaksime näiteks, ja, teise keeltet öökkida raamatud kasutada mingi pöökkide. Ma mõtlen seda peale, et see järg näha töökk proovida, et meie ülikooli tõhke teinuskatudud aard, mis meil teile teha, Ouliteo. Et muidu muud appid läheb võib-pall natukalt kalliks, aga võib-pall nagu tude, mis saab, appid rajalida teha, et muidu Google tõlgeid või midagi muid kasutaja. Võib-pall jah, tehtimine või sellene igade parandus kui tagi, et parem. Jah, mõte. Suumist ma praegu küsimisei näe. Tänne on siis lõpetave natukalt läks kiiremne kui parasemalt, et ma naptsin võitsin sellist mikrotienastikordamist väeemalt läheb.