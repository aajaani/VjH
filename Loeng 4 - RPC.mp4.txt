 Tere tulemas siis neljandasse loengus meie veepi teenuste hajussüsteemid aines. Tänase loengu teemaks on siis kauk protseduurid, et me jätkame sellise hajussüsteemide vahelise suhtluse teemaga, kus seekord räägime viimasest sellisest hajussüsteemide objektid omavalsest suhtlusest ja järgne nädal natuke hüppame üle siis appidele ja veepi teenustele. Kuigime tegelikult räägime täpselt samaste asjast, et kuidas kaukelt mingisuguses serveris asuval tarkkvara meetodid välja kutsuda, mis tegelikult ongi ka samuti appidefinitsioon ja appide mõte ka. Aga alustamegi natuke siis ajalost tagasi. Olem siis selles kohas, kus me elmkord rääkisime siis sõnumite põhisest suhtlusest. Täna räägime remote procedure call, kaug proceduuride välja kutsust, ja siis järgmene nädal hüppame sobia resti ja hddb appide peale. Ja idea on siis sellasemele, et me ehitame kaks processi ja otsustame, et kudas processid oma vahel anmeid vahetavad, mis sõnuminet saadavad. Me defineerime selle sarnaselt nagu programeerimises, et üks klass kutsub teise klassi meetodeid välja, et meil on nagu processid, kes saavad üksteise meetodeid välja kutsuda. Et siis me ei pea defineerime võib-olla väga konkreetselt, mis on need sõnumid, mida me saadame, vaid igal meetodil on oma loomulikud sisendid, mis selle meetodi väljakutsumiseks on vaja, ja need anmed me edastame siis ülevõrgu, kui me kutsume välja mõnes teises serveris asuva processi meetodi või mingi appi meetodi või mingisuguse tarkvara meetodi. Idee on ka, et meid ei huvita väga, et kas see teine process on samas serveris või mõne teises serveris, kas ta asub üle võrgu, üle lokaalsa võrgu, et kas see on lokaalna või kaug võrg, see meieoks ei tohiks väga erinev olla, kui kiireaalselt võib olla suurem latentsuse, see tõltab rohkem aega, kuni meie vastust tagasi tuleb. Ja sana on idee siis ja, programeerimises teise klassi instansi või objekti meetodid väljakutsumiseena. Ja arpet see mõte oli ka programeerimise see, et me saaksime täpselt samamoodi programeerida, et me ei pead teadma programeerimised asemel, et objekt asub kusagil mujal, et me saame ikka oma pyytan koodis lihtsalt objekti meetodid väljakutsuda ja tegelikult see objekt ise asub nagu teises serveris või põhimestelt suunatakse edasi selle objekti väljakutse teises serverisse taustale. Ja osaliselt on see kasutaja või programeerija eest peidetud, aga osaliselt mitte. Te tegelikult peate paar asja tegema ja me vaatame natuke näiteid ka. Ja see on vana idee aastast 1984, ingliskeeles oligi selle nimi Remote Procedure Goal. Jaavast tihti nimetadaks seda Remote Method Invocation, kuna ei ole proceduur, vaidu metodid, et see proceduur ongi selline vanem sõna metoditel. Aga idee on täpselt sama, kas on proceduur, kas on funktsioon, kas on metod. Idee on, et mingiseks meetodi väljakutsumine, mis ei asu samas harvutist samas serveris. Mida tähendab metodi mitte asumine samas serveris, et tema implementatsioon ei asu lokaalselt siin serveris, et implementeeritud on ta kusagi mujal. Ja me ei võib-ole näegi, kuidas ta on implementeeritud ja mis kootel sees on, et seda nagu meie ei näe. Ja see kasutab siis tavalis klient-server-mudelid, et meil on mingisükki server, kes pakkub seda metodid ja klient kutsub selle serveri metodi välja lokaalselt lokaalses programmis. Ja osaliselt põidetakse ära, et server asub kusagil mõjal. Proceduurid tihti toimuvad musta kastina, et lokaalselt meil ei prugigi olla selle metod implementatsioon. Me ei tea, kuidas ta on implementeeritud, et meil ei ole isegi seda sisemist pinaarsed koot, mida käivitatakse selle metodi käivitamisel. Aga mõnikord on see kasulik, vajadus saada lokaalselt käivitada, et mingi pildi töötlus, kui server ei ole kätte saadav. Mõnikord on see täitsa võimalik, et meil on see koot. Aga üldjuhul klient ei tea, kuidas seda implementeeritakse kauad aega võtab, kas ta, ja et kui suurse koodi seegi on. Aga samas meil on vaja täpselt teada, mis on see operatsioon, mille me välja kutsume ja mis on selle operatsiooni sisendid. Ehk täpselt samamoodi, nagu me programeerimeses mingi metodi välja kutsume, et meil on vaja teada metodi nime, metodi argument, et mis on see anmed, mida me siis edase anname sellele metodile ja see peab meile midagi tagastama. Ja tegelikult need ongi täiesti loomulikult sõnumid, mida tegelikult taustas vahetateks kahe serveri vahel, ehk meie sõnumid eks muutuvad need nagu metodite sisendid ja väljundid või nende protseduurite sisendid ja väljundid. Ja sellisel juhul me ei mõtlegi nii väga välja, et mis näb metodid oma, mis meie program siis saad makab teisele programmile, mis jooksab kusagi mõjal, või et me lihtsalt meil ongi kõik sisendid ja väljundid metodide ongi net sõnumid. Ja kauk protseduurite kirjeldus, et kui me programmatiliselt kirjeldame, et mis on kauk protseduur, siis meil ongi vaja ära defineerida protseduurinimi, protseduurisisendid ja tihtiga protseduuri väljundid selleks, et oleks võimalik neid lihtsasti parsida, et ei ole hea, kui me saame üllatuks, et me loodame, et on Jason, aga tegelikult saame tagasi XML näiteks. Meil on tegelikult vaja teada, et mis tüüpise väljundid ka on täpsil nagu programeerimises. Eriti tüüpidega programeerimises. Ja kauk protseduuriteö keskond võib olla täitsa midagi muud, see võib olla teene architektuur arm, AMT 64 asemels, täitsa teine operatsioonis süsteem, oma mälu alla ja nii edas, et ta on täiesti oma hajussüsteemi sõlm, mingist teine serveri keskond ja me ei prugi tegelikult sellest teises keskkondast mitte midagi teada ja meid ei tohikski väga uvitada, et kas ta jookseb Ubuntu Linuxi peal või Windows, siis Python kootina või Java kootina, et tegelikult see ei tohikski väga tähtis olla. Ja parametrid ja tulemuseks, sisendid ja väljundid edastataksegi siis keskkondade vahel sanumitena, et taustalt kasutatakse täpselt samu viise, mida me oleme kattud siis elmistes langutes ja ühenduseks me ei saa eeldad, et meil on mingisugune väga lai riba ühendus, et me saame gigabaiti sekondis anmed saada, vaid pigem on mõeldud nagu väikeste anmed edastamiseks, mitte suurde videode edastamiseks, sinna võivad olla sisse ehitatud sellised maksimum latentsus, et ja kovas aega võtab, et kui meil on vaja videosid edastada, siis pigem tuleks valida mingisugune teine lahendus selle, agaks et me me tüüppeliselt ei tohiks panna video metodi argumentiks või video pinaarsed striimii väärdust metodi argumentiks, et pigem tuleks sellist atmed edastada muul visil. Ja tegeleme pigem nagu väiksete või keskmiste sanumitega kui suur anmedega. Ja üld juhul vähemalt esimestes implementatsioonides oli see täiesti simkronne, et klient kutsus välja metodi, taustal edastadis selle metodi välja kutsume teise serverisse ja klient jäi ootale. Ehk see algne implementatsioon oli täiesti simkronne, aga tähna vaatame ka seda, et kuidas tehaks asynkronset ja kuidas jäävad programeerid, siis saad need tulevikko objektid põhimõtteliselt. Et kutsute välja mingisuguse metodi ja saad teendal tagasi nagu tulevikko objekti ja taustalt käib siis selle metodi välja kutsume serveril, kuni see server tagasi saadab anmed, siis tulevikko objektiil nagu väärtusi ei ole, et teie saada kontrollida või saada defineerida alerti, et mis juhtub siis, kui tulevikko objekt lõpuks väärdustatakse. Ehk jaavast lihtsalt kasvatatakse pigem nagu tulevikko objekte implementeerimiseks. Aga algselt jäi lihtsalt klient ootale, kuni vastusa saab funksioonilt ja siis ei ole tähtis, kas see vastus tuleb samalt arvutist või erinevast arvutist. Ja see onki üks viis, kuidas programeeria eest saab ära peita kõik seda sõnumite vahetust, paralel või seda hajussüsteemide programeerimist, et klenti arva, et ta kutsub välja meetodi ja ta ei tea, kas on lokaalne meetod või kuski mujal hajussüsteemis asub meetod mingis teises serveris jookseb. Ja klendil samas peab olema mingisugune lokaalne meetod või kood, mida ta välja kutsub, et meil ei saa olla niimood, et me pyütunis kutsume, hakkame võtma ühendustis serveriga või et meil tegelikult peakse eksisteerima mingisugune lokaalne meetod, mingisugune lokaalne klass, mille meetodid me välja kutsume. Ja tegelikult meil on vaja mingisugust koodi, kuhu me saame nagu edastada need sisendid ja selle meetodi väljakutse. Ja tihti seda ingliskeeles nimetatist tabiks, eestikilles tüükkaks, et meil on selline väike funktsoon, kuhu me saame selle väljakutse edastada. Ja see funktsoon siis põhimõtteliselt jätab meid ootele ja selle funktsooni implementatsioonis ees on kogu see hajussüsteemis sõnumite vahetus, kuhu ühendust võtta, kuidas sõnumid vahetada ja meie jääme selle tüükka või stabi taga ootel, et see on sarane siis tulevike objektide implementatsioonile näiteks. Ja tegelikult selle asemel, et seda lokaalselt meetodid väljakutsuda või et selle taga oleks mingi loogika, siis sinna tahan peidetas kogu see hajussüsteemi loogikat meetodi otsese väljakutsumise asemel või teel edastatakse sõnumu hoopis sellele serveri, kus selle metod implementatsioon tegelikult eksisteerju, nii et on osaldsead peidetud kasutajaheest või programeerijaheest. Aga siis serveris on täpselt sama metod koost päris implementatsioonina, et meil on nagu selline lokaalne liidesest stiilis tüükas ja siis serveris asub täpselt sama metod samad argumentidega, aga seal juba asub päris implementatsioon. Ja siis kogu see suhtlus klendi ja serveri vahel peidetakse programeerija või meie eest ära, et me ei arva, et me kutsume meetodi välja, aga tegelikult toimub see taustas nagu kahe hajussüsteemi sõlme vahelne suhtlus ja kaugel asuva meetodi väljakutsumine. Ja ma juba seda ütlesin, et mis selle nimi on, et meil peab olema mingisugune lokaalne meetod või klass, midama välja kutsumine. Ja Eesti, kes on selle nimi tüükas, ma usun, et on veel teisi nimesid ka. Inglis, kes on seda, et niimeks on STAB, et mingisuguse meetodi selline võlds implementatsioon mõttes. See on tehtud, seal on implementatsioon, aga see implementatsioon ei ole seotud üldse nagu meetodi enda väljakutsega, vaid ongi seotud kogu selle suhtluse ja anmed ledastamisega. Ja ta ei ole, ütleme, et meil on meetodi interface ja me saame luua selline interfacei põhja, et meil on metodi interface, et meil on metodi interface, et meil on ütleme, et meil on metodi interface ja me saame luua selline interfacei põhja al STABi, mis on nagu mõnes mõttes võlds implementatsioon ja me saame serveris luua selline interfacei päris implementatsiooni, aga me saame siis serveris meetodi väljakutsuda, aga me saame ka siis selle STABi kaudu meetodi väljakutsuda, aga STABi kaudu või tüükakaudu meetodi väljakutsumine siis tegelikult toengub nagu edasi suunamine või selle proksimine. See on nagu proxy põhimõtteliselt, et ta nagu meetodi proxy väljakutsumine, et tegelikult me ei kutsu meetodid lokaalsalt välja, vaid taustal toimub selline suhtlussele asemine, et võib- olad nagu proxy on mõnes mõttes parem eestigelne nimi, kugi proxy ka ei ole eestigelne suna. Aga ja, ta selles mõttes lokaalsed implementatsiooni ei eksisteri. Ja siis võimaladab klendi rakendusele päe seda teenusele ligi nii, et klendi arvatest ta näeb välja nagu kohalik, varjates kogu selle suhtluse üksikasjad kasutajest ära. Ja ta lihtsustab selles mõttes arvendusprotsessi, et me saame toetuda sellele ütleme teegi implementatsioonele, et kuidas RPC implementeeritakse ja me oma koodise ei pea ise välja mõtlema, et kuidas saata sõnumeid, kuidas ühenendustuota serveriga. Mõnes mõttes me isegi võib-olla ei pea teadma, kui me peame seda konfigureerima, et kus need serverid asuad, et kogu see keerukus peidetakse programeerimise hetkel ära, kui ki ta implementeeritakse siis teegi tasemel, kes oskap näid tükkad ja staab ja RPC-t implementeerid. RPC siis teeg võimatsõlsed või see tarkku ora siis implementeerib selle. Ja pakkudes siis arvendal täpselt samasugust liidast, et püüt on lihtsalt mingisuguse klassi mingisuguse meedadi välja kutsumist selle asemete tegeleda sõnumite vahetusega. Ja et on sellesamudse nagu abstraktsioon. Väga kõrgele tasemel toimub see umbes niimoodi, et meil on klient, kes kutsub välja mingisuguse metodi ja pärast selle metodi väljakutsud hakkab toimuma klendi arvutis ümbersuunamise protsess, et selle asemel lokaalsed väljakutsuda, tuleb serveris väljakutsuda ja sisse selleks, et sõnumite tekitada tuleb meil sisend kodeerida, et kui meil on mingid lokaalsed püüt on muutujad, aga serveris on C program näiteks, siis tavaliselt standardiseeriteks need sisendid ja väljondid ära mingiteks RPC protokolli paastüübiteks. See võib tegelikult sisemised olla XMLX, JSONX, see võib sisemised olla mingiteks protopuffiks, kui me räägime Google'i GRPC-st või mingisugus selle RPC protokolli speziifiliseks anme tüübiks ja sõnumi anme tüübiks põhimõtteliselt. Kui teeriteks ära, siis saadatakse sõnum serverisse ja jäätakse ootale, et kuni vastus tuleb tagasi. Serveris võetakse see sõnum vastu, teeritakse vastavalt selle programeerimeskeele, speziifilistele, anme tüüpitele, kas on integer või mingisugune R või midagi muud. Täiditakse funktsioon, tavalselt panaks see ka kaas, mis on selle funktsiooni nimi, mida me tahame serverist käivitada. Täiditakse funktsioon, võetakse funktsiooni väljond, jälle koteeritakse, et RPC protokolliga saaks tulemus anmed tagasi edastada klendile ja klend tekoteerib lahti, võtab vastuuse sealt tekoteeritud seest ja jätkab käivitust, et mis iganesse järgmine käskoli on. See on väga lihtne, et me lihtsalt edastame. Praaktikumis me osaliselt teeme selle läbi, et me teeme seda küll pyytonis ja me implementeerime RPC ise, me implementeerime RPC rabit ja habil, et loomame sellise hästi-hästi lihtsa rabit ja Jasoni põhis ja RPC süsteemi praktikumis. Me teeme saanamise procesi läbi. Kui meie aga see tekoteerimin on suhtel lihtne, et me toetume rabitile, et tekoteerida näid sonumi, et me paname rabit ja saad Jasoni, rabit ise tekoteerib selle ära ja siis rabitist küsime Jasoni ja see tekoteerimine ja koteerime toimub automaalsed rabitipolt. Meil on mingisugune mõlemas arvutis, on meil mingisugused kihid, et klendi kihis on meil see klendi tarkokara näibiks püütane program, mis siis RPC-ed välja kutsub, siis meil on klendi tüigas, kes implementeerib selle võimaluse, et kutsuda välja kauge lasuvad metodid, kui lokaalsed püütoni metodid. Meil on mingisugune RPC-vahevara, mis tegeleb kogu selle tekoteerimise ja koteerimise ja anmet edastamise võrgupaketide teel kuhugi teise serverisse. Selle serverisse on sarane RPC-vahevara, mis oskap RPC-sõnumid vastu võtta ja saata ja siis on serveri tüigas, aga see serveri tüigas juba nüüd põhimõtteliselt, kas sisaldab, võid oskap käivitada juba seda päris koodi, mis on selle sama metodi implementatsioon ja siis täidab selle koodi. Põhimõtteliselt klendi tüigal vastab serveri tüigas, aga serveri tüigas teab, kus on implementatsioon või mis päris püütoni või java metodid väljakutsuda ja serverist täidetakse see. Probleem on ka see, et mis juhu kui viga tekib. Kui me kutsume välja lokaalse metodi, tekib viga, siis me saame uurida, et kus see viga tekis, mis reas koodis. Me saame püütan stack trace või avatsja stack trace uurida, et mis olid need metodid väljakutsujärjestus, et kus viga ta päris tekis, mis reas koodis. Kui meil ei ole lokaalselt koodi, mida me siis teeme? Kui klient näeb, et tekis viga, aga vea tulemus on, et XML sõnumis oli mingisugune väärtus, võitme väärtus vale. Aga meie mõtlasime, me kutsusime välja püüton metodi, miks me tegelem X ja Melliga. Et seal tekivad nagu mitud aset vigaadest, et kas viga tekis serveris asuvavast püüton koodis, kas viga tekis sõnumite struktuuris kodeerimisel, lahtikodeerimisel, et võib-olla ta ei oska teatud UTF-8 ääätähti kodeerida korrektselt ja siis tekis sõnumite konverteerimisel viga. Et vigased võib tekida kas serveri ja klendi vahelises ühenduses, ülevõrgu paketide saadmisel, nii et meil on nüüd palju rohkem erinaid tüüpe vigased, mis võib tekida. Ja kas me üldse tahame klendile anda mingis stack trace, mis võib-olla kogematab prindib välja mingisugused salased väärtused, mis on ühendusega seotud mingisugused võitme. Vigade käsitlemine on siin palju keerulisem, tekivad igasugused hajussüsteemide probleemid, tuleb mõnesmõttes otsustada isegi selle RPC tarkvarja implementeerimiselle, et mis suurvigased edastatakse. Ja sellise tarkvarat e-bagimine võib-olla palju keerukam kui lihtsalt kohaliku meetodi välja kutsumina. Et te võite saada mingisid vigased, millest te mitte midagi aru ei saa, sest seal on üldse seotud selle funktsiooni loogika välja kutsumisega, võid on üldse seotud mingid RPC mehanismide või sõnumide struktuuriga. Ja siis on ka, et kui tekib viga, mis me siis teeme? Kas RPC kutsub selle meetodi uuesti välja? Kas RPC millegi tõttu kutsub selle meetodi kaks korda välja? Me saame tulemused kudagi oma arvutesse kaks korda tagasi, kun nad arvab, et tegelikult käivitas ootab liiga kova aega ja proovib uuesti, kas päringult peab kordama. Mitu peab korda peaks kordama enne, kui kasutale üelda, et server ei ole kätte saadav. Ja kui server saadav vastuseid, kas server peaks ka ülekontrollima, kas klient sai vastuse kätte või mitte. Et kui me elmikord rääkisime sõnumide järjekordata puhul erinevatest nendest strategiatest, kas sõnumide saadadaks üks korda või mitte korda, et karanteerida, et ei tekiks dublikaaata või karanteerida, et tõesti klient sai selle sõnumikätte. Et kas siis selle jaoks on võimalik suhtiselt sarane tase konfigureerida sõnumide kohale toimetamisel, kun nad austal tegelikult me tegelemegi sõnumide kohale toimetamisega RPC-sees. Meil on tähtis ka see viahaldusisse mantika, et kas meil on võib olla meetodi käivitamine ja tulemuse kätte saamine, või me tahame karanteerida mingisuguse pangadussisteemi puhul või hästi kriitiseb sisteemi puhul, et kui meetod väljakutsuti, siis klient kindlasti saab tulemuse ja täpselt ühe kora või ühe tulemuse tagasi kätte. Et siis ongi võimalik valida, kas meil on vähemalt üks kord meetodi käivitamine, et karanteeritakse, et kindlasti meetod käivitatakse või sõnumid juhad kohale. Kas me tahame karanteerida, et vähemalt üks kord käivitatakse ja me ei ole okei, kui seda meetodid proovitakse käivitada mitukorda järjest, et ei tekita mingisugust probleemi anmebaasis, kui me kutsume sama meetodid mitukorda välja, et ei tekik kolme kirjat ühe kirja asemel anmebaasi näiteks. Kas meil peab olema sisseheitada mingisugune duplikatide filtreerimine või astuse kordamine? Või siis me peame karanteerime, et tõesti kui klient saadab meetodi, siis meetod kutsutaks välja täpselt üks kord, aga mitte rohkem kõik kord. Ehk pigem prooviteks implementeerida sest transaktsioon, et karanteerida, et tõesti see käivitus toimus. Ja anmebaasi pandi ainult üks kord mingisuguse tulemused või saadati välja mingisugune SMS ainult üks kord. Saadate tee e-mail välja ainult üks kord ja vältida seda, et duplikaate tekiks. Selles aine, sa me väga seda ei räägi, et räägitakse magistri õppes hajussüsteemid aine seda rohkem, et kudest see taustal toimub ja misugused loogika sellest tagapäepeab olema implementeeritud selleks. Aga täpselt üks kord sellene poliitika prooviv siis tagada, et kindlasti jõuab see meetodi väljakutseda. Aga see võib olla suhselt kerran, et vähemalt üks kord siis põhimõtteliselt näiteks server saadab tulemus tagasi klendile, kuni klent saadab vastu acknowledgemente, et ja, ma sain selle tulemuse kätte. Aga siis ei ole nagu klendipool implementatsiooni selle koht, et duplikaatide mingisugust e-maildamist. Aga need tasemed vähemalt üks kord, ülimalt üks kord või täpselt üks kord on samad, mis AMQP ja MQTT protokollides on kasutuses sellise quality of service moodidena või nende lähenemistena. Ja kauge, proceduuride või kauge meetodide väljakutsa probleemid on see, et need on tavaliselt ja algselt implementeeritud väga synkroonsetena, et klend ei ootale, kuni meetod tagastab midagi. Suurst, et vähe oli võimalik anmeid saada, et me pidime hästi palju meetodide väljakutsid tegema, et rohkem anmeid saada, kuna ühe meetodi väljakutsa oli piiratud esimestis implementatsioonides. Puhudusid sellist voo kontrollid ja puferdamised, et kui klend võtab vastu anmed, siis ta peab võtma vastu neid anmed, mis vastu saad, et ta ei saa nagu lugeda neid anmed, näiteks väikse tükki haval või vastupidi, et iga kord, kui me tahame uusi anmed, siis me peame uue päringu tegema, aga ma ei saa jääda kuulama, et lasta serveril meil avatud ühenuduse kaudu järjest rohkem anmed saada, et näiteks öelda, et ma sooviksin saada kätte kõik viimased mingiseliselt sõnumid anme baasist selle stabilist ja siis ma pean iga kord uuesti pollima, sellasema, et ma teen ühenuduse lahti ja lasen serveril saata mulle selle ühenuduse kaudu järjest rohkem uusi liituvaid mingisuguseid sõnumeid või kirjaid anme baasi. Me vaatame korraks seda, et kui täst GRPC seda tänapäeval tuetab väga hästi ja miks ta populaarskas on saanud. Ja tihti lähevad nend väljakutsa ahelad keerukaks, kui meil on rohkem kui kahes sõlme vahel nagu see RPC-t. Kui mina saadan pärin, kui ühte serverisse RPC kaudu ja see server teab RPC kaudu veel järgmisesse serveris sõhenduse ja siis to server teab veel järgmisesse sõhenduse, tegib see ahel hajussisteemide sõlmed vahel, et siis nende debugimin on isegi keerukam ja kogu see sisteem läheb väga keeruliseks ülesehitada ja jälgide siluda debugid, et kuidas see töötub. Ja ta on suhtselt jäik selline klient-server rool, et kui me tahame, et klient saks serveri meedlade väljakutsuda ja samuti see teine hajussisteemi olem peab saama esimese serveri, esimese klienti meedladev väljakutsuda, siis tava RPC kauduse ta teha ei saanud, siis mõlemad pidid mängima serverit ja eraldi ülesehatma sellised võimalused, et see ei ole, nagu ühe ühenenduse tegemise kaudu ei saanud server, siis klienti remote metodid väljakutsuda niisama, et suhtluspartnerid ei olnud siis võrdsadnud, ei olnud mõlemad serverid. Ja ei olnud võimalik, nagu sellist asynchronous, et callbacki teha, et klient saadab sanumi ja siis server hiljem kutsub välja klienti metod, et seda sanum takastada, et seda esimestes implementatsioonides ei olnud võimalik. Aga hiljem implementeeriti asynkronselt RPC-t ja see töötas niimoodi umbes, et ma kutsun asynkronselt mingisuguse meetodi välja, selle meetodi tulemest kirjutatakse mingisuguse objekti, mida ma saan hiljem pollida, aga ma ei jää ootale, vaid ma jätkan oma koodi käivitamisega ja hiljem käin ja küsin, kas selles objekteis on väärpise, põhimest selline future-objektid, kus ma kontrolli kohe ei eeldagi, et see väärpus kohal on, vaid ma tean, et see võtab kaua aegas, ma teen mingisugus muid tegevusi, et näiteks asynkronselt erinevate. Sisse tulevate päringute töötlus niimoodi, et ma RPC-kaudu kutsun välja mingisugused teiste hajussüsteemi sõlmed ja meetodid, aga ma ei jää nagu ootale, kas et kohe midagi väljastavad, vaid tulem hiljem tagasi ja vaatan, et mis see väärpus hiljem oli, kui see lõpuks kohale juob. Et ja, et selle jääks tihti kasutataksegi näid future-objekte, mis tulevikus avad alles väärtuse. Et me saame testida, kas hiljem kas tulevikus objekti seese on nüüd väärtus tekkinud, või siis me saame defineerida, et käiviteke mingisugune meetod, lokaalne callback-metod, siis kui future-objekte isa vastas kohal. Sana sellest midagi tekite ka rapidMQ praktikumis. Aga me võime ka teha lihtsalt politavad, et me iga natuk saada, kas controli, mingis future-objekte isa on mingisugune väärtuse. See väga kõrgele tasemvisualiseerimisel toeta pumbas niimood, et me kutsume välja ARPETSE-ekoodu serveri meetodi, ja siis tekitame kuskile tuleviku objektit näiteks listi ja esialgun nendel väärtust ei ole, aga me koha kutsume välja kolm ARPETSE-metodid ja ei jää ootale enne teise väljakutse tegemist, kuni esimene saab vastuse, vaid me järjest kutsume kolm välja, ja siis hakkame kontrolli ma näiteks, et kas nende saab mingid väärtuse. Ja siis server kutsub järjest välja ja ARPETSE protokollika autu saadab vastused ja siis ARPETSE tarkvaras siin õtab vastuse vastu ja paned nende väärtused õigesse future-objekti, kus siis hiljem klentsab polides või mingisuguse callback-metodi väljakutse tead, et seal on väärtust olemas. Saab näiteks kontrolli, mõt kas tuleviku objekti siin nüüd on uus väärtuse mitte. See on hästi lihtne visualtioon. Ja see tähendab seda, et me saame siis kolm tükki väljakutsude ja alle siis testi makata ja server saab nende nii kiiresti, kui tema on võimeline käivitada. Server võib nende tegelikult käivitada mingis teises järjekorras näiteks, kui server on ise hajutatud ja seal on mitu paralleelsed töötavad töötajad, kes võtavad näiteks järjekorrast sõnumeid ja võib-olla esimene töö on aeglassem kui teine töö, aga teine töö käivitatakse mingis serveris, mis on vaba ja nii kauku esimest käivitatakse, siis teine server on teise töö juba ära teind ja saadab teise tuleviku objekti vastus enne, kui esimene üldse kätte saadakse. Selleks, et me saaksime kuskil muheal serveris oleva meetodi väljakutsuda, meil on vaja neid kirjeldada, et kus asuvad serverid, mis meetodid seal on, mida saab väljakutsuda, mis on nende meetodite sisendid ja väljundid, et meil oleks vaja mingisuguses standaardeid, mis kirjeldavad seda, et kus asuvad need remote meetodid, mida meie programmist saab väljakutsuda, kas meil on kusagi mingi rekister, kui me saame ühendada ja küsida, et kas kusagi lasub seda tüüpi meetod, et mis on selle server IP-adress, meil hajussisteemide võrgus või üldse internetis näites kusakile, et kui me API siit kasutama näiteks. Siis on väga erinevaid standaardeid selle jaoks, näiteks Open Network Computing Interface, Cobra Common Object Request Broker Architecture, midul on Microsoft Interface Definition Language, JAX RPC on siis Java App for XML-based RPC, puhas XML RPC ja puhas JSON RPC. Need Java XML-i põhised on suhtsealt laialdaselt kasutuses, aga kui nüüd mõeldad, millega me tegeleme, me tegeleme kuskilt ülevõrgu meetodite väljakutsumisega, siis kuidas see tegelikult erineb mingisugust HTTP Appist või kuidas see erineb REST Appist, et tegelikult idea on väga sarnane. HTTP Appi ja REST Appi panad natuke rangemal paikat, mis on need meetodid, mida on võimalik väljakutsuda, aga sellest me räägime ei siis järgmine nädal, mõnesmõttes HTTP Appid ja REST Appid ongi teatud tüüpi RPC-id. Ja tihti kasutataksegi XML-i, kasutat XML-i nende meetodite spetsifikatsioonina ja XML ja JSON-i, lähene mõne on väga lihtne, saadame serverile JSON-i ja JSON-i see, et mis meetodid me saame väljakutsuda, mis on selle meetodid sisendid ja server siis parsib JSON-id, et teada saada, et mis on see meetodi väljakutse. Ja tegelikult midagi sellist me teemegi praktikumis läbi rapidiga, me kasutatame siis rapid JSON RPC põhimõttelis praktikumis implementeerime ise rapidi põhjal. Ja te näete, et see ei ole tegelikult väga keerulne selline JSON RPC implementeerimine. Aga põhimõttelis siin ma taangi natuke rääkida, et kuidas see umbes toimub. Meil on siis vaja ühele sellistele standarditele vastavad kirjeldust. Siin on näide siis Cobra kohta. Meil on Cobra spetsifikatsioonis kirjeldatud siis remote meetodispetsifikatsioon, et mis on see meetodi nimi, mis on selle meetodi sisendid ja väljundid. Põhimus, et lihtsalt näiteks XMLi dokumentina kirjeldatud, et mis on see RPC meetod, mida on võimalik väljakutsuda. Ja siin me kasutame Generator Darkpara, mis on võimeles genererima selle spetsifikatsiooni põhjal serveri poolele skeleton, kus sisemine loogik on implementeerimata ja kliendi poolele tüugas või proksi, mis on implementatsioon, et kuidas seda serveris asuvad meetodid väljakutsuda täisest serverist. Implementeerijad peavad selle skeletoni põhjal implementeerima loogika vastavalt keeleskas jaavas või pyytonis või C-sharpis näiteks. Ja panema selle serveri rakenduse siis üles, kuskil serveris jooksma ja kuskile registreerima, mingisuguse name serverisse või registrisse registreerima, kus see server asub ja misugused meetodeid ta toetab. Jät server implementeerib mõned need ITL-is kirjutatud meetodid ja saada registrisse, et mina asun siin IP-adressil ja mina toetan neid RPC nagu spetsifikatsioon, et minu serveris on need implementeeritud, et nüüd mulle saab üle võrgu saata RPC sõnumid, et neid meetodeid väljakutsuda. Ja klient, kes soovib siis sellist meetod väljakutsuda, ta võtab selle Generated Stab tarkvarad näiteks genereritud pyyton keeles ja siis saab seda tegina kasutada pyytoniselt need meetodeid väljakutsuda lisaks ta peab defineerima või otsima vähemalt, kus need serverid asuvad, mis seda meetodid toetavad ja valjama ühen endast põhimatsalt. Et kui registris on kolm, siis ta valib ühe milline väljakutsu. Et see register või name server võib siis olla meie rakenduse sisemine, aga see võib ole ka globaalne mingisugune kõiki servereid. Põhimatsalt ta ei ole selles mõttes, et kõik serverid ühendast võtavad, aga ta võib olla rohkem kui ainult meie hajussüsteeme osa. Näiteks võime jättekujutada, et siin on mingisugune Twilio meetodi väljakutsumid, et saata Twilio kaudu SMS. Ja siis kui meie rakendus tahab Twilioga ühendast ota, siis ta küsib name serverist, mis on Twilio SMS saatmise sõnumi serveri adress, mille kaud on võimalik Twilio meetodeid väljakutsuda et SMS-i saata. Et siis otsitakse Twilio adresse, kus need metodid on implementeerikud. Ja siis kui klendi rakenduses see meetod väljakutsuda, siis taustal toimub siis RPC implementatsiooni vahel sõnumite saatmine, et se serveris, se server kutsub välja reaalise implementatsiooni, et lõpuks saadad näid tulemused tagasi, et siis see kiht, kus on implementeeritud, siis RPC-se tegeleb siis selle tüükka või proxy ja selle realise implementatsiooni vahelise sõnumite vahetusega. Ja klendi tarkvaraselest midagi tead, ma ei tead, tema arvab, et ta lihtsalt kutsub välja selle püüta metodi ja implementatsioon võib olla teises keeles. Ja see on tegelikult väga sarane, kui täs appid töötavad samamoodi. Java appi XML põise RPC-aks ja karta XML RPC on põhimõtteliselt sarane, aga idea on, et see töötab Java'al, et need implementatsioonid ja klendid on Java'as implementeeritud ja me kasutame soap protokolli, millest ma ka järgmõne kord räägin, et kasutakse soap ja HTTP protokolli selleks, et vahetada siis sõnumite kahe Java virtuaalmasine vahel, üks mis asub serveris ja üks mis asub lokaalsalt. Ja samamoodi on võimalik siis genereerida klendi ja serveri tükkaid või proksisid ja saame siis nii klendiosa kui serverosa genereerida. Alati me peame serveri osas mingisuguse implementatsiooni ka looma, aga see on alati nagu vajalik. Vaatame ühtel näidet, et meil on hästi see Hello World näide, mis on implementeeritud siis selles jaks RPC's, et meil on vaja defineerida config.xml, mis defineerib ära siis, kus asub server. Meil on vaja selle meetodi spetsifikatsioon xmlina, mis kirjalab ära webi teenusti selle parametraid ja meil on vaja ka web.xml, mis kirjatakse ära, et kuidas seda üleseada siis käivitada serveris. Ja siis meil on vaja liides, jaava interface viis liides, mis kirjalab ära selle meetodi sisu, et mis on meetodi nimi, mis on meetodi sisendid ja väljundid. Siis meil on Hello World klient, kes kutsub välja selle meetodist tükka ja meil on Hello implementation, mis implementeerib siis selle meetodi loogika või sisu serveri pool. Liides näb väga lihtne välja, täpsel samamoodi nagu jaavas on, klasside liides, et meil on mingisugune interface, mis siis extendib seda remote ja see remote on siis jaava RMI tegist. Ja me peame ära lihtsalt kirjalama, et mis on selle meetodi nimi, mis on selle meetodi sisend, väärtused ja mis on selle meetodi väljund. Ehk siis saaname stringi ja välja saaname stringi. Ja ta viskap ka siis nagu remote exceptionid, mis võib-olla annavad meile tagasidat ühenduse kohtat, kui ühendus feilib. Ja jaava server on siis meetod, mis implementeerib selle meetodi, mis implementeerib selle liides võib-olla mingi klassi meetodid ja siis implementeerib, et mida see meetod siis selle sisend stringiga tajab, et tagastada siis väljan string. Et ta praegu lihtsalt tagastab hello string, hello pelle, kui string on pelle näiteks. Ja siis klientis, klient peab importima siis sellest jaavaks XML arbetseest staabi. See staab on siis selline üldine staab ja idee on, et seda saab lua siis sellise great proxy meetodiga sealt klassist. Ja et põhimõtteliselt kutsutakse välja sellest klassist, mis extendib siis seda remote. Kutsutakse välja selle remote classy meetod getHelloWorldIf port, getHelloWorldInterface port. Ja selle meetodi tulemus, siis saadakse see klas, mille kaudu saab meetodid välja kutsuda. Ja pärast seda kaastitakse see staab sellesse interfeisi, mida meil on soov, mille meetodid meile on soov välja kutsuda. Ja siis me saame lokaalselt nüüd selle klassi kaudu seda meetodid välja kutsuda. Ja kui meil tekib siis remote exception, siis me printime selle väljat. XMLRPC on palju lihtsam. Nüüd meil ei ole tegelikult enam vaja otsaselt midagi kaastida. Me tegeleme pigem XML-ide parsimidega. Seleks, et me saaksime XMLRPC kaudu välja kutsuda mingi meetodi, me lihtsalt peame õige struktuuriga XML saadma serverisse. Ja me XML-i sees ei ütle ainult, mis on selle meetodi argumentid, vaid me paneme ka selle meetodi nime. Nüüd me serverisse saadame, et me tahame välja kutsuda mingisuguse klassi mingisugust meetodid ja me anname sellised argumentid. Nüüd on see keerukamsest, me ei saa enam mitte metodid püütanis välja kutsuda. Me peame edastama mingisugus XML ja paneme selle meetodi nime argumentid XML-i. Me peame nüüd XML-ige parsima, aga nüüd on ta palju üldisem, et me saame põhimõttel XML-i panna kõik, mis vajalik on. Me saadame serverisse, et me saadame kutsu välja see meetod ja neid argumentidiga. Aga see lähene liigub natuke arpeetseest kaugemale, sest me enam ei tegele lokaase meetodi välja kutsumisega. Vaid me pigem defineerime sõnumi ja ütleme, et selle sõnumi saadame serverisse, et me tegeleme sõnumi edastamisega mõnesmõttes. Aga see sõnum on nagu spetsifikatsioon selle, et mis meetodid me välja kutsume, mis me tegelemme sõnumi. Aga see läheb nüüd kaugemale nüüd nüüd tüübitud progameerimisest, et me teame täpselt, mis on välja tüübit. Aga need tüüpid info panaks ja siis XML sisse, et meil on lihtsalt parametrit, aga meil on üks parameter. Selle on välju ja välju on integer 4 tüüpi, nii et on teatud pikku, aga integer, mis on, mida server peab olema võimene vastuvõtma selle meetodi sisendina. Ja kui meil on siin palet nimed, et siis välju asena on midagi muud, siis me saame servers terrori, et see meetod ei võta selle. Et selle meetodi mingisugune sisend on puudu. Ja vastus näeb saa sugunne välja, et me saame vastuseks näiteks sellis, et kui meil on method getStateName, mille id on 40, siis anvepaisis on 40. state nimis autakoda ja selline välja on, et meie tarkvara peab samuti paletnud. Ja peab aru saama, et see välja kutse või see tule, et see, et ikkse välja, mida me tagasame, on siis seotud selle eelmise päringuga. Ja see läheb natuke apide suunas mõnes mõttes. Kus seda kasutatakse? Ma näitan hiljajame Jason RBC näiteena, et kus see praegusel kasutuses on. Jason RBC teutab täpselt saamoodi, et ikkse mäljas me kasutame lihtsalt Jasonid. Nii et on selle kerge kaalukam RBC, et me ei tegele nii väga enam kliendist tüukaste genereeerimisega, serveri genereeerimisega, ma ei pigem nagu see on nagu sõnumite vahetus, aga sõnumite vahetuse eesmärk on kutsuda välja method serveris. Ja see näeb välja umbes selin, et kui me tahame välja kutsuda mingisugune, et me ei ole kutsuda, et umbes selin, et kui me tahame välja kutsuda mingisugust methodid substraktis, saadetakse Jason, mis sisaldab, et mis on selle methodi nimi substrakt, mis rbc-t me kasutame, et Jason RBC, mis on selle metodi parametrit, me võetakse sellest, mis on täpselt samad, mis metodi välja, kut seal oleks. Ja me paneme tihti kaas, et mis on see päringu ID, et kui me tuleb tagasi vastus, sama ID, kas me teame, et see on selle päringu vastus, nii-alt RBC päringu vastus. Ja väljundis on samud, et mis on see rbc protokolli versioon, mis on see päringu ID, mille vastus on ja mis oli siis result, mis oli selle metodi tulemus. Ja see metodi tulemus peab olema, et Jason ei nad kodeeritav, võib teoreeltiselt olega mingi base 64 kodeeritud, siis mingisuguna pikkem string või mingi pinaarsed väärtused ka näiteks, et me saame aga pildi painaristriimi võtta ja base 64 enkoodida ja panna see stringina põhimõtteliselt sisse, kui me väga tahaksime pilditeutluse teha, aga pilditeutluse sõnumite saadmist ei ole hea teha XMLi või JSONina. Kuigi seda on ajal olnistelt ka tehtud. Mul vist peaks olema üks keerukam näide järgmise slidil, mis siis näiteb, kuidas seda tänapäeval päriselt ka kasutatakse, aga siin võib olnud, et tulemus on saadatakse meile opis erroor, et metodi väljakutsa ei õnestund, kuna on puudu second teene argument sellele päringul, ehk meie, kui me unustame ära substrakti metodi kutsam välja, unustame teist väärtust 23. et siis 42 minus mida, et meil teist väärtus sellel parametrite listisei on, et siis saame erroori, et teine väärtus on puudu. Ja siin on üks näide selle kohta, kuidas seda JSONRPC kasutatakse selliste blockchainide valdkonnas või enda blockchain-appide valdkonnas. Et siin on üks JSONRPC näide, et kuidas küsida, palju transaksioon maksma läheks Ethereumi võrgus, et palju Ethereumi kaasi maksaks mingisugna transaksioon enne, kui seda välja kutsuda, et siis saab saata selle transaksiooninfo, et kui te saadate mingi päringu siit siia, siis saad ja mis on see etke kaas, kui palju trikaasi on, mis on etkev kaasi hindvist ja kui saadate mingisugna sellise data, siis mis see maksma läheks, siis arvet, et see ka autu vastatakse teile, et see reanne hind, mis see praegu siis maksaks. Ja siin on ka, et mis on selle päringu idee, tihti seastatakse see päringu idee konkreetsse kliendiga, et see ole globalne idee vaid selle kliendi 67 päring ja vastus tuleb siis ka, et see vastus on siis selle kliendi 67 päringu vastus ja et mis see vastus on ka oleks. Ma räägin järgune nädal natuke rohkem sellest, et mis on siis RPC-appide vahe, peamine appi ja RPC-de vahe on tegelikult see, et me võime siin panna nagu põhimus, üks kõik, mis meetodi nime, kui haatete peapides tavalselt panaks sa paika, et mis meetodid on lupatud ja kasutatakse pigem, et mis resursi peal me selle meetodi väljakutsume, aga tegelikult see lähene mene on ka väga sõupi, sõup appide protokollis harane, millest me ka järgmine näda räägima. Üks, mis on väga populaarseks hiljuti saanud sellest haatete peapide asendusena, on ka RPC stilis GRPC, mis on loodud projektina pilve põhiste süsteemide foundationi poolt, Cloud Native Computing Foundation, mille raames on ka näiteks kuberneetees, mille raames on dockeri imageid kasutamine nagu konteineristandardina, ja kus on väga palju sellist mitte otsest standardiseerimist vaga selline arendajate best practiceite paika paneme, et mida võiks kasutada tulevikus selleks, et teha süsteemid, mis oleks võimaliselt ka leerima ja tõrkeda aluvalt looma. GRPC üks eesmärk on asendada mikrodeenuste haeusessteemide komponentide vahel tavalisi appi liidesed nagu Http appisid või Soap appisid ja RESTi, et on disainitud efektiisemaks, kui tava veepis kasutatud olev Http ja REST appide. Võib-olla ma natuke liiga palju räägin ette, aga kuna see on otsestelte RPC-ga seotud, siis ma räägin ka sellest, et see tegelikult kasutab täpselt sama Http protokollega kasutab uuemat versiooni, milles on sisse eitatud sellised natuke uued featureid selleks, et saaks paremine anmeid vahetada real ajas ja ei piaks nii palju üksikult päringud saadma serverile, et uusi anmeid küsida. Ja kasutab seda Google-i protokoll pufferid Chession XML asemel, et ei edastada enam nagu pinaaselt kodeeritud stringe ja sellised väga paljude selliste võtmeväärtustega väärtusi, et sellasemmel, et edastada selline string, kus on need võtmed ja igasust komad ja sulud, siis tegelikult, kui on ette teada, mis struktuuriga see oleks, siis me saaksime ainult edastada väärtused, pinaaselt kodeeritud ja eraldatak eraldatud, aga me saaksime välja jätta kõik muu anmed, mida tegelikult meil vaja ei ole, et kui me teame selle Chession struktuuri või noh, me teame, et mis on parametrit järjekord, meil on palju efektiisemalt võimalik need anmeid tegelikult edastada servelite vahel ja see liikluse maht on väiksem puhtalt selle tõttu, et me enam ei saada neid XML ja Chessioniga seotud igasugused kasvenid igasugud muid märke. Et tal on selle tõttukas kompaktsem pinaarnaanme salestus, kiirem parsimine, sest me ei tegele enam XML ja Chessioni teksti põhise, regekside põhise parsimisega kasutada väga paljudes programeerimes keltes, kuna nad on nende jaoks teinud liidesed ja ta on optimeeritud just selleks, et automaased genereerida nii klendi kui server klasse ja põhimised ta on disainitud mitte selleks, et välis maailmas serveriga ühendust võtta, et ei ole see, et klient võtab browserist ühendust ja ta paks gRPC-t rääkima. Et selleks ta ei ole mõeldud, et on ikkagi nägemus, et klendid oma browserist kasutavad täpselt sama Http üks punkt ühtem, mida teie browser räägib, kui ta serveri ühendust võtab, aga pärast sellist frontendi või sellist esimest mikro teenust, mikro teenuste vahelne suhtlus kasutaks efektiisemat suhtlust gRPC kaudu või kasutaks sellist tava Http appisid, et üks teise metodeid väljakutsuda. Et ta on just disainitud hajusüsteemide sõlmede vaheliseks suhtluseks, mitteni väga klentide hajusüsteemi vaheliseks suhtluseks. Ja siis need mikro teenused vahelisüsteemide komponentid, mis töötavad serveritena, nemad pakuvad gRPC-serverid ja lubavad siis enda lokaased metodeid sest selle gRPC kaudu väljakutsuda ja osa mikro teenused, mis isedevad ka päringud, nemad on siis gRPC klientid ja gRPC serverid, kui teised klientid siis nende mingisugust metodeid väljakutsuvad. Ja see on siis efektiivsem, kui selline puhas XML-i või JSON-i põhine RPC, kuna anme mahude väiksemad ja ta toetab sellist anmete striimimist, mis on üks peamine põhjuseid, miks ta on kasvatusluvajatud. Selline tavalne RPC on sellise mudelina, et me kutsume välja metodi ja me saame tulemuse tagasi ja kui me lauama kümmekorda metodid väljakutsutasime, kutsume välja kümmekorda, saadame kümme päringud, saame kümme vastust. Mida see HTTP version 2 lubab ja mida see gRPC lubab on, klient võib öelda, et ma sooviksin kuhulata mingisugust anmebaasi uusi, anna mulle anmebaasi mingisugust kirjed ja ma sooviksin jätkata kuhulata uusi kirjed, mis anmebaasi lisatakse, ühendu siia plaht ja siis server saadab iga kord, kui uus anmebaasi kirja lisatakse, saadab selle ühenduse kaudusis uued metodi tagasi, et me saame siis kutsuda välja mingisugust metodi, mis ei tagasta meile üks kord, vaid jääb tagastama striimina siis anmeid. Teine võimalus, et me on võime, et klient saadab siia servers näiteks kümme ekraani vaadet ja server saadab meile tagasi video, kus ta on need kümme ekraani vaadet kokku pannud, aga me ei pea need ekraani vaadet saadmas ühe päringud, me võime teha näiteks kümme päringud, et saata kümme ekraani vaadet või pilti ja siis lõpuks saame servered nagu ühe tulemuse tagasi, et on võimalik ka sellist mudelet täita. Või siis meil ongi võimalus jäta kahe hajusestemi komponentid vahel ühendus lahti, me saadame järjest päringud ja me ei oota vastusid, ma lihtsalt viskamme torusse uusi metodi väljakutsaid ja server töötab neid ja saadab tagasi meile meil metodi väljakutsaid tulemusi. Me pea uusi appi päringud tegema või teeme ühe päringu ja selle ühenduse kaudu saadame uusi sisendäid funksioonile. Me saame siis järjest uusi sisendäid sellele funksioonile saata ja me ei pea uuesti ühenduse loomist tegema ja siis server jätkab meile vastuste tagasi saadmist. Võimist, et ta on nagu websocket, kui tahate websocketid progameerind, aga mis on nagu hardtab appi teab puhul, ei ole väga uus tehnoloogia, aga gRPC toetab seda siis sellise appi te tasemel või rpc tasemel. Ja kui Jasoni mingisugune näite, Jason võtaks 81 paiti, siis gRPC sõnum, üks näite anad, võib võta peage 3x vähem ruumi lihtsalt selle vähem võrguliklust võrgumahtu. Ei, see ongi see, et kui meil on mingisugune, see on nagu keskminevõrdlus, nagu suvalse näitega, et ta võib umbes 2x-5x vähem võtta, aga see täiesti oleb sellest, et kui telt Jasoni on mingisugused ästi lühikised võtme nimed, et siis võib-olla ta ei võta kaks korda väksel, kui neid võtme nimed on nagu ühetähelised ja põhimesed teemaldab kõik mittevajalikud asjad nagu Jasonist ja proovib edastada ainult need anmed, mis muutuvad. Ja kodeeriteks sene pinaarsalt. No tegelikult Jason ka kodeeriteks pinaarsalt, see olnud tegaks aina pinanesteam, aga ikkagi see võtab, see on päris palju sellist lisa karakterid ja märke, mida tegelikult ei oleks vaja edastada iga Jasoniga. Ja siin on üks näide selle käa RBC kohta, et me saame tekita sellise protofili, mis defineerib, et mis on metodid ja mis on nende metodide sisendid ja väljundid ja mis on nende objektide, tüibid, mida ma edastame nagu sõnumitene. Me saame defineerida, et importida Google Prototype wrappers, kus on väga palju sellist baas tüüppe kirjeldatud, et kui me tahamme integeri saada, et kuidas ta integeri kirjeldatakse. Ja me saame defineerida, et meil on inventory service ja selle serviceil on kolm metodid, mis on RBC tüübi metodid, getItemByName, getItemByID ja getItem. Me defineerime, et mis on nende sisendiks. Sisendiks võib olla meie enda klas, näiteks item, item või items või siis võib olla Google Prototype, protobuf string value või Google Prototype, protobuf pool value või integer value või midagi muud. Ja et siis, kui me saadame string value, siis tagastatakse meile itemite list. Kui me saadame getItemByID ja saadame string value, kus see string on sa ID, siis tagastataks üks item. Ja add item on siis selle post metodid, et paneme uue objekte anme baasi ja tagastatakse meile pooliam välu, et kas see on nende. Ja kui meil on siis selline custom tüüp, et meil on item, me defineerime, et selle item on ID ja name. Ja kui on items, me defineerime, et meil on itemite list. Ja ma ostadesin määleta, mis item desk on, description. See on põhimõtteliselt kaks parametri, mis defineerivad, et kui meil on kuskilt binary string, siis mitu tükki saad lugeda vist. Et kui me saame tagasi väärtused, seal on kaks itemid, siis me võtame ja streamist proovime kahta seda tüüp asja lugeda. Me loome seda ühe string väärtuse, me loome seda ühe name väärtuse ja kuna meid on kaks, me loome ühe korral, loome veel. Ma olen Sarnast asja implementeerinud suur anmete töötluses, et ma pole sada protsentikindal, kas see on korrektne viis. Et siin ei ole nagu nende itemite listi, vaid see põhimise defineerib, et kui meil on puffer, siis mitu objekti seda pufferist lugeda. Aga me loome seda tüüpi objekti seda pufferist ja see objekti defineerib, et pufferist peab olema siis üks string tüüpi väärtus, üks string tüüpi väärtus. Ja tavalselt on seal defineeritud ka nende väärtuste eraldaja. Ja items lihtsalt ütleb, et mitu objekti on seal listis ja vist ühteb ka, kes selle mingisugune kirjeldus ka lisaks, et näiteks, mis tüüpis on, et ta on item või minega muud. Ja ta toetab siis näiteks jaavad, pyytonid, teisi keeli ka. Mis ongi enam vähem kõik. Ma olin natuke vähem slaide. Nii, et võib-olo ma saan midagi juurde rääkida, et ma ei teagi, miks nii kiiresti tänne läks. Et põhimõtteliselt järgmine kord, siis me räägime veel ühes sellisest hajus-anme suhtlusest, mis on hajussüsteevide speciifina, räägime natuke näha hajusobjektidest, et kudas need on kaug protseduuridest erinevad, siis lähme üle veepi-teenustele. Aga samuti räägime sellest, et kudas saab neid veepi-teenuste appisid, mis on ka siis soap või HATTP protokolliga, et kudas neid saab siis hajus. Vabandust, kas keegi saaks suumis öelda, et kui kaua see ühendus maas oli? 30 sekundid, jah. Ma umbes saan aru, et kuna sinna 5 tudenki talle esi jäänud, nad ei ole nagu äralend, et kuiaks pool tündis nad oleks tõenast lahkunud selleks aegs, et ma siis lootsin, et ta koha nagu ühendas. Aga ma loodan, et see salvestus ei lennud kõikki. Tavalliselt sinna internetiga probleeme ei tegi, et selline on uvitav olukord. Järgmene nädal siis hüppame nagu sellistest ajaloolistest hajussüsteemide teemadest natukene veepi-teenuste juurde üle ja räägime siis kudas neid kasutadeks selleks, et defineerida siis appisid. Kas siis saa moodi, et me defineerime appid, mida klendi rakendustest välja kutsutakse? Ma hüppan korraks selle visiooni peale. Kas siin vahel need appisid või ka siis nende hajussüsteemide komponentide vahel? Ja meie praktikumist tegelikult teeme saarnasid asju nagu siin, aga me ikkagi kasutame seda REST ja HATETP-appid mitte, GRBC praktikumides oma komponentide vahel ja seame üles oma rakendusega Azures ühes tuleviku praktikumis. Aga sellest nädalab praktikumis me kasutame rabitid edasi, veel ükskord ja järgmine nädal me enam rabitid ei kasuta, aga see kord kasutame rabitem-q-t, et siis ise üles sehitada JSON sõnumite põhine arpet see, niimoodi, et me kasutame rabitid kahe serveri vaheliseks ühenuduseks, me seame üles kaks püütam programmi, mis küll teiarvutist töödavad samas arvutis, et me ei paned neid serverist tööle, aga nad oma vahel kasutavad remote rabitid, et vahetada sõnumeid ja see sõnumeivahetus toimub umbes niimoodi, et meil on nüüd klient, kes soovib välja kutsuda arpets see metodid, näiteks arpets see, et õmba alla raamat ja otsi sõne sealt, ja me siis serveris implementeerime, et kuidas tõmata alla raamatud ja otsida sõnet sealt, ja klient siis saadab arpetsse sõnumi JSONi struktuuris, mis ütleb, et mis on metodi nimi, mida me soovime välja kutsuda ja mis on selle metodi argumentid, ja meie server hakkab kuulama teatud rabitmq järekorda ja sinna järekorda suunatakse need sõnumid, mille rootimisvõiti on selle metodi nimi ja see serverimplementatsioon, mis seda järekorda kuhu see rootimisvõiti kohal jõuab, siis temal on see implementatsioon, mis seda metodid oskab. Käivitada, nii et siis see serveri kood saab põhimõtteliselt JSON sõnumi, mis ütleb, et käivita otsi tõmba alla raamat ja otsi sõna ja ta teeb selle läbi ja siis ta publiseerib selle tulemuse tagasi rabitisse ja meie klient tegelikult ühendus ajal saab endale oma lokaase postkasti, kuhu server saab iljem rootida tagasi selle sõnumi ja klient saadab siis ühte exchangei, metodi väljakutse ja samal ajal kuulab üste järekorda, kuhu temale tagasi rootitevad sõnumid, siis jõuaad ringiga tagasi. See on see asynkroonne metodid ja väljakutsumine RPC modelis, kui ma selle implementeerime ise rabit ja püütaniga, aga see model on aesti lihtne, et seal midagi keerulist ei ole, et reaalisest elus me peaksime natuke rohkem implementeerima, et sa päriselt nagu tööle saaks üks kõik, mis metodid teaks, aga te saate nagu nägemuse sellest, et kuidas sa RPC, JSON RPC on implementeeritud, kunas sa tegelikult baas loogik on suur, et see on sellest, et see on sellest, et see on sellest, et see on sellest, et see on sellest, et see on sellest, et see on sellest, et see on sellest, et see on sellest, et see on sellest, et see on sellest, aga nüüd on suhtseud lihtne. Slaide pole. Aga õnneks ma väga palju slaidena ei kasutanud ka. Ma siis jagan ka zoomineid slaidid. Või mõtselt mõne oligi paar slaidi, kus ma rääksin lihtsalt sellest, mis on järgmises looingus ja järgmises praksis. Slaide näitega siis veebi lähelt saata allatamata näid. Aga lõpetamist tänakse sara, et oli natuke väiksem loo, enge ei läinud seekord üleaja ja arvasin, et ma selgitan, et näite natuke kauem, aga läks suusad kiiresti. Jah. See oleneb sellest veebi poest. Kui see on Amazon veebi poot, siis see on selline. Aga kui on mingisugun lokaalne Eesti veebi poot, siis ta on pigem monoliitne. Aga reaalselt, kui sul on ikkagi, ma ei tea, miljon kasutajad, kes Temus ööhendub ja asju ostab, siis sa nagu monoliitsa rakendusega väga hakkama ei saa. Et kui seal reaal ajal on ikkagi tohutud palju külastajad, siis sul on vaja nagu skaleeride lahendust ja selle asemel, et skaleeride kogu monoliitsad süsteemi koopjaten on tihti parem. Kui sa tead, et skaleerime näiteks orderite töötlust eraldi, kui product katalog töötlust, võib-olla siin tuleb tohutud palju kasutajad, aga siin on vähem, et me saame specialiseerida selle optimeerimisele, selle asemel, et proovida optimeerida kogu sellist suurst süsteemi. Jägame siis oma suuresüsteemi väikisseimateks mikroteenusteks. Me saame, et iga meeskond arendab oma mikroteenust näiteks. See on jaavas implementeeritud, see võib näiteks mingis teises keeles olla implementeeritud, näiteks ko programeerimeskeeles. Ja me saame ka kõiki eraldi skaleerida, nad töötad eraldi konteinerites ja oma vahel suhtlevad. Siin näites KRPC protokolli kaudu. Ei ole mitte mingisugust reglit. Kui sul on nägemus, et tulevikus ei saa ühe servega nii hakkama, et sa pead algus selle peal mõtlema, et kudas sa seda skaleerimes teed. Ja tänapäeval väga tihti võetakse mikroteenused kasutusale, selleks, et hiljem oleks lihtsam asju tükeldada, asju skaleerida, et sa ei pea ette vära mõtlema, et okei, no mul on monolid, seal on probleemid, et ma akan kasutama mõttes. Ja me saame kõik, et me saame kõik, et me saame kõik, et okei, no mul on monolid, seal on probleemid, et ma akan kasutama pool aastat selleks, et sa monolid väiksemadakse tükkideks designid. Tihti võetakse mikroteenused kohekasutusale, aga see ei pruuki kõige efektiivsema olla, et see võib alguses kallimaks minna. Et kui sa pead ühe virtual machine asemel mingit 16 konteinerid jooksutuma ja... Kui sa mikroteenust teed, siis ei saa. Kui sa ja, otsustada alguses monolidina ja implementeerida, siis saad. See ei ole, et see pole vahetas ja pohalik, kui ei ole see kogu. Jah, nagu virtual machine või serveri mõttes jah, aga konteeneri mõttes mitte, et see on väga halb praktika panna liiga palju asju ühe konteenere sisse. Konteeneres võiks olla üks peamine protsas, mis jookseb ja kõik. Üks Flask server, üks Fast API server ja kõik. Et kui sul on kolm mikroteenust, siis nad tavast jooksevad kolme protsasina ja siis sa ei tohiks väga ühte konteenerse panna kokku. Ja see on halb praktika, kui sa proovid näid ühte konteenerse kokku panna. Sest nad kõik kirutavad erineva striimi logisid näiteks, siis on kõik logid koos. Nad kõik üks jookseb kokku võib terve konteener kokku joosta. Et neid vältida siis tee üks virtual machine ja pane sinna mitu konteenerd sisse. Ja see palju parem seda arendada ja administreerida, kui nad on eraldi konteenerdas. Isegi konteenere ehitamine on sul palju lihtsam, kui sa ei pea mõtlam veel, et mis järekonnastat protsasid peakse selle konteenere. Sest jooksemad sa pigem ütle neid samu asju nagu väljaspol konteenerd panat paikad. Aga muidu idee on küll see sama täpselt jah, et panat üste virtual machine ja kõik kokku. Sest ta nii kaha kui vajadust ei ole, töötab ühes server ja ühes virtual machine. Aga tänan panen praegu ka suumi siis kinni.