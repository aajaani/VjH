 Tere tulemast siis kaheksandasse loengus webi teenustehäüsüsteemide arendusaines ja täna räägime siis virtualiseerimisest, mis on mõnesmõttes pilvetehnoloogia alus ja täiesti vajalik pilvetehnoloogia toimimiseoks. Ja räägime konteineritest, sest tihti ei ole mõistlik panna üles iga erineva rakenduseaks virtuaalmasin, et isoleerida rakendusest üksteisestest. Virtualiseerimine võtab omakorda resursse ja selleks, et hästi palju rakendusi samas füüsilises serveris jooksutada, siis tegelikult on parem kasutada kergema kaalulisemaid lahendusi kui virtuaalmasinad. Ja täna räägime siis natuke virtualiseerimisest. Räägime konteineritest ja räägime, mis on konteinerit ja virtualiseerimise erinevused. Räägime, kuidas konteinerid on implementeeritud, et vältida sellist riistvaralist või tarkvaralist virtualiseerimist. Siis on tegelikult kasutusest pikem tehnoloog, et isoleerida protsasse, kui virtualiseerime note. Räägime nimeruumidest ja C-krupidest ja falisisteemidest, mis on siis konteinerit alused. Ja räägime natuke konteinerite standardidest. Peamaselt tockerist, mis on muutunud selliseks mitte ametlikuks standardiks, aga de facto standardiks. Ja ainuke, mis tockeri selline olemus, mis on muutunud täiesti standardiks, on tockerfailid. Et kasutatakka üks kõik, mis teisid konteineriseerimise tarkvaral, siis tegelikult ikkagi kasutam tockerfailid konteineril tehitada. Ja räägime kas natuke konteineriseerimise elistest ja probleemidest luoingul lopus. Virtualiseerime on sellise arvuti, virtualise serveri loomine, mis suudab jooksutada oma suvalist operatsioonisisteemi. Niimoodi, et te saate minna pilve ja panna üles virtuaalmasina, kus on näiteks Centos või Rocky Linux või siis Windows Server või siis Ubuntu 24. Aga ei ole vahet, mis masinas ta reaalselt jookseb, et teie saate valida suvalist operatsioonisisteemi ja saate põhimõttelselt sellise virtuaalise serveri, kus saate sisselogida oma rakendust installeerida või siis näiteks Jupiter notebooki sinna installeerida ja kasutada ära seda mingite masinope rakenduste jooksutamiseks, et lood oma Python notebookid seal Jupiteris näiteks. Ja te ei oota seda kasuta näiteks operatsioonisisteemides, kus te saates üles VirtualBoxi oma arvutis, ja virtuaalboxi sees tekite virtuaalmasinad ja installeerisete need virtuaalmasinad täpselt, nagu te installeeriksite ütleme operatsioonisisteemi suvalise arvuti peal. Aga tihti, kui tähes pilvest tegelikult pigem toimub nagu te ka elmisest praksis nägid, et te valib te nime kirjast endale sopiva operatsioonisisteemi ja teile valmistateks ette sellide virtuaalne masinad. Te saate tegelikult nii Amazonis, kui Azures ka ise ette valmistada virtuaalmasinad image'aid, et te ei peha alati valima just nende seast, mis on nagu seal olemased. Tihti pakutakse teile ka võimalasse ise ette valmistada. Aga põhimest, et mis seal taustaks on, on lihtne koop ja filesisteemist. Kui tähes protsest toimub, et te installeerite täpselt nagu VirtualBoxi installeerit operatsioonisisteemi kuskile kettale, ja kui te teete selles kettas koop ja saate seda koop, et kasustada uute virtuaalmasinate loomiseks, väga palju töötab ilmadi virtuaalmasinate ketasta koopjate liigutamise või koopeerimise või pack-upimise teel. Aga selleks, et me saaksime määrata, et kui suur on see virtuaalmasin, selleks, et me saaksime juoksutada paljusid virtuaalmasinad sama serveri peal, meil tuleb piirata, et ku palju filesisteemi, ku palju CPU tuumasid, tuleb pole isegi rangevalt mitte terve CPU tuum, vaid mingi protsent sellest CPU tuumast. Kui me räägime, et me saame 50% CPU tuumast, mida see tegelikult tähendab, see tavas tehenab seda, et CPU tuum on kasutatav sisteemis ja see virtuaalmasin saab endale 50% sellest protsessori ajast, mis on alokeeritud ühele et CPU tuumale. 50% ajast meie virtuaalmasin kasutab ära siis justi CPU tuuma, et alokeerida vähem, kui terve et CPU tuuma. Virtuaalmasinatele seadistateks ka RAM, teaks eraldi virtuaalne võrgukaart, mis põhimised konfigureerib, et mis ympärsuunamised võrgutasemel kasutatakse, et sinna virtuaalmasina andsunat, et saab igal võrgukaarditasemel defineerida oma tulemyri reeglid ja rootida andmed, et kui andmed tulevad, siis teatud virtuaalmasin IP-adressile, et siis suunatakse need sellesse võrgukaart, kus on see IP-adresse ja IP-võrg konfigureeritud. Üldjuhul me vaatame seda, et me saame ühe riistvora seadme, kühe serveri, resursid jagada paljudi virtuaalsate serverite vahel. Kui me vastupidist tavast ei tehta, et me ei kombineeri mitud füüsilist serverid üheks suureks virtuaalmasinaks, et seda tavasti kutsute virtuaaliseerimiseks, et pigem käib jutse siis kas klastrite loomisest või sellistest, ütleme, superarvutitest, aga tavasti ei loeta seda virtuaaliseerimiseks. Kuigi me võime luua virtuaalsed file-süsteeme, kus üks file-süsteeme on üle hästi paljude ketaste ja need ketad võivad asuda võrgus, nii et on võimalik luua virtuaalsed võrguketaid, mis on petapaid suur, näiteks. Võrguketa file-süsteeme kasutada selleks, et luua virtuaalsed file-süsteeme, et see on suurselt tavalnega tavasti ei looda, näiteks virtuaalsed masinaid, milles rohkem tuumasid kui ühel riistvoraalisel serveril. Ja virtuaalmasinad võimalde, et pakkuda siis rakenduste aaks turvalist kohandada nii isoleeritud keskonda. Ja see on just sellest pilve vaatevinklist, et just me pilvest tahame pakkuda, et kui me oleme pilveteenuspakkuja, et meil on palju kliente ja me paneme kahe klendi rakenduse samasse füüsilis serverisse, siis me tegelikult tahame karanteerida, et üks klient ei saaks mõjutuda, teise klienti ei saaks sisse häkida või siis, kui hakkab mingisuguse probleeme tekimad, neil ühe rakendus võetakse üle häkerete poold, et see kuidagi ei saaks levida teiste rakenduste peale, ei saaks teisi rakendusi mõjuta, et siis on tegelikult väga tähtis, et oleks võimalik sellist pakkuda turvalist kohendatavad ja isoleeritud keskonda. Ja meil on ka hea, et me saaksime lihtsalt ühes riistvoraalisel serveris jooksutada erinevaid operatsioonisüsteeme ükstise kõrval. Minna kui ma mainisin, et virtualiseerimise tehnoloogid on pilvetehnolooga aluseks ja väga lihtne visualiseerimine on see, et meil on mingisugune riistvora. Tänapäeval ei panda eraldi operatsioonisüsteemi selle riistvora peale, vaid jooksutatakse otsa hyperviisor või virtualiseerimise tarkkvara otsa riistvora peal, kus see hyperviisor või virtualiseerimise tarkkvara ise hoolitseb teile matalat aseme operatsioonisüsteemi funksionaalsustest, et näites, kuidas riistvora seadmik kasutada, paas seda Linux kernelid pakkuda ja muud sellised asjad hoolitseb hyperviisor ise, et meil ei ole eraldi Linux operatsioonisüsteemi siin maja. Mõnikõrd on Linux operatsioonisüsteemi kernel sinna hyperviisor osa, nii et hyperviisor mõnes mõttes võibki mängida ka esimised aseme operatsioonisüsteemi ja peale seda siis pannaks virtuaalmasinad jooksma selles masinas, kus iga virtuaalmasinada on oma operatsioonisüsteem ja siis iga operatsioonisüsteem me jooksadame kas ühe või rohkem rakendusi vastavalt sellel, et kuidas meie kasutajad, kes sinna virtuaalmasinad löid, otsustasid, et kas siin jooksutada näiteks kuberneetes, mille see on palju rakendusi või jooksutada siin üks püütan rakendusi ja teha väike virtuaalmasinad, see on põhimiseid pigem siis kasutajate ja otsustada, et kui palju rakendusi ühe virtuaalmasinad ees jooksad. Mis ka kasutajisa valib, et kui suurse operatsioonisüsteem, kui suurse virtuaalmasin on. Ja üks sellised puudusi virtuaaliseerimise puhul ongi, et kui me nüüd tahame 16 virtuaalmasinad siin jooksutada, siis meil on vaja 16 kooped operatsioonisüsteemist, nii et meil on vaja 16 näiteks Linux kernelid, 16 kooped kõikides failides, 16, mis iganes operatsioonisüsteemi teenused peavad jooksma, siis meil on vaja 16 kooped sellest jooksutada. Ja see on nagu resursside natukene raiskamine, mida proovibki siis konteneeriseerimine hiljem parandada, kui me sinna juhulame. Ja üldiselt virtuaaliseerimine võimalatab siis jooksatud virtuaalmasinad, tekitavad sellise virtuaalseid versioone resurssides, nagu kettad, võrgud, failisüsteemid, keskkonad ja nii edasi. Ja ühed sellised kõige laialtasemad kasutatavad lahendused on Xen ja KVM ja siis VMware. VMware on selline kallim ja proprietorilahendus, kus maks taks litsentsid eest ja tihti võib minna, võib juhtud, et VMware litsents maksab rohkem kui Ristvara ise. Eriti viimase laial, kui VMware on tõstnud litsentsi tasu, mida nad küsivad kasutatelt. Ja Xen ja KVM on pigemselt vabavaralised virtuaaliseerimist tarkkonad ja virtuaalboxi nagu päriselt kasutatakse pigemt avakasutat raames seda nagu serverit, et see ei kasutata väga. Kas hurakar virtuaalmasin, sa mõted virtuaalboxu? Et virtuaalbox pigemt avakasutatelt kasutavad, et ta ei ole nii efektiivne, et pigem kasutatakse Xen nii KVM serverites ja oma arutis oleks ka parem kasutatada otsa näiteks Vcelli või Hyper-V, et jooksatad virtuaalmasinad, et need on palju efektiivsemat. Ma räägin ka sellest, mis virtuaaliseerimise tüübid on, aga virtuaalbox põhimõttel teab tarkvaralist virtuaaliseerimist ja ta ei ole väga efektiivne, kui Xen ja KVM ja teised on võimalis, et väga Ristvara põhist virtuaaliseerimist teha tegema, et ära kasutada neid funksionaalsuse, mis on Ristvara sisse eraihiidatud. Ma räägin ka sellest natuke hiljem. Seda jaastad tegelikult väga kunagi teagi, et näiteks Amazon, mida Amazon kasutab. Ma tean, et meil Hub et see kasutab peamiselt vist Xen nii või KVM-i või isegi mõlemad, kuna nad on vapavaralist, aga Amazon või Azure võivad toesti implementeerida oma, et teha seda efektiivsemaks. Kuigi nad ka võivad lihtsalt vapavaralist edasi arjendada, et nad ei pea täiesti oma nullist välja mõtlema. Aga need on väga laialdaset kasutuseks saanud serverite maailmas, kuna nad on ka efektiivsemad. Selles ainest ma ei räägi seda ajaluku, virtuaaliseerimise ajaluku, et pilvetehnoloogia ainest ma rääksin seda rohkem. Et seal on ka samm-sammulised uuendused, mis ajaka ja pilvetehnoloogia arendusega kaasas käisid, et kui teid uitab, saate natu kuurida nii virtuaaliseerimise ajaluku. Aga motivatsioon on siis see, et meil võibad olla serverid, et kui me sinna installeerime ühe rakenduse, siis terveserveri jõudluse võib-olla või resursid raiskem ära, et parem on panna ühte serverse mitu virtuaalmasinat ja virtuaalmasinate suuruseid kohandada vastavalt vajadusele, et me saame riistvarab efektiisemalt ära kasutada, tükkeldada suure serveri väiksemateks tükkideks. Lihtsustab keskkondade ettevalmistamist, kohandamist rakenduste jaoks, et iga rakendus saab oma keskkonna, oma operatsioonisisteemi, oma komplekti teke, tarkko aramisel jookseb, et siis ei pea nagu hoolitsema sellest, et kuidas me siis hoolitsema, et keskkond toetab rakendust aad, peed, seeed ja teed, või et me saame iga rakenduse aks oma keskkonna teha. Keskkondi on ka lihtsam teiselta ja taas kasutata, kuna me saame virtuaalmasinast ketas lihtsalt teha koopia, selle koopi teise serverse liigutada või me saame ettevalmistada näiteks mingisuguse Postgres SQL ja aks vaeliku virtuaalmasinakeskkonna installeerida Postgres versiooni ja enne, kui me hakkame seda jooksutama teha selle koopia ja tulevikas iga kord, kui me järgmise 3 kuu jooksutama, on Postgres jooksutama, me võtame selle koopia nataka modifitseerime ja jooksutame selle, et me peab nullist asi ülesse jaotma, et me saame suhtselt lihtsalt koopa, et lihtsalt peab virtuaalmasinaketastest. Ja virtuaalmasinaketast koopa tegeminam piisav. Ei ole vaja mälust koopet teha, ei ole vaja nagu tihtisegi konfigurasioonist koopet teha, et meile tihti tõesti piisab ainult ketta koopa ja kõik. Teatad olukordad, et see ei prugid töötada ideaalselt näiteks Windowsi puhul, aga Linuxis piisab lihtsalt ketas koopa tegemiseks, et virtuaalmasin takkapida või seda mitte korda jooksutada. Ja lihtsaltub ka haldust, et kui meil on kõik rakenduse keskkond virtuaaliseeritud, siis me ei ole otsa seotud enam riistvaraga, et rakendus ei, enam ei sõltu riistvaratyübist, et näiteks, kas meil on teatud tüüpi ketta riistvara või teatud tüüpi võrgukaardid, et kõik on nagu nende lähenemine virtuaaliseeritud, et siis meil on lihtsam serveritest riistvara välja vahetada, kui mitte katki läheb ja virtuaalmasin ei prugi sellest väga midagi arugi saad, et seal riistvara taga taustal muutus. Et see võib jälle probleem ajatelne olla GPUda puhul ja Windowsi puhul, et GPU-t tihti tahavad väga GPU-spetsifilisi teek, et kui me vahetame välja Nvidia GPU serveris AMD GPU vastudist teie tarkvaränamlist, et ei tööta. Meil ka tudenkit, kui jooksutasid Nvidia masinope asju sinn haapetsees ja siis hakkasid Suome superarvutid kasutamas, nad pidid oma containerit, docker-containerit ümberheitama, kuna AMD tahtis teht, kui sa teek, ja mingid versioonid töötsid AMD peale, mingid versioonid töötsid Nvidia peale, siis tuli päris palju teek ja välja vahetada, et see tööle saada. Teatud olukordades, nagu 100% ei ole niimoodi. Teoreetselt küll, aga lihtsalt ei eksisteeri selliseid driverid GPU-teaks, mis oleks täiesti riistvara agnostilised. Neid lihtsalt ei eksisteer. Kõik GPU-driverid, mida te kasutate kuskil oma arvutis või kuberneeteses või kuskil on, need on väga GPU-spetsifiliselt, kuna GPU-te on nii kallid ja te tahtet nagu tohutult efektiivsalt seda jõudlust ära kasutada. Lihtsalt keegi ei ole ehitanud selliseid driverid, mis oleks täiesti riistvara agnostilised. Driver peab teadma, mis riistvirade kasutubetaab, et seda efektiivselt kasutada. Seda on lahendatud ketaste puhul, et alguselt ka ketavirtualiseerimises tehti ketastest. Iga ketajaks eraldi driverid, nüüd eksisteerib riistvara ketaste ja SSD-teaks. Tegelik ei ole sellist üldist virtuaalselt driverid, mida sa kasutada. Ei päris teadma, mis riistvara ketast on, et võib sellist välja vahetada, aga GPU-te puhul seda lihtsalt ei eksisteeri. Ei ole sellist üldist virtuaalselt driverid, mida saaks kasutada. Meil ka hapet sest inimene pidi ümper ehitama Nvidia kuberneetes driverid, et seda saaks kasutada dynaamilselt ja kuberneetes operaatoreid pidi ümper ehitama, et toetada mingit konkreetselt version. Yks sellised suuripõhjus, et miks teie ka võiksete kasutada virtuaaliseerimist isegi, kui te ei ole plaanis nagu pilve pakkuda, või mida sellist. Turvalliselsest rakendusisab isoleerida ükstööselt, et kahes erinas virtuaalmasinas jooksid rakendus, et neil on palju raskem mõjutada. Eritikude panate virtuaalmasinalle paik ka rangel, et kuidagi palju resurss on, nad võidad kasutada. On palju range misoleerimine, sest põhimõtteliselt, kui rakendusid jooksid samas virtuaalmasinas, kui ühel rakenduses onnestab kuidagi saada root õigus, et nad saavad samas operatsioonisisteemis teha peagi kõike. Aga kui on kaks rakendusid jooksib kaas operatsioonisisteemis, isegi ühel on root õigus, ta ei saa midagi teise operatsioonisisteemi ligipääsu selle tõttu, et ta kui tegab õigusest saada, või õigusest saada mingi kernele bugisid kasutada, et kuna kõik need operatsioonisisteemi anmestruktuurid on erinevad, siis lihtsalt ei õinestu neid ükst eest mõjutada nii hästi. Palju keruisemal häkida teise virtuaalmasinasisse. Et on parem turvalisest, et ta ei ole turvaline, et kuna midagi ole 100% turvalina. Seda teile võib-olla ka räägid operatsioonisisteemid ainas, et kui me viitame host serverile või host masinale või võrstatale masinale, siis on see peamine server, mis jooksutab virtuaalmasinad. Võib-olla siin on koom operatsioonisisteem. Kui me räägime kest virtuaalmasinad, siis on need külaliseid, mis jooksevad selles suuremas masinaset. Meil on siin kolm kest operatsioonisisteeme või külalist ja üks selline hostia. Ja siis lisaks on meil hypervisor, kes hoolitseb selle virtualiseerimise ja virtuaalmasinata loomisest. Teatud olukordades ta hoolitseb ka tõlkimisest. Aga see natuke olemeb, et kui tarkvaralne see virtuaaliseerimine on. Mida ma mõtlen tõlkimises all on siin, et meil on rakendus. Me sellele operatsioonisisteemil on teatud mäluala, näiteks kolm gigabaiti mäluruumi, mida võib kasutada mäluna. Kui nüüd rakendus ütleb, et ma soovim mingid mäluaadressi kasutada, et on meid salvestada, siis see mäluaadressid kehtivad selle virtuaalmasinasees. Ja neid tihti tuleb tõlkida välise Ristvara mäluaadressideni. Ja siis tavaselt toimuvad siin tõlkimised, et kui siin rakendus kirjutab mäluala, et miljon, ide, miljon midagi, siis siin võib sa olla kaheksa miljonid seide jalati iga CBO operatsiooni puhul, mis tehaaks, see tuleb tõlkida. Mäluaadresse tuleb tõlkida mingid muid aadresse olguse, olguse siis kas processide aadressid, mäluaadressid, et kõik tuleb reaalaes mõnesmats tõlkida. Varasemalt tehti seda Tarkvaras, VirtualBox ka teb seda Tarkvaras, aga täna palju eksisteerivad ka Ristvarad asemele eraldi kiibid, mis tegelevad näiteks virtuaalmasinate aadresside tõlkimisega. CPU, protsessor enaajal peaks sellelegi isetegelema ja saaks kiiremini virtuaaliseerida. Selleiselt speciaalselt virtuaaliseerimiseks mõeldud kiibid ka eksisteerivad täna päeval emaplaatide ja protsessorite juures, mis kirrendavad virtuaalmasinate jooksutamistese. Ja monitorib ka virtuaalmasinade, kas nad jooksevad ja panem nad uuesti jooksma, kui nad tead jooksma, et ma jääma näiteks. Ja Hypervisor ongisesse virtuaaliseerimise Tarkvara, mis võimaldeb sama aegselt kävitada jooksutade virtuaalmasinad. Ta on nagu selline Tarkvara, mis on siis puhimised väga palju õigused, et kui teil virtuaalbox jookseb teie masinas, siis tal on õigused näiteks ümber konfigureerida teie masina virtuaalsseid võrgukaardtet. Et näid võrgukaardid luoks väljaspol virtuaalmasinad, et ei tekitada virtuaalvõrgukaard teie virtuaalmasina sees, vaid luoks väljaspol nii, et virtuaaliseeritad alati peab olema rohkem õiguseid, et teie masinas asju ümber konfigureerida, näiteks kas või selleks, et ruutida serverisse sisse tulevaid pakete teatud virtuaalmasina võrgukaardile ja siis virtuaalmasin saaks võrgupaketid kätte. Ja oleneb virtuaaliseeriat ja hypervisorete tüüpist võib neil olla palju rohkem õigused, kui teie Windowsi operatsioonisisteemilad. Kui teil on ülikooli süle arvuti, mitu virtuaalmasinad teil jookseb praeguselas. Kas kellegil jookseb nüüd? Tänapäeval tegelikult võibki vaadata nagu uusi arvuteid niimoodi, et teil jookseb pähamad üks virtuaalmasi, mis on teie Windows. Põhimõttel, kui te jooksutad Linuxi operatsioonisisteemi virtuaalmasina, siis ta jookse enam teil Windowsi sees, ta jookse selle Windowsi kõrval. Windows Subsystem for Linux või Hyper-V saavad panna virtuaalmasinad jooksma teie Windowsi kõrval. Nii et nad ei enam eksisteeri seda, et teil on Windows, siis ta on VirtualBox ja siin on VirtualBox virtuaaliseerib teie Windowsi nüüd sees uut virtuaalmasinad, vaid näid jooksevad pigem nagu kõrval. Ja võib isegi vaadata, et tegelikult see Windows ise jookseb ka nagu tuhimõttel virtuaalmasinana Riftvara platformil, kus Riftvara platform teie üle arvuti. Ja selled ötate saate sama laajal jooksutada neid ükstese kõrval ja palju efektiisem, kui VirtualBoxi kaudu virtuaalmasinata jooksutamine. Ja hypervisorit jaoks ongi siis kaks tüüpi. Tüüp üks on see, mida ma ka visuaaliseerin enne, et kus ma jooksutame nagu hypervisorid otsi Riftvara peal, et ma isegi installeeri operatsioonisüsteemi, ma installeerime otsi hypervisori siis Riftvara peal ja ta mõnesmõttes asendabki operatsioonisüsteemi täiest ära, võtab endale kõik need operatsioonisüsteemi kohustused ja funksionaalsused. Ja tüüp kaks on siis pigem VirtualBoxi tüüp, kus me installeerime näiteks Windowsi, Windowsi sees installeerime hypervisori ja siis hypervisor virtualiseerib ja jooksutab virtuaalmasinaid, siis olidseb ise selle virtualiseerimiseest. Ja üldjuhul on tüüp üks on rohkem efektiivne kui tüüp kaks ja peamine üks peamine põhiselt ka, et meil ei ole vaja eraldi operatsioonisüsteemi, et meil on selline minimaalne operatsioonisüsteemi, mida hypervisor ise nagu implementeerib. Tüüp üks jooksebki siis otsa. Riistvara peal suhteleb ise otsa Riistvara pool pakutud keeltega ja appidega ja tuntud ka, kui selline põline või neiti virtuaalmasin virtualiseerimistarkkvara, mis ja näiteda näiteks ksen osaliselt KVM, kui KVM on mõneselt mõlemad tüüpi VMware, ESX ja Microsoft Hyper-V. KVM on ka siis põhimõtteliselt otsa ja Riistvara jookseb virtualiseerimistarkkvara. Teine tüüp on siis see, mis vajab operatsioonisüsteemi tukevirtualiseerida ja siin on samuti KVM, aga KVM on mõlemas, kuna KVM on selles mõttes natuke huvitav, et ta võtab üle kül Linux operatsioonisüsteemi, aga ta kasutab ise Linux-it. Ta põhimõtteliselt muudab Linux-i kernele ümber virtualiseerijaks või hyperviisoriks. Ta lihtsalt aktiveerib teadud modulid lisaks ja ta ei nõua eraldi nullist ehitatud hyperviisorit, vaid pigem augmentib selle Linux-i kernele hyperviisoriks. Ta on selles mõttes natuke mugavam, sest saab kõiki Linux-i võimalise featureid ära kasutada, et Linux-i arvutid hallata ja siis võimalta taga virtualiseerimist juurda. Aga teist tüüpi virtualiseerijad vajavad operatsioonisüsteemid tuge. Nad jooksevad kõrgemad õigustes kui tavaprogrammid, aga nad on põhimõtteliselt selle operatsioonisüsteemi sisemised tavaprogrammid, mille on lihtsalt rohkem õiguseid. Ja teamine eelis on, et nad neil on lihtsam emuleerida teisi arhitektuur, et üld juhul nad saavad näiteks 64-pitises süsteemis ilusti virtualiseerida 32-pittisüsteeme või virtualiseerida arm-süsteeme või te saate näiteks Linux-i masinas virtualiseerida näiteks arm-operasioonisüsteeme või arv. Rasperi operatsioonisüsteemid saate rasperilaadseid väikseid virtuaalmasinad jooksutada, aga see on ka sellete ota, et nad pigem emuleerivad seda virtuaalmasinad. Ja tihti seda nimetadaks ka hostitud virtualiseerijaks, et me jooksutame seda virtualiseerijad siis operatsioonisüsteemi sees, et ta ei võta serverid või Ristvara ülevaid, ta on lihtsalt üks rakendus selle serveri sees. Ja see vahe on võib-palseliselt selin, et meil on type 1, mis on siis virtuaalboxi sarane ja type 2, mis on siis Hyper-V või Xen-i sarane, kus meil on type 1. Me võtame Ristvara sinna peale, installeerime näiteks Linux-i, sinna installeerime. Nüüd mulleks lähtaka valesti vist jäädse, kus mul jäi. Type 2 on siis virtuaalboxi sarane ja type 1 on siis Xen-i ja Hyper-V sarane, et kus type 2, me peame mingisoks operatsioonisüsteemi installeerima Ristvara peale enne, kui me Hyper-V sori installeerime. Ja me tavasad jooksutame osarakendusi siis väljas pooseta hypervisorit. Meil on hypervisor põhimselt samalt asemel, kus mõne teised rakendused, mis jooksevad, aga type 1-püle on, me paneme Ristvara peale Otsa Hypervisori ja kõik muud rakendused jooksevad mingisugus virtuaalmasinas ees. Et te võite vaadad, et kui teil on siin Hyper-V teie arvutis, siis jookseb Windows ka põhimselt virtuaalmasinana ja teie rakendused jooksevad Windowsi virtuaalmasinas. Ja kui te vese selli kaud installeerite u-buntu, siis teie u-buntu jookseb kõrval teie Windowsile ja u-buntus isemist rakendused on siis teises virtuaalmasinas. Aga põhimselt Ristvara poolt vaadates ei ole see Windows nagu see peamine operatsioonisisteem, vaid se hypervisor on see peamine operatsioonisisteem, kellel on siis kõige rohkem õiguseid nagu selles masinas. Ja see on efektiivsem, kuna meil ei ole vaja eraldi operatsioonisisteemi kihti ja meil ei ole nagu mõnesmõttes lubatud siis jooksutada rakendusi hypervisori kõrval, et hypervisor on nagu selline kõige rohkem õigusi oma system selles serveris. Ja meil on võimalik teha mitmed tüüpi virtualliseerimisi, et me saame teha täielik virtualliseerimist või sellist emuleerimist, kus me näiteks kõik virtualliseerimeid me ei kasuta ära Ristvara võimalusi virtuaalmasinat jooksutamisel ja need on kõige vanemat tüüpi virtualliseerijad. Need on ka virtuallbox on ka põhimõttel täielik virtualliseerija, et ta virtualliseerib põhimõttel kõike. Põhimõttel selles külalis operatsioonisisteemi jooksab selle virtualliseermisees, et tema tavas teie näegi, et virtuallmasin arvab, et ta on lihtsalt tavaline operatsioonisisteem ja jookseb nagu kuskil serveris, aga tema täiesti peidetakse ära, et on virtuallmasin. Tiihti tuleb ka CPU käske tölkida. Ja see on ka üks põhjus, miks sa pead teha emuleerimist erinevata arhitektuuridu vahel, et me põhimõttel tölkime kõik CPU käsud ühest arhitektuurist teise. Ja meil ei ole vaja Ristvara tuge üldse. Põhimõttel me saame virtualliseeride peaa üks kõik, mida me tahame, aga see on palju palju epaeffektiivsem, sest meil ükski rakens ei suhtle otse Ristvara seatmetega ja kõike tuleb nagu tölkida. Tuleb virtualliseerida ja selletuttu on üks aeglase moid. See on ka virtuallbox on seda tüüpi ja selletuttu ka virtuallbox on tihti aeglane eriti grafikakaartide kasutamise juures ja graafilist asjad võib tärks palju jõudlust vääda. Meil on võimalik teha ka para virtualliseerimist, kus me osa asju lubame minna ümber tölkimise ümber otse virtualliseerimised. Me saame isegi modifitseerida virtuallmasina sees jooksata operatsioonisisteemi, nii et me paneme teatud tarkkora virtuallmasina sisse jooksma, mis teab, et asjada on virtualliseeritud ja mis suhtleb otse virtualliseeri, aga näiteks see tihti kasutaks ka virtuallboxis, need kestad isjanid, kuhusab sisse panna tarkkora, et oleks võimalik näiteks USB seadmeid ülevõtta, et oleks võimalik teatud Ristvara otsa ära kasutada, nii et mõnesmõttes virtuallmasina ja virtuallbox on ka selline täielik virtualliseerija kui ka para virtualliseerimise näist tüüpi, et me modifitseerime seda virtuallmasina operatsioonisisteemi, paneme sinna teatud funksionaalsuse või tarkkora juurde, mis põhimõttes, et lubab meil mööda pääsada sellest täielikust virtualliseerimist ja teatud Ristvara otsa kasutada, et näiteks GPU-te jaoks pidi seda kasutama, et kui me tahame USB seadmeid ülevõtta ja et midagi keerulis, et teha, mida on raske otsa virtualliseerida, siis sinna implementeerime mingit lisadarkkora, mis proovib otsa Ristvara ka suhelda, mis on palju efektiisem kui täielik virtualliseerime. Aga tänapäevad pidem, pigem prooviteks teha Ristvara toetatud virtualliseerimist, et kui te keted, kui teil on kolm virtuallmasinad ja kõik tahavad kasutada, kõik tahavad kettale midagi kirutada, siis keegi peab otsustama, et mis järekorras operatsioonid kettastale kirutadakse, et kui meil on kolm virtuallmasinad, kes proovid täiel kiirusel kõik kettale kirutada, siis kusagil pead mingi protsess olam, kes planeerib, et kes saab ketta aega, aga selle asemel me saksime implementeerida virtuaalmasinad tev vahel järjekorrad Ristvara tasemel. Tänapäev ongi ketastel imod, et ketaste driverid või ketastel on sisse eitatud sellised järjekorrad, et nad saab automaalsalt tekitada eraldi ketta driveri või ketta Ristvara tasemel eraldi järjekorrad erinev, et virtuaalmasinad jaoks. Operatsioonisisteem põhimõtteselt ei pea ise hakkama planeerima, et millisel virtuaalmasina on lubatud kirutada, vaid kõik sisse tulalt päringud edastatakse ketta driverile, ja ketta driver sissemisel ise paneb erinatelt virtuaalmasinatelt tulnud operatsioonid erinatels järjekordadse ja planeerib ise, kui virtuaalmasinate vahel jagada ketta kirutamist. Et see outsorgetakse põhimõtteselt selline ketta planeerimine siis hyperviisorist või operatsioonisisteemist ketta driveril tasemel. Ja teene asimida ma näitasin on näiteks see mäluaadrasse tõlkimine, ka tänapäele on selline translation lookaside bufferid, mis on sellil, et chipid siis kas emaplaadil või prozessori juures, mille ainuke üle sanna ongi need mäluaadrasse tõlkida ja nüüd ei pea seda enam täieliku virtuaaliseerimise stiilist CPU tegemat, CPU ei pea real ajas virtuaalmasinada aadrasse tõlkima ümber päris füüsilisteks. Mäluaadrasse teks vaid seljaks on eraldi kiibid siis ja see paraliseerib seda, et samal ajal, kui CPU teab mingit operatsioone, instruksiooneid teav läbi, siis samal ajal saab teised chipid tegeleda siis nende mäluaadrasse tõlkimisega. Ja need on sellised ristora toetad virtuaaliseerimised, mida tihti tuleb ka teil näiteks bioses sissele üritada näiteks kas AMD-V AMD jaoks või Intel jaoks VTX, et teatud virtuaaliseerimist teile ei ole võimalik, näiteks teid saa Hyper-Vid kasutada enne, kui te selle bioses sissele üritatad, et see on lubatud teil, nii et need on midagi, mis tuleb tihti aktiveerida ja kuus kaheks sa kümme aasta tagasi pidi isega vaatama, et kui ma ostan protsessoriga, seal on VTX tehnoloogio olemas või mitte, et tänapäeval on kõikides protsessoritesse olemas, aga mingi kaheks ja kümme aasta tagasi oli et ainult osades protsessoritesse tugi olemas. Ja see on ka üks põhjus, miks pilvetehnoloogio virtuaaliseeriminid on rohkem, rohkem efektiiseks muutunud, et järjest rohkem Ristvaru on hakkanud toetama virtuaalmasinaid, et enam ei peaks peamisa arvutid, CPU, kõiki transleerimisi tegema järjekordasest haltama planeerima, et järjest rohkem on toodud Ristvaru tasemelle, et Ristvaru ise toetab virtuaaliseerimist. Ja see on ka üks põhjus, miks pilvetehnoloogid on efektiiseks muutnud ja see vajadus ongi tekinud sellest, et järjest rohkem on tavalne, et jooksutakse palju virtuaalmasinaid serveritest ja selledatuga serverite Ristvaru ja tavar Ristvaru siis on pidanud seda rohkem toetama. Ja näid järjekordad on tihti isoleeritud, nii et ka isegi Ristvaru tasemel karanteeritakse, et hoitakse need operatsioonid ükstisest eraldi ja saab isegi mõnesmõttes kaitsta Ristvaru tasemel, et üks virtuaalmasina ei saa teise virtuaalmasinaketta alale ligi või midagi sellist, et saab kaitsta erineades operatsioonisisteemides olevaid protsass üksteise eest, mitte ainult virtuaaliseeria või operatsioonisisteemi tasemel vaid isegi Ristvaru driverit ja Ristvaru kontrollerit tasemel. Aga üks puuduse virtuaaliseerimise puhul on ikkagi see, et kui meil on seda tüüpi virtuaaliseerimne, kus meil vaja operatsioonisisteeme, ja siis veel igale virtuaalmasina operatsioonisisteeme, siis igal juhul on meil vaja palju koopeid operatsioonisisteemidest. 16 rakenduse ja juoksutamiseks 16 eraldatud keskkonnas oleks meil vaja 16 operatsioonisisteemi juoksutada sama aegselt. Kõik need Linuxi kerneri, kõik need lisa Linuxi tenused peavad juoksma jääma ja võtavad resursse, võtavad mälu, kasutavad CPU'd ja see ei ole nii efektiivne, kui juoksutada 16 protsessis samarvuti peal ilma virtuaaliseerimesida. Aga kõvasti parem kui enne, et tänu Ristora toetatud virtuaaliseerimisele on see palju palju efektiivsem kui enne, aga ikkagi see ei ole ideaalne, et ikkagi tuleb natuke eeldatad virtuaaliseerimine, kasutab lisa resursse ja on võib teha aeglasamaks teatavad protsessid. On ka uued tüüpi ohud, et näiteks, kui meil onnestub juoksutada mingit pahalast või, ütleme rootkit niimoodi, et ta juoksagi meil ühegi operatsioonisisteemis ees, vaid juoksad virtuaalmasinana ja proovib ennast kärrapeita, et teised operatsioonisisteemid ei näed eda, kun nad listivad näiteks, mis on virtuaalmasinad VSL-is juoksavad. Siis võib juhtuda, et üheski operatsioonisisteemis sees juoksav rootkitid otsi ja ei leidasad üles. Võibki tekida olukord, kus kui on võimalik kärrapeita, et rootkit juoksab teise virtuaalmasinasees, siis seda ei prugi ollagi nii lihtne üles leida ja teatud tüüpi rootkitid võib selle totu olla raskemine leitavad. Aga üks põhjus, üks lahendus, mida me saame teha, et parandada efektiivsust sellised senaarimis, kus me sooveme kuute teist rakendust juoksudada samas serveris, ongi siis, et me virtuaaliseerimise asemel kasutame konteinerid. Kas keegi oskab seletada või öelda näiteks, mist teie arvates on virtuaaliseerimise ja konteineriseerimise vahe? T.K.A. kui ma jahan tead, aga kui ma virtuaaliseerimine, siis ma põe ikal eraldikoov. Aga fundamentalisemalt, mis on konteineriseerimise ja virtuaaliseerimise erinast. Kas konteineriseerimine on virtuaaliseerimine? Mis te arvate? Atsi, mida seda arvates, mida sa teha järgmikult tege? Jah, see on põhimust teige. Minul on natukse linnan ekstremisev arvamus, et ta ei ole virtuaaliseerimine. Näiteks mulle ei meeld, kui kusagil Wikipedia-sele kusagil kirjaldataks, et konteneiseerimine on õhukese virtuaaliseerimine. Ta on pigem nagu isoleerimine ja ta ei ole enam nii väga virtuaaliseerimist. Kuigi sellest on virtuaaliseerimist eriti võrguketaste tasemel, et tegelikult kasutatakse täpselt samasuguseid virtuaalseid võrguketaid Linux'is, kui virtuaalmasinete puhul. Osaliselt on täiesti vajelda, aga... ...saks võrguketaid ei juba tseksida, liga tseksida, saab suur ka võrguketa. Ta ei ole absoluutne mälururuma. ...selleks, et ise võib teeme teise üle, et oks otsuonist ei juba partab seda isele. Ia, aga kui sul näiteks konteneerisees jookse protsess, mille on ruud õigus, et väljaspol konteneeres, tema saab teha kõike. Tema saab teha teiste konteneere, mis ikäärast ta tahab. Võib aga virtuaalmasinete jookse protsess isa. Virtuaalmasinete väljaspool teisi protsess hallata, ei see kui tal on ruud õigus. Virtualiseerimise on täiesti ära isoleeritud, aga... ...ja, et protsess on vähem virtuaaliseeritud, kui konteneerise jookse protsess selles mõttes võib toesti nõustuda. Aga vaatame natuke rohkem enne, kui me näida samu asju uuesti võib-olla lõpupool arutame. Iga rakenduse jaoks ei ole mõt, et saada on üle oma virtuaalmasinete ja operatsioonisesteemid. Eriti, kui me on hästi väikse mikrotenuseid või nanofunktsioonid, kus meil on väike püütene funksioon, mida me tahame teatud ajal käivitada. Kron tööna näiteks. Siis miks me peaksime tekita mingi hiigel suure virtuaalmasina? Võisigi väikse virtuaalmasina, kus me paneme ühe kron töö jooksma öösel, kell kaks teistie, kas see virtuaalmasin peab siis 24 tundi jooksma selleks, et üks kord öösel jookseb. See on natuke ebamõistlik põhimõtsalt, aga täiesti tavaline muster, mida pidi tegema virtuaalmiseerimise ajal enne konteinerid. Konteinerid aitavad lihtsamini eraldada rakendused üks teisest, aga natuke nõrgema isoleerimisega, et tihti on raskem kontrollida, et ühes konteineri jookseb protsess ei saa teisi mõõtuda. Vissame pidi selle, et see on põõri. Jah, et palju raskem on panna virtuaalmasinates jooksvat protsesid. Ereemates virtuaalmasinates protsesi jooksema oma suhtlem, et see on palju raskem. Serveris, kui me kasutame konteinerid, siis serves on mingi minimaalne Linux operatsioonist teem võib-pol isegi ainult kernel ja kõik muu saab käivitada mingis vormis konteineride sees. Ja et mõnesmõttes harnaane siis virtuaalmiseerimisele, et me jooksatame kõiki konteineride sees, me ei pea, aga me saame. Ja see lihtsustab meil näiteks ka monoliisjates rakenduses liikuda hajusete mikro teenuste poole, sest me saame igale rakendusele või igale protsesse luua oma konteineri keskonna, kus on täiesti eraldi tegid, eraldi keskond saras virtuaalmasinatele, et me saame panna sinna ühele sisse püütanide, sille jaava kolmandele ruubi asjad ja täiesti hoida net fileid ükstiselt eraldi. Nii et server vajab kisest minimaalselt Linux operatsioonisiteemi ja muu asjad jooksat konteinerid, et mul on see lausevist millegus kahekorselt seal kirjutatud. Konteinerid on palju kerge kaalulisemad kui virtuaalmasinad. Ei ole tegelikult üldse raski jooksatada sadat konteinerid ühes Linux serveri, siis egini tuhandat oleneb sellest, kui palju on ülekattuvust keskondade vahel. Kui meil on 10 unikaalsed konteineri imidžid, siis võib-palju see ei ole väga võimalik, aga kui nad kasutad kõiki sama konteineri imidžid, siis see on pihti võimalik. Meil ei ole eraldi vaja hyperviisarid. Meil on vaja mingisugust konteinerid haldusrakendust, mis oskap konteinerid luua ja kustutada ja hallata, aga see otsi ei jooksuta konteinerid, see otsi ei virtuaaliseere midagi. Koguse isoleerimine ja virtuaaliseerimine on ehitatud operatsioonisüsteemi kerneli funksioonide põhiselt. Meil näid, et Stoker ise ei virtuaaliseeri mitte midagi. Ta on lihtsalt põhimised API, mille kaudume ütleme, et loome konteinerid ja Stoker võib-palju kutsub välja konteiner-dia-api, ja konteiner-dia-api kutsub välja mingi Linuxi süsteemi käsud, et konteinerid luua. Konteineri sisased protsesid on eraldatud üksteisest kasutades Linux nime-room, C-gruppe ja muid sellised Linux kerneli sisse eitatud võimalusi. Tavaliselt me saame, me ei pea, aga me saame konteineretele eraldada oma komplekti resurssidest, et kui teie kasutate Tokerit ja panete midagi jooksma, siis tegelikult defaulti nad osab ligi pääsu kõigile teie mälualale, kõigile teie CPU-dele, et kui te ei limiteeri, et palju mäluala võib kasutada või palju CPU-tumasi, et ta võib kasutada, siis defaultina ta võib kasutada kõike, nii et ihti on hea ära limiteerida, et ko palju ta võib kasutada. Konteinerit ülesseed on hästi lihtne, et kui konteiner image on valmis, siis selle jooksutamine võib võtta sekundeid aega, oleneb sellest, kas teie konteineri seest tuleb mingisugusi tegevusi teha, mingid filesystemi ümber kopeerida, mingisugusid kaustasid ette valmistada, et kõik see võib või ta aega, aga kui on lihtsalt processi jooksutamine ühe käsujooksutamine, et siis kui konteineri ei ole vaja ümber ehitada, ei ole konteineri pilti vaja pildida, ei ole vaja konteinerid allotamad, interetist siis konteineri käivitamine võib võtta ainult sekundid aega. Ja jõudlus on ligi lähedane serveri tavajõudlusele, suht vähevahet on sellest, kas te jooksutatate processi konteinerist väljaspol või konteineris seespol. Et see jõudlus võiks olla enam vähem sama, aga see olad jo oleneb, kas te panete mingi piirangud peale, et näiteks, kui piiratad kuid palju tuumad aega konteinerisjookse processi võib kasutada, siis ta on kindlasti aegelsem, aga see on steie piirangud ootbu aegelsem. Ja erinevad konteinerite raamistikud eksisteerivad, te tead toki tokerit palju, et toker oli üks esimesi populaarseid konteineriseerimise tarkvarasid, aga ta on ära standardiseeritud ja täna päeval toker enam ei ole nii väga konteineriseerimise tehnoloogia, ta on pige liides, mille kautu on mugav konteinerid luua, ta tihti nüüd sissemiseks kasutab näiteks täiesti teist tarkvarakonteinerid liid. Ja tokeri asemel kasutada otsa konteiner teed, ei pea enam tokerid kasutama, kui teil seda vajadust ei ole, tihti konteiner teed kasutadaks. Uperneeteses selle tõtta, et toker tegelikult enam ei ole täiesti, ta asuta tarkvara, et tokerid võib kasutada näiteks siis, kui te soovite teda õppetöösk kasutada või soovite oma hobi projektiaks kasutada, aga kui teie asutus kasuta profesionaalse tokerid, siis nüüd on licensid ja asutus peab mingist hetkes maksmakama sellest, et tokerid kasutatakse. Toker konteinerid implementeerimine on nagu pigem palju madalat aseme tegevus, kui lihtsalt tokeri jooksutamined. Näiteks LHC on Linux Containers LXC, mis on kernelid asemele virtualiseerimise metod, mis kasutab Linux kernels ja sisse ehitatud funksionaalsusi, et isoleerida konteineris jooksevad prosessid üksteisest ja kasutatakse Linuxi Nime Room ja C Group selleks, et seda teha ja teie võite Linux Nime Room ja C Group kasutada ilma konteineritada. Te võite tegelikult olevale prosessile või alustatavasse prosessi võimesed konfigureerida samat featureid, mis on konteineritas ilma, et te otsa konteinerid kasutada. Et Linux Nime Roomid ja C Groupid on kasutuses ka väljaspol konteinerid täpselt sama asja teaks. Mis on siis Nime Roomid? See on nagu prosesside, tabeli, filesystemide, gruppeerimine üksteisest eraldatud Nime Roomid, jah, et ühes Nime Roomis jooksevad prosessi ei näe teises Nime Roomis oleva prosessi resursse ja nad ei saaks nagu üksteist mõjutada ja üksteise mälu ola trasseerida, üksteise file kasutada, üksteist äratappa, et võimesed isoleerid prosessid üksteisest selleks operatsioonisisteemi anmestruktuurida tasemel. Järgine slaid vaatam, kuidas see töötab. Ja C Groupid on juba loodud Nime Roomile, siis kas CPU, mälu ola, ketta roomi ja teiste resursside piranguda panemine, et me saame seda looma näiteks looma sellel prosessile Nime Roomi ja siis jõuksame, et selles Nime Roomis, kus see prozess jookseb, on lubatud kasutada üks tuum ja 2 GB mälu. Ja siis üks kõik, mis prosessid selles Nime Roomi sees jooksevad, nende kogu maksimum resursside maht on vastavalt C Groupile, et saanab meile siis võimaluse täpselt virtuaalmasinate puhul öelda, et näiteks mingisugune Postgres Sunme baas, mis meie service jookseb, et tema ei saa rohkem kui 3 CPU tuuma ja rohkem kui 8 GB mälu kasutada, et te saate väga hästi prosessida või konteenete tasemel siis eraldada neile teatud arvresursse. Et kui nad mingil põhjus lakad proovid liiga palju kasutada, siis seda limiteeritaks ja neile rohkem mälu ja CPOa ega ei kasutada, et nad ei saa teisi rakendusi serveris mõjutuda. Ja konteinerid tegelikult ongi mõnesmõttes nagu selline liides nende ja plus lisafunktsionaalsuste peal, et oleks mugav prosesse panna jooksma sellistes eraldi nimeruumides ja näile resursse alokeerida. Lisaks nimeruumidele ja C-krupidele meil on ka konteenerite bildid, tocker imageid, kus me paneme kõik vajaliku tarkvara, mis on vaja vajalik selle prosessi jooksutamiseks ühte käivitatavasse musta kasti põhimõttel, et seal sees on siis tarkvara kood, kõik tegid, mis on vajalikud, kõik konfiguratsioonid, mis on vajalikud ja isegi se kirjutame selle käivituskäsu, et kudas see prosess käivitataks käsure käsuga, me paneme kõik selle konteeneri bildi sisse ja pärast seda meil on võimalik konteeneri bildi peale teha start. Ja kui me teeme konteeneri bildi peale start, siis tegid teda uus konteener selle konteeneri bildi põhjal, et see on täielik paket, et jooksutada mingid konteenerid. Lisaks nimeruumidele ja C-krupidele meil on vaja kihilisi failisest teeme, see on selled oot, et meil tihtime, maundime konteenerite sisse erinevad kaustasid fail, et konteenerite piltide sisse on mitmed kihid ja kui meil tekivad 6-8-10-15 kihdi, see on meil vaja kuiidagi loogiliselt see kihv teha kasutatavaks ühes Linux failisesteemi naa procesile, et procesi näeks kuhutades kihv, nad näeksid ühte loogilist Linux failisesteemi või uniks failisesteemi ja põhjimõtsed see on sellene kihiliselt failisesteemide union või mergemine üheks failisesteemiks. Lisaks turvaliselt seaks on meil vaja ka C-linuxid ja SECOMPi, kus C-linux piirab millised konteeneri failisest namespeisist väljaspoosed failid, portid, sisteemi teenused on kasutatavad proceside poolt, mis jooksevad nime ruumi sees, see tähendab seda, et me saame näiteks lubada procesil pandida porti 80 või kasutada kaustasid väljaspol virtuaal masinad, et procesidele oleks õigused välja kutsuda mingisuguseid teenuseid operatsioonisisteemi käske ja nii edasi väljaspol konteenerid ja SECOMP siis piirab täpselt just operatsioonisisteemi käske ja C-linux piirab pigem nagu sellised teenuseid ja resursse, võib-olla teenused on natuke valesana, pigem resursse nagu failid, portid ja nii edasi. Et mis süskool operatsioone siis konteeneres on lubatud välja kutsuda, et kas ta saab näiteks mingit failel uua väljaspol konteenerid. Konteenere pilt siis sisaldab rakenduse koodi, rakenduse käivitameks vaheliku keskonda, näiteks Python 3.7, vaheliku süsteemi, näiteks vket või kurli ja töökeskonda teke mingit Python tegid, konfiguratsiooni väärtusad, näiteks mis portid ta peaks kasutama, mis kasutanime ta kasutab, kas ta jookseb Ubuntu kasutajana, kas ta jookseb Grafana kasutajana, kuiigi Grafana kasutanimi tegelikult midagi ei tähenda väga, et ta lihtsalt ID-värtus, et see on juba. Ja mis on see käsg, mida jookseudutakse? Ja konteenere pilt saab siis kergesti teha koopjaid ja konteenere pilt on aina loetav, et konteenere sees jookseb protsess ei saa konteenere piltis midagi muutua, ta saab küll muudatuse teha, ka need muudatused tekivad kihina selle pildi pealet, pildi sees või selle pildi koopja sees, mida ühtegi fail ei muudeta, et kõik muudatused tekivad nagu uue kihina, et uuskiht ütleb näiteks fail kusud seda tera, uuskiht ütleb kusud seda jära, uuskiht ütleb kusud seda jära, uuskiht ütleb kusud seda jära, uuskiht ütleb kusud seda jära, uuskiht ütleb, et failis on nüüd uus sisu, uuskiht ütleb, et uus fail on lisaks või uus kaust on lisaks, et kõik tekivad nagu uute kihitina ja hiljem nagu mörgitakse se üheks loogiliseks failisüsteemist kokku. Mis on siis nimeruumid? Nimeruume võib seletada siis hästi listast niimoodi, et kui ma saadan näiteks mingisuguse firma kaevama kraavi ja ma ötlen tal, et kaevaku kraav riha 16 juures, siis kuhu läheb see firma? Kas ta läheb Tallinnasse või tartus riha 16 aadressil või läheb Pärnusse? Pärnus on ka riha 16 riha tänav. Ma arvan Tallinnasse võib pole ei eksisteeri riha tänav, ei ole pärnu tänav, aga põhimuselt, et kas riha tänav Tartus või riha tänav Tallinnas, et kudas firma teab, kus kaeva makata? Nimeruumid ongi täpselt samamõtted. Meil on Tartu nimeruum ja meil on Tallinnan nimeruum ja need aadressid sellest nimeruumis on täiesti erinevad asjad. Üks protses proovib konteineris. Ütleme, kui on protses 16 konteineris A, see ei ole samamist protses 16 konteineris B ja see ei ole samamist protses 16 operatsioonisüsteemi C. Kui meil on protses, mis jookseb konteineris ja tema proovib ära killida protsesi üks, siis see on alati protses üks konteinerisees ja ta ei saagi kunagi saata ühtegi käsku protsesile üks, teises konteineris või protses üks väljas pool, sest tema ei ole seda aadressid kuhu saata. Ja me saamegi jakada filesystemi, protsesid ja igasest muud nimed või aadressid operatsioonisüsteemid asemel eraldi nimeruumidesse ja niimoodi isoleerida protsesid kärnalil tasemel, et ühes nimeruumis olevat protsesid pääsad juurde ainult selles nimeruumides olevatele nimetele või aadressitele. Nimi nimelsi võib konkreese mõelda siis aadressid, et neideks file aadress, protsesi aadress, mäluaadress mis ikanes. Ja meil on erinevat nimeruumid, et kõige tavalse on protseside nimeruum, aga ka filesystemide nimeruum, võrgu nimeruum, et näiteks localhost mida tähendab. Localhost ühes konteineris, selle samamist localhost teises konteineris. Või näiteks mingisegi IP-aadress ühes konteineris ei prugu üldse olla samamist teine IP-aadress teises konteineris. Meil on ka tomeenite nimeruum näiteks, mida tähendab grafana.ut.ee. Ühes konteineris võib see tähendada üht asja, teises konteineris võib tähendada teist asja. Kasutate nimeruum. Meil on kõigis konteinerite sees olla kasutavu puntu. Aga mida tähendab puntu ühes nimeruumis ei ole sama, mida tähendab puntu kasuta teises nimeruumis. Lisaks on ka protseside vahelse suhtluse aadressid, et kuidas ma siis saadan protsesile kaks sõnumeid või protses kaks, protsesel kolm, et ka kogu see suhtluse aadresside nimeruumide vahelse. Selles võib olla natuke raska aru saada, kui ta jääb sellise abstraktiaks. Vaatame näiteid, et protseside nimeruumid on sellised, et meil on host masinas mingisugune protseside puu. Et Linuxist saate juoksutada käsku PS3, et näha protseside puud. Et protses 1 on siis loonud protsesi 2 ja protsesi 3, protses 3 on loonud protsesi 5 ja protsesi 6 ja protses 6 on loonud nimeruumi ja loonud uue protsesi selle nimeruumi sees. Ja nüüd kõik protsesid, mida protses 6 selle nimeruumises tegi ja juoksud selle nimeruumi sees ja kõik protsesid, mida protses 6-port loodub protsesis loob, ka jäävad selle nimeruumi sisse. Ja nüüd, kui see protses 6.1 siin nimeruumis vaatab oma aadresid, tema näeb ennast kui protsesühte. Ja siis on meil protses 1, protses 2 ja protses 3. Ja kui protses 3 proovib tapparaa protses 1, siis tapetaks ära see protses ja ei saa kunagi proovida tapparaa nagu seda protsesi, mis on reaalselt protses 1. Aga üks hiigel suur vahe virtualiseerimisega on see, et kui te ei olete siin, juoksad netiks protses 3 või suvalne uus kasuta selles süsteemis ja teil on root õigused ja te teete PS3 root kasutane, te näete kogusada pood. See osa siin ei ole mingisugune virtualiseeritud eraldi arvutid, on lihtsalt protses, selles arvutist on lihtsalt protses kuuaal olev protses ja root kasutane väljaspoolt te saada seda protsesid ära tappa, te saate seda hallata, te saate üks kõik, mida teha, mida root kasutasid teha, et nagu loogilised võib nagu füüsiliselt vaadates on ta lihtsalt protses suures masinas ja sellet ötav on ka jõudlus põhimõtteliselt enam äm samas, kui te ei limiteerida maa nagu ressursse. Ja natuke selline detailse m näite on siis siin, et meil on siin üleval siis välis arvutis ooks protsesid. Protses kolm on alustand konteiner üks ja protses kuus on alustand konteiner kaks, konteiner kahele luuaks namespace kaks, konteiner üheks luuaks namespace üks ja siin namespace üheses on neliprotsesi, protses kolm alustas protsesi seitse, protses seitse nimeruumi seest näeb välja nagu protses üks, protses seitse alustas protsesi kaheks ja protses üheks ja protses üheks alustas protses kümne, aga nimeruumi seest vaadates on meil protses üks, protses kaks, protses kolm ja protses neli. Et kui üks kõik, mis protses siin nüüd käivitab Linuxi käsu, et mis on siin masinas jooksad protsesid, et näiteks PS jooksatab, siis tema näeb seda tabelid. Ja siit seest jookse protses näebki protsesi tabeline ainult seda väikest tabelid. Aga kui te nüüd jooksutate root kasutana väljast seda PS käsku, siis teie näete siin kogutabelid. See üks väga ei tööta. Et teie näete seda kogu seda suurt tabelid, mis asub siis siin ja root kasutasab suvalist protsesin ära tappa ja root kasutav võib-olla ei näegi seda, et see on protses kolm tõmaneb, et protses üheks saab. Et root kasutav väljas poltsab tapp ära protses 14 või 13-15, aga kui siin namespace-is kahes jooksav protses 2 prooib jooksutada käsku, et kill protses 6, siis siin tabel seda eksisteeri. Ükski käsk, et tapp ära protses 6 siin ei töötas, siis ta saab vastu seda protsesi eksisteeri. Et kui sa ei saa jooksutada ühtegi Linux kerneli käsku või sisteemi käsku, et adresseerida mingit protsessi, mille ideed sinu tabelis ei ole, siis seda seda ei saa. Ja kõik käsud, mida sa jooksutad protses 3 peal, pransleeriteks ümber protsesi käsuks, mis töötavad protses 13 peal, niimoodi, et isegi kui sa proovid midagi halva teha, siis automaatne pransleerimine toimub ja sul ei õnestugi adresseerida midagi teha. Ja samamoodi töötab ka filesisteemide selline loogilne file-nime Room, et mõne on välises masinas root kaust, siis on slash var kaust, siis on slash var leap kaust, siis on slash var leap container kaust. Ja siin kaustal all tekivad alam kaustad konteenere teaks, näites kontee-nere 1, kontee-nere 2, kontee-nere 3 ja kui me vaatame nüüd ühe kontee-nere sisse, see ei ole samam, mida te väljas poolt näete filesisteemin, aga pikem see, mida te näete, nagu kontee-nere seest, et kui te kontee-nere seest vaatate, et te näete, et siin on root kaust. Et kontee-nere seest vaatate, see on teere root kaust, aga see root kaust ei ole see root kaust, see root kaust on tegelikult ümber transleeritud slash var slash leap slash container slash my container. Et kui te nüüd ütlet, et RM minus F ja R, et kustatakse kõik kaustad root kaustas ära, siis kustatakse kõik kaustad selles my container kaustas ära. Et põhimõttel, et ei saa adresseerida väljas pool asuvait kontee-nere, sest ei saa kasutada dot dot slashi, sest see pronseleeriteks ümber, nagu relatiiseks teeks selle filesisteemi sees. Põhimõttel, et siis linkiteks ümber, et kontee-nere seeas aru root kaust asub väljas pool siin, aga sees poolt vaatates ükski protsess, neid väljas pool asuvait kaust ei näe ja selledut, et nad ei saa ka hallata väljas pool asuvait kaustu. Kui te tahate, et see proses näeks väljas pool asutada kaust, see saaksid tegelikult mountida slash home siia mingisuguseks slash home kaustaks. Ja tavas seda me tokkerist teeme, et kui meil on vajalik, et tokkeri sees jaoks sa prozes saaks kasutada väliseid kaustasid, me peame nagu eraldi mountimise teha sisse, aga sista nagu siin selles filesisteemis alam mingis pool asuv kaust ja sista on adresseeritav, sest sa saad nagu allapool adresseerita, aga sa ülespool adresseerita ei saa. Ta on lihtsalt nagu ümpertölkimine põhimõtteliselt, et ja, et see ongi siin nimeroomide tasemel, et Linux kernel-i filesisteemin nimeroomide tasemel sa lihtsalt ütad, et selle protsessil on selline filesisteemin nimeroom ja et see algab siis root kaustast. Ja väljas pool masinas on ta siis mingisubun alam kaust, aga selle protsessi jaoks on ta siis kogu filesisteem, mida tema näeb. Ja tavas, et need samad kaustad eksisteerid, sest ka siin sees, et meil on siis omakorda slash proxine ja slash proxine ja slash pingeen ja slash pingeen ja nii-et asi. Sest Linux protsessi selleks, et ta töötaks, ta peab omama filesisteemi, nii et ta on sellesmõtteliselt ümpertölkimine, põhimõtteliselt lihtne ümpertölkimine, aga ta on nii tugev ümpertölkimine, et protsessi saa aru, et ta on mingisugus teises filesisteemi alam kaust, et tema näeb seda kui terve filesisteemina. Aga väljas poolt siis root kasutada saab minna, mina olen seda teinud, et näiteks kui siin filesisteemis tekitas liigasur logifile, kui ta seda logifile kustutada, siis mina olen seda mõningu kurt teinud, et ma lähen root kasutada ja siit slash varleap containers ja mingisuguse filesisui ümber kirutanud näiteks tühjas rõngiga, et saa tühjaks teha, et logifile tühjaks teha, et logifile on mingi 16 gigabaiti suur, siis ma ei tahakse, et see on kustas. Sest ma ei päris konteeerid ümber ehitada või konteeerid kinni panna, ma lähen lihtsalt konteeerid sisse, ma ei piha, et konteeerid sisse minna, ma saan väljas poolt seda teha, väljas poolt filesisteemist saa minna ja filesisui ümber kirutanud tühjas rõngiga. Aga tihti see isegi jooks nagu konteeerisees, jooks nagu konteeerikõrval, et selle konteeeriprocessi standard output sihti suunataks ühte jasonfile või lisad logfile ja see logfile või pärsti suureks osutuda tockeripuhul, et tockeripuhul salvestatakse kõik processide standard output üste logifile ja see võib hiige suureks muutuda üle aja. Et kui kasutad mingid ngenicsid, mis logib iga sisse tuleb pärin, kui logifile, siis see võib lihtsalt minna kuudes kiva suureks ja teil kogu selle virtuaalmasinaketta täis kirjutada põhimõttesalt. Tihti on seda juhtunud. Selle tõttu on soovitatav näiteks välises süsteemis maundida see kaust eraldi kettale, et seda kausta ei saaks täis kirjutada, sest kui see kaust täis kirjutamise tulemusena läheb kogu file süsteemi kogu server koku ei oosta. Aga kui te selle maundite reaalselt teise ketta voljumi peale, mille suuruseks näiteks märjate 20 gigabaiti või 30 gigabaiti ja väljas pool on siis veel 20 gigabaiti tokeri konteeenerid ei saa kunagi teil kogu ketasta täis kirjutada, kuna te limiteerid, et see onki eraldi ketta peal. See toimub konteeenerist väljas pool. See on pigem nagu se konteeeneriseerimise tarkkavära defineerid, et kui suurde logifailid on lubatud oida, et see logifail ei prugiga konteeeneris sees olla, ta võib konteeeneris väljas olla, toker hoiagi neid väljas pool põhimusult. Jah, aga see on ka keerulisem ja mõnesmõttes sellise eraldi voljumi tegeminu on suhtsalt rang, et see ei õnestugi, et see ei saa nagu ülepaisuda, et sul onki eraldi 20 gigabaitine ketta ala, siis ketta peal, mis on selle kaustajaks maeldud ja selt nagu üle ei saagi minna. Jah, sa võid ka see tarkkuvarad aseme, et sa võid proovida tokkerele mingi neist peasi tegitada ja sellet aseme selle kirjeldada, et ma isegi ei tea, kas see on võimalik. Jah, et see võib olla natuke keerulisem, sest operatsioonisistemi vaadates, et siin on palju protses, et igas konteeeneris on eraldi protsesid ja kui sa tõesti nendele kõigile nagu panad mingil limidid, siis see võib olla võimalik. Lissalt see probleem on selles, et kes kirutab seda logifailis, et see ei prugi üldse olla, see ei prugi üldse olla see protses, mis on see, et see ei sooksab, vaid siin võib olla väljaspol mingisugune rootõigustes protses, mis kirutab sinna ja siis on natuke keerulisem seda limiteerid, aga kindlasti on marvandse võimalik küll. Siin on idee. Mina pigem teen lihtsalt ühe eraldi poljumi sinna selle. Ja see kruppid on siis viis, kuidas me saame nimeruumile panna mingit limete, et näiteks me saame limiteerida CPU-aega. CPU-aega tavasid limiteeriteks nagu komakohtadega, et me saame mingile nimeruumile panna paja peale, et ta võib kasutada 0,2 CPU-aega. See tähendab, et ta saab 20% CPU ühes tuumast ja see tavas tähendab ka seda, et seda siis võeteks arvas protseside planeerimisel, et siis Linux kernel ei lupa sellele protsesile alokeerida rohkem, kui 20% ühe tuuma ajast. Me saame ka märat, et tuuma finiti, et mis tuumad on lubatud kasutada, et näiteks pirat, et ANME base saab kasutada tuuma 7 ja 8, et teisi tuuma siit ei ole lubatud kasutada. Meil on mahtu, aga me saame ka võrguliikluse kiirust, mahtu ja prioriteeti panna paika nimeruumile, et see protses, mis seal nimeruumis jookseb, et ta ei saa arva kasutada rohkem näiteks kui 10 Mbiti võrguvähendust. Ketta ruumi ja see ka seadmatel, et näiteks märatud, kas konteeneleis oleva protses võib GPU-t kasutada või mitte, või teatud seadme, nagu printerit, kas printerit on lubatud kasutada või mitte. Ja virtualiseerimise konteenerise vahe võib-olla siis selline, et kui meil on oma rakenduste jooksutamine siis otsa serveri peal, siis on meil vaja serverite operatsioonisüsteemi, siis paname lihtsalt rakendused siia. Teoreetselt me saame siia väga lihtsasti ka nimeruumeid C-gruppe isekasutada Linux-sid asemel ja me ei pea midagi väga erilist tegema, et meil peab siin konteenerid kasutama võtta, kui meil on täitsa okei manuaalsalt iseneid nimeruumisid luua. Virtualiseerimise puhul üks tüüb siis kasutab Ristvara eralte operatsioonisüsteemi, siis hyperviisorit ja seeraldi virtuaalmasinad, seeraldi virtuaalmasinad, siis eraldi operatsioonisüsteemid ja iga operatsioonisüsteemis eraldi koopja nagu teekidest ja failidest ja siis võib-olla mitu rakendust igas virtuaalmasinas. Aga siis on meil vaja koopja nendest pinnidest, teekidest ja operatsioonisüsteemidest. Konteenerite puul meil on tavastanud Ristvara mingisugun operatsioonisüsteem, see võib hästi lihtne Linux kernel olla, siis konteener ranta, mis tegelikult ei ole eraldi kihina, mina palaks seda viseliselt kõrvale võib-olla, et te näidat, et see siin ei toimu nagu Transleerimis nende vahel. Ja siis meil on kolm konteenerit ja siis rakendust sellest konteeneris ja iga konteeneris ees mingi koopja nendest failidest, mida on vaja. Aga nagu üks tudenks siin ütles, et me ei pea tegelikult konteenerite puhul tegema koopjaid failidest, me võime seda täiesti ära kasutada, et kui meil on virtualiseerimise puhul hypervisor, operatsioonisüsteemi jaoks, nagu Linux kernel komplekt nendest upuntu, nagu interfeisiprogrammides, mis on upuntust avaselt kaasas ja meil on neni virtuaalmasinad, kus kolm jooksatud upuntud, siis meil on upuntust vaja kolme koopjat. Ja kui meil on kaks upuntud jooksatud netkoodist vaja kahti koopjat. Me peame alati virtualiseerimise puhul koopjaid tegema. Aga konteenerite puhul meil tavast mingi hypervisor on, kus me saame virtuaalmasinad jooksatuda, siis me jooksatame tavast mingi virtuaalmasinad Linux kerneliga. Meil on selline Linux kernel, mida me nüüd saame kõiki nend konteenerite vahel ära kasutada. Meil ei ole vajanam nelja koopjat Linux kernelist, nelja virtuaalmasinajaaoks, vaid meil on üks Linux kernel, mis kus see siis toimub nimeruumide põhjal isoleerimine, aga kõik konteenerit kasutad sama Linux kernelid. Ja kui meil on vajalik siis Ubuntu keskond, et oleks Ubuntu programmit kasas, siis meil tegelikult ei ole vaja siin kolme koopjat, võib-as see visuallisioon on natukene... Põhjumist, et me saame täpselt saama moodi teha, et me saame teha kolm konteenerit, kus on seees Ubuntu need vajalikud käsud ja programmid, aga meil ei ole vaja nendest koopjat teha, et me tegelikult saame neid kasutada ilma koopjat. Siin võib olla tegelikult ainult üks Ubuntu Docker image, mida kolm konteenerit ära kasutavad ja nendest ei ole vaja kolme eraldi koopjat. Ma räägin sellest natuke hiljem Dockeri slideid juures. Docker ongi sellest üks populaarsemaid konteeneriseerimise tarkvarasid. Nüüd on järjest vähem populaarseks muutunud, kuna ta muutus osaliselt tasuliseks ja enam ei saa täiesti kasutada näiteks firmade poolt. Aga samas se kommunite version on siiamaani tasut, lihtsalt on licensid, reeglid on rangemaks järjest muutunud. Aga avaldati 2013 aastas. Esialge oli platformesa service pilve tehnoloogia projektiis, nagu .cloud, piskül suri ära, aga see tehnoloogi, mida nad ehitasid selleks, et isoleerida platformide eraldamist üksteisest platformesa service pilves, siis see jäi elu ja sellest kasvus välja Docker. Alates 2016 on ta siis komertsionaalne lahendus nii, et teatud olukordades peab asutud sellest mox makuma. Peamised on samad komponentid. Üks peamise erinele on see Dockerfile, mis defineerib ära, et mis on käsut, mida kasutatakse, et ehitada Docker image ja see on muutunud standardiks kogu konteeneriseerimise maailmast, et kõik konteeneriseerimise tehnoloogid kasutavad Dockerfile, kui kindlot taras seda enam Dockerid ei kasuta. Ja Dockercontainer on siis see, miss on ühe Docker imagei instants, mis jookseb, kus on kõik vajalikud nagu tarkvaraja protsesid, mis peavad selles konteeras jooksma. Docker image on siis konteenerfilist ehitatud sellise konteeneri nagu ketta maail, kus on kõik vajalikud failid, konfiguratsiooni failid ja sellene käsk, mida käivitatakse. Ja tavasalt serveris jookseb ka Docker daemon, mis siis haldaab kõiki neid konteenerid, mis serveris jooksevad, aga ta ei ole virtualliseerija, ta pigem nagu haldusprogramm, mis alustab ja käivitab konteenerid, kui restartte protsesid ja sellasees liigutab faili ja nii edasi, et ta pakub sellist appit põhimuselt. Ja tihtiame ikka Docker registry, kus me hoiame need Docker imageid ja selleks, et me, kui me soovime Docker imageid kasutada teises serveris, et siis ei peaks faili liigutama, aga me saame kasutada registreid nagu Docker haabi, kuhume need Dockerbildid üleslaadime ja alla laadime. Dockerbildis on siis kõik vajaliks olemas, et seda containerid jooksutada kasutab sellist union failisisteemi, et eraldi kihid, failikihid joinid nagu üheks loogiliseks failisisteemiks. Ta väldib igasugust koopjate tegemist, et kasutab sellist asja nagu Copy&Write, et kui meil on kaks protsesi, mis kasutavad sama faili, siis nad kasutad koopjad ja nii peab, kui ühte faili tehaks see muudatus, siis see muudatus teaks see kihina ja välditeks selle koopje tegemist. Ja kui tõesti on vaja koopjad teha, siis see protses, kes hakkab midagi muutma, see teab koopja, aga ülema protsesid võib kasutada samat originaaselt koopjad. Ja ehitadaks alati kichtitena need Dockerbildid, et aluseks võib olla näiteks Ubuntu Paaas Docker Image. Kas ta oskata välja, mis on siin kontekstis Ubuntu? Mis on Ubuntu Docker Imagei sees? Kas keegi oskata välja pakkuda? Ko Esta being jår sa teohmas kooped kohepionid? mis mida kasutaja või program vajab, et selle operatsioonisisteemis joostad. See võib olla lihtsalt shell nagus ütlesed, see võib olla v-ket käske, et sa tahad internetis mingit file alla tõmata. See võib olla lihtsalt file de-haldus, näiteks LS-kommandet listida file. See võib olla kätkommandet file vaadata, et mis iganes. Et alati meeldam, et Linux siis on mingisugust käsud olemast, mida kasutatakse ja see tuleb kihti väljaspol Linux operatsioonisisteemi või Linux kernelid. Et tuub puntuge tuleb kaasas oma komplekt nendest, debian nagu mingi tsaarnane komplekt, aga ROCKI Linux iga näiteks teine komplekt sellest. Ja siis kõik muud on eraldi kihti, tähna näiteks jaavajaks OpenJTK, siis oma rakenduse aks me liigutame siinne YAR-faili, siis YAR-faili lisaks paneme mingit konfiguratsioonifailid, näiteks logimise XML-faili ja viimases kihis tavalselt toimub selline kirjutamine, et rakendus enda poolt, et meil on alati selline viimane kiht, mis on write-kiht. Kõik kihit enne viimast kihti on read-only-kihid, et me ei saa põhimõttel muuta YAR-faili, kui me tahame YAR-faili ülekirjutada, siis tekiks uus kiht, kus võeldaks, et see file muudetakse ära. Ja mää etan selle vahele, kuna aeg on natuke vähe, aga kui te soovite, saate natuke lugele selle kopion writei kohta ja natuke googledada selle kohta, et mis on kopion write, et kui mulle aeg üleps, ma tulen see ju võrd siia tagasi. Et Union-failisüsteeme ongi selline viis, kudas mitu kihti joinida üheks loogisest file-süsteemiks, sest meil ei piisa ainult mountimisest, me ei saa lihtsalt ühte file-süsteemi kõik vaelikult asjad sisse mountida, sest meil toimuvad ka file-ida muutmise, operatsioonid teistes kihtides ja meil on võib-olla vajadus ühte kausta liigutada erinevad muudatused nagu niimoodi, et file-ja lihtsalt kirjutatakse üle või samase kausta panaks ja mitmed file-id erinevades kihtides, et lihtsalt mountimisega see tihti ei ole võimalik. Ja eesmärk on siis, et kontenees jookse protsest näeks file-süsteemi kui ühte sidusad Unixi file-süsteemi ja ei oleks vahet, et mitu kihti, meil on, et meil võib siin olla 60 kihti mingil põhjusel, aga me taam ikkagi, et nende kihtide tulemuse ana siis näeks välja ainult ühte file-süsteem, mis iganes järgmised kiit kirjutada ülepõhimist, et mis juhtub elmistes kihtides, aga see ei toimu muutmised, eel see toimub nagu sellise juunioni-del, et ja iga kiht, siin kihtide järekord on ka hästi tähtis, et iga järgmine kiht võib ülekirtada, mis see onne kiht, nagu määras file-süsteemis, et kas file eksisteerib või mitte ja mis file-id eksisteerid, mis kaustat eksisteerjuda. Ja see ketta kiht võivad siis olla sellise, et meil on siis masin, kus on siis mingisugne virtuaaliseeria, meil võib olla siis Linux, mis jooksetab dockerit, Linux-konteinereid ja Windows, mis jooksetab Windows-konteinereid, et kaks erineld virtuaalmasinad ja Linux-konteinere sees, meil on näiteks mingisugune Java-kiht, meil on mingisugune ngenicsi kiht ja kui meil on kaks konteinereid, mis mõlemalt avad Java-kihtis, nad jagavad seda, kui mõlemalt konteinereid avad ka Apache Tomcat ja Maven-kihti, siis ka võivad seda jagada, eesegu meil on tarkk vara sama, et sama rakendust jooksetab, meil saavad võib edasi seda kihti jagada ja kui meil ongi nagu kaks koopad samast näid HAPi rakendusest, siis nende sees on, nagu viimane kiht on erinev ja kaks erinev protsessis, siis siia viimaseise kihti kirutavad oma erinev anmed, mida nad siis jooksimise ajal muudavad, näiteks mingi logifailid või mingi JSON-nid kirutavad kettale. Ja mingi teinekiht, mis ei kasutas, teinekonteinere, mis ei kasutajahavad, siis tema on oma kihit ja üks peamine eliselt ongi, et meil ei ole vaja neid kooped nendest kihtidest ja Windows-is on põibist saa muud, et kaks rakendust, mis jagavad kihted, siis neid kihti ei pea koopeerivad. Ja Union, mis siis toimub, et kui meil siin protsess jookseb, siis meil on vaja, et need kihit näeksid välja kui ühe fallisisteemine, et ei tekiks nagu probleemi sellega, et kui üks kihti ütleb, et falli eksisteerib, teine kihti ütleb, et ei eksisteeri, kolmas kihti ütleb, et eksisteerib, siis mis see viimane tulemusisorn, et kasutatakse kihti tästi lihtsalt see, et Union mergemist, et lihtsalt otsustada, et mis see viimane seis on. Ja kõik need muudatused, mis siia kirjutatakse, neid võib kõik need alomised kihi seisud ülekirjutada, et suhalsed fallid või suhalsed kaustad öelda, et kas on kustutatud või loodud uus fall või ülekirjutatud midagi. Ja tihtun ka vahet, millist base imageid kasutada tokkereid ja konteinerite puul, ja miks olete võib-al märgand, et L-PAN on hästi populaarseks muutunud tokkereid ja puul on. See on nagu see hästi õhukene Linux kerneli peal olev käskude kiht, mis ei nõua nagu väga palju mahtu, et sa oled hästi väikse konteineri ja file luua. Noo.js L-PAN konteiner oli paar aastat tagas ajal 23 MB, samal ajal kui mingisel Noo.js Debian kiht on 202 MB suur. Nii et näid on nagu rohkem ettevalmistatud selliseks õhuke seks tockerfailideks, et saaks tocker imageid suhtselt väikseks. Ja kui te soovite, et teie konteiner oaks rohkem hallatav, et seal oaks igaselt käsut nagu v-ket, kurl juba olemas, et ei pea nii ise installeerima, siis saate mingit Debiani või Ubuntu-base imageid kasutada, aga kui soovite hästi õhukest, hästi väikseid file, siis pigem L-PAN põhiseid mingit püütane või JavaScript-base imageid kasutada. Et tokkere kasutama ei see elisid ongi siis, et saate efektiivsema jõudluse, et enam ei ole vaja meil nii palju koopeait fileidest, operatsioonisüsteemidest, et võib-olla saama ühe operatsioonisüsteemi kakkama. Tavallest me ikkagi kasutame virtuaalmasinaid, lihtsalt selleks, et oleks parem hallata kogu virtuaalmasineid seherakustutada uusluua või siis selle skoopja teha, et tihtime ikkagi virtuaalmasinete kasutama, aga me loome pigem nagu ühe suure virtuaalmasina serveri kohta, kui me piamised konteinerid kasutame. Me saame rohkem keskkondasid mahutada üste serverist, sest me ei pea kõikides fileidest skoopjat tegema. Suhtseid lihtne on docker image'aid teiselta teise serverse. Te saate ka docker image'i või docker konteineri võtta ja docker konteineril teha komiti. Ja te, praeguses docker konteinerist teha image ja nüüd saad ta image file'i ära liigutada teise serverisse või registrisse saata. Seda ei soovitada teha, sest sinna jäävad kõik väikselt muudatused, mida protsess on teinud sisse. Võib tekida hiigel suur kicht sinna, aga põhimiselt on võimalik teha juoksost konteinerist nagu commit. Ja sellest tekib image ja nüüd saad selle image ära muud liigutada teise serverisse. Väga lihtne on tekitada üks konteiner image'a nüüd seda 60 korda kasutada, et 60 konteinerid lua. Natuke lihtsam kui virtuaalmasinate puul, aga põhimiselt virtuaalmasinate puul tead saate täpselt sama asja teha. Ja on ka kiirem teenuselt ülesseada, kuna kui see image on olemas ja teie esimene skript, mis seal konteineri seisookseb väga midagi teeb, peale ühe käsujooksutamist, siis saab väga kiiresti konteinerid ülesseada. Aga teatad olukordades võib konteineri image alla tõmbab, aga päris palju aega võtta, et eriti kui internet ei ole väga kiire. Insoleeritavus on ka hea, aga see on õrgem kui virtuaalmasinate puhul, et kui operaator ei ole serverit hästi konfinud, kui ei huolitseta sellest, et kas konteineri seis on kõik hästi tehtud, siis võib juhtuda, et konteiner nil õnestub muukida välja konteinerist ja väljas polmasinat asju teha. Eriti kui maunditakse valjesid asjaad, näiteks, laisalt maunditakse kogu väline root disk sinna konteiner sisse, ja protsessi jookseb root kasutaja õigustena konteineri seis, siis no, konteineri võib üks kõik mida teha. Tokkeri puhul seda on ka raskem kaitsida, kui perneetisse puhul saab lihtsamini kaitsida, et kui perneetise puhul saab üeldad, teatud kui perneetise nimeruumis jooksevad konteinerid, neile ei ole õigust jooksutada root kasutana, neile ei ole õigust väljas pala mitte midagi maundida, et kui perneetise saab nagu reegleid selle peale panna ja üeldad, teatud annebaasi nimeruumis jooksev konteiner lihtsalt ei tohigi mitte midagi teha, et kui perneetise on see sisse ehitatud, et saab sellised poliitikaid määrata. Ühes loon, kus ma veel räägin kui perneetisest, aga selles ainest me kui perneetist ei kasuta, kui perneetist kohtam veel üks erald ja aine sügisel, mis on küll magistrile mõetud, aga pakatudengid vist saavad seda võtta ja pilvede analogist kasutame ka kui perneetist natuke praktiku mides. Kuigi vähem ühes praktiis ainult. Kokku võtak siis, nii virtuaalmasinad, kui konteinerid võimaldavad sellist infrastruktuurikoodina, saate täpselt ära defineerida skriptidena, et mis peab olema serveris, mida te üles seate, kas virtuaalmasinanna või konteinerina, aga konteinerideses on pigem sisse heitatud, virtuaalmasinate puhul on rohkem tavalne, et operaatord läheb ja käsur ja käsupelt seab asjad üles ja siis peab ise hooritsema sellest, et skript eksisteeriks, mis on tehtud selleks, et virtuaalmasin üles jada, aga konteineride puhul see tockerfail ise ongi skript tohimõtselt. Nii et teile nagu paas kasutus ongi see, et skriptige, mis peab konteinerisees olema. Ja täitsa, no ütleme, lubatud on teha niimoodi, et te võtate paas konteinerimidji, panete selle jooksma, lähete sisse, jooksotate käsur ja käske konteineris, et installeeri see, konfigureeri see ja siis teete, panete konteinerisees, ma teete selle komiti ja teile on image valmis. Et te võitisegi tockerfaili asemel käsur reaalta asju teha ja selle komitida uueks image-iks, aga see ei ole nagu best practice, et see on, saab teha, aga see ei ole hea viis, et parem on ikkagi tockerfaili kõik asjad kirja panna tockerfaili käskudena, et see on palju nagu standartsem ja saate tockerfaili dokumentatsioonina kasutada, kitis hoida ja teised arendajad näevad, mida te tekite palju lihtsameni, et ta ei pea minema ja tockerimidji kihte uurima, et mis käsut seal on olemas, et saab lihtsalt tockerfaili luugeta ja palju luge loetavam. Konteinerid pakuvad sellist ühtelast keskonda arenduses tootmisene, et väga lihtne, nagu oma arvutis testimiseal jooksutada, väpsalt sama konteinerid, mida jooksutad testkeskonnas, mida jooksutad produksion keskonnas, nii et saate samu konteinerid täst väpsalt kasutada, et ei pea keskondi erialdi hoidma, et ei ole vajadust, et jooksutama oma arvutis mingit SQL lite, siis testkennkonnas, MySQL ja siis productionis PostSQL ja siis teeme kõiki natuke teist moodi. Meil on väga lihtne Postgres konteinerid jooksutada oma süle arvutis, ja me ei pea väga muretsama sellest, et paljud ära suurse võtla, me ei võimeda lihtsalt hiljem seisemu panne ja kõik. Suurselt lihtne on eemadada oma arvutist vanad konteinerid, mida enam vaja ei ole, mida ainult arenduse ja testimiseal oli vaja. Palju lihtsem, kui otsutad, okei, mis mul on installeerimata või mis mul on aninstalleerimata, et otsida üles, mis ma olen kokemata unustan, me oleme installeerid, et ma istult vaatan konteinerid list ja kas veemalt annad kõik, et need on lihtne uuesti lua. Me saame rakendusi isoleerida ilmal oes lisakoopetet, aga siin on suure tagad. Meil on lihtsam serverite peal jooksutada hästi palju asju ja panna serveri peal näitis sada erinead konteinerid jooksma, see alati ole natuke, ku palju resursse iga konteiner vajab, ja palju kooped palju erinead keskondi on. Ja hästi lihtsam skaleerida tokkereis jooksavad asju, sest tokkereis endas on sisse eidatud tokkerservice, kui teed võtate serveri, muudate tavalse serveri tokkersform serveriks, te saate tekitada tokkerteenuseid ja panna tööle näiteks kolm kooped oma raamatud ja haldusapist ja automaatsal jagatakse teil, sisse tuleb päringud nende kolme koopi vahel ära, et tokkersformi on see sisse eidatud selline skaleerimine ja kolmuse jagamine. Ja suhtel lihtsam ka nGenics iga seda teha, et panate üles kolm tokkereid, kolm kooped samast tokkereimidist, kõik panate jooksma natuke erine porti pealis kasutada nGenicsid, et sisse tuleb liikus portile kaheksa jagada ja siis portide kaheksadot üks, kaheksadot kaks ja kaheksadot kolm vahel ära, et suhtel lihtsam skaleerida, et tekitada konteinerid juurdeist, panate mingi reverse proxy, nagu nGenicsi selle ette, et jagada liiklus nende vahel ära, et võtab mingi 50 minutit, no võib-al rohkem kui te esimiskorda seda teete, aga suhtel lihtsam skaleerida niimoodi, et panate mitu appid samase serverse või mitmesse serverse tööle. Miks üldse skaleerida konteinerid samas serveris on võib-al see, et näiteks, siis te ei pea prosesside sees tegema, mitme lõimelisi lahendusi või näiteks prosess on natuke piirata, et mitu ühendus on nad saavad samal lahti hoida, et ta ei prugi alati aidata, kui te kasutad mitut serverit, aga mõnikord on selles päris päris päris palju kasu. Aga samas ikkagi jääb vajadus kasutada virtualiseerimist, et karanteerida isoleeritus, nii et kui teil on mingi start-up, teil on kolm erinead klenti ja te soovite, et nad ei saaks ükstees mõjutada, siis mõnikord on ikka panna kolm erinead virtuaalmasinad ja nende rakkendused juosta nende virtuaalmasinad sees, et nad natuke karanteerida virtuaaliseerimist ja selletud ihti ka näiteks Amazonis ei ooksutada konteinerid alati samades virtuaalmasinades, et lihtsalt vältida seda, et midagi juhtub ja virtuaaliseerimist ikkagi pakub paremat isoleerimist, aga kui kasutada kuberneetes, sinna on siis sähitatud lisa sellise politikad ja viise, kuidas karanteerida isoleeritavust, ka saab tegelikult küll seada üles suure kuberneetes klastri ja siis näiteks erineate klientidele tekitada kuberneetesed asemel erinead nimeruumid ja nendele panna erinead politikad, turvapolitikad pealet, et nimeruumide vahel ei ole mitte midagi lubatud teha ja nimeruumide sees ei ole lubatud näiteks ruud kasutena jooksutada ja muides, aga siis peab olema ettevaatlik, sest kui teile on mõni lais karante ja siis lais karante näeb, et oh, ma ei saa seda konteerid jooksutada, kuna ta ei ole lubatud ruud õigustes jooksutada selles nimeruumis, a, ma muudan tema konfiguratsioon, et ta on nüüd lubatud. Et see on täitsa lubatud, et arendaja või operaator saab ise tsundida teha siel tööle, niimoodi, et ta panem lisapoliitika sellele konteerile ja selleks, et nagu mingisugusest politikast mööda saadan viise, et selline lais karante saab tegelikult sellest mööda ja siis te arvad, et teil on hea poliitika peal, mis seda ei luba, aga kui eegi ikkagi seist mööda häp, siis saab lisalt. Selles näedala praktikumist te siis võtad oma esimesi appi, raamatud appi, mitte selle open appi spetsifitseeritud versiooni, vaid selle esimesi versiooni ja loodte selle konteenerid ja konteeneriseerite selle ära ja siis me vaatame, mängime läbi ka paar sellist scenaarjumid, kuidas need konteenerid ehitada ja seata selle üles ja tulevikus ma hakkame need konteenerid kasutama ja me isegi agame selle ühe konteeneri mitmeks, mikrotenuseks ja mitmeks konteeneriks siis ühes tulevikupraktikumis, aga täna teeme selle esimesi korda läbi ja järgmises loon, kus ma plaanin siis rääkita anmebaasidest, nii hajuskui pilve anmebaasidest, et natukräägimelt skaleerimises ka, et mis on siis anmebaasida hajussisteemid omadused ja läheme natukene hajussisteemide juurde tagasi, aga just selliste suurte anmebaasida ja pilveteenuste kontekstis. Kas on küsimusi? Peske käsi üles, kes on kasutanud dockerid, konteenerid ja kõik. Et see ei pruugi väga keeruline olla, kui te olete kasutanud. Kes on ehitanud dokkeri faili põhjal docker konteenerid ise? Kes on dockerfaila kirutunud? Juba vähem, nii et jah. Võib-olla siis see teile esimesi korda. Aga okei, laboor on siis kahe tunni pärast ja järgmise näda räägime anmebaasidest.