 Tulemast siis järgmese loingus. Tänna räägime peamised mikrotenusteest ja alustame konteerinetehalduste platformide teemada. Tulelikus lähmed tulemise tagasi natukene. Räägime tulelikustokubet neetesest, aga mittele tänases loingus. Tänas räägime siis, mis on üldse mikrotenused näidete põhjal ja räägime, mis on nende peamised omadused. Nadukene samume tagasi ka hajustus, teemeid omaduste juurde ja teine loingu osa räägeb konteeritehalduses. Mis probleemid meil tekivad, kui me seame üles masinaid kus jooksad tokker ja kui me proovime hakkata kasutama edeks tokker swarmid, selleks lua suuremat tokker cross trade või konteerite cross trade. Järgne nädal ma ei jätka veel kui ka neetesest, aga ma räägin järgune nädal siis veel väiksematest teenusteest, nanoteenusteest, functionase service või serverlessist, kudas näid kindiskeesti nimetatakse, aga siis pärast seda tuleme konteeridehaldust platformi jõudas tagasi ja räägime nad kui me näedame sest ka. Räägime siis, mis asjad on mikro teenuseks. Mikro teenuseks on põhimõtteliselt hajustus, teemeid ja arkitektuurimuster, kus me mingisuguse rakenduse jagame väiksemateks muoduliteks, aga need muodulid ei ole nagu tarkvarasees, vaidada võrgus eraldi väikset serverid või pratsessid, mis suhtelad ülese lokaase võrgu. Kui me luome sellise rakenduse ilma mikro teenuste ja mustriutad, me tavaselt luome nagu sellise yhne rakenduseks sees, me teeme erilad muoduliteks kasutete halduseks, ningilt postistuste halduseks, mis postistuste oondamine kreetiteks, vaid ka hea teestikesed sana ei tule pähä. Päekeks meil on mingisugune Node.js appi telus, mille sees on kolme ühtki hästi erilaadiga appi endpointe ja metodid, mis halduvad kasutajate ja postistuste. Aga mikro teenuste mustris me võime näiteks jagada siis sellise malolidise rakenduse kolme apps, et üks appi, mis tegeleks kasutajate, üks appi, mis tegeleks kreetitega, üks appi, mis tegeleks pastistustega, haldusega. Ja me seame nad üleskaites kolme erineva Docker-konteehnerina, sellase mõned tekitada üks, et sa appi serverid, et halda pünt. Ja miks seda tead, me tuleme seda juba tagasi, aga põhimõttem see, et kui meie rakendus siigel suureks kasab, et näiteks nii kui rakendus on Uber või Netflix või Twilio, et siis ei ole kerge luua hästi suuri monolid ja ekskaleerida, et siis tihti meil võib-olla kasutajapäringid jääb koko aeg, pastistusi kustilistapäringides koko aeg osa ningite muuturite päringid jääb harvemini ja meil on mõnikord lihtsam skaleerida ainult ühte seda rakendusosa, kui hakkata kogu rakendust palju koopleid tegema. Ja sellise juul meie süsteeme enam ei kuolsud nagu serverid, et mis kõik tead täpselt samas asja, et meil oleks ütleks monolid, mis 3D-t replikad, vaid meil on 3D-tyndi serverid, et me igas tões võib olema kiik saada räägmikäil, et me tegib selle haiusam süsteem, mis suhtlevavad oma vahel, et näedis kasutaja. Me näedeks ütleme postituste, appi-meetod võib-olla või põeandes kasutajate teenusega, et kontrollida, kas kasutale on nii-daugusete mitte või siis kasutajate info küsida või kasutajate infot muuta. Ja mikroteenustel on tistis selline autonoomsust, et ikka erad nii oleva mikroteenuse võib siis designida täiesti eradselit eradli seisud rakennisest, mis mõnesvõttes ei jää siin teada teistest mikroteenustest midagi, et kui tema ei ole vajalduks, näist postitus mikroteenuse ei ole vajalduks, et võib-olla teeme hõta pasta nii pärin, et teegiselega togaasest midagi, aga ei kuu kisegi teada midagi teistest mikroteenustest. Ja see rakennisest loogika, mis tegeled mikroteenustest oma vahel suhtusega, see võib-olla on teistest mikroteenustest, et meil võibki sellised mikroteenuded olla suhtset autonoomsest ja meil võib-olla kasutusavaatest, ja meil on erilisava arjensusmeestkonna tegelevat erinat mikroteenust inklementeelisega, näiteks see meest, kes tegeled postituse mikroteenuse ei tegelega väga palju teapunketudes teise mikroteenuseks töötavad ja saab ainult fokusseerida väitsamale osale suuremast rakennid. Ja iga mikroteenus on spetsialiseeritud, et ta ei teada nagu teadma teistest mikroteenustest, aga samasta tavaliselt valitaks sa sene loogiliselt niimoodi, et meil on nii, kui olev mitte koupo, või nii, kui teadub tegelusta koupo eralata mikroteenuseks, meil on tegeled ainult postitustega, ainult mind kasutavatega ja see teadab ka seda, et meil on väiksem komplekt mingisuguseid teke, mida vaja, et kui see mikroteenust tegeled Maija Skuelliga, siis ta ei, temale ei pea ole, mis ta on eritud, samast tocker konteenust mingis teginist tegeled oskasiga meil sellist. Saab ka nagu neid keskkonalt väiksemana hoida ja natuke puhtuma, et me ei pea tegedama keskkondamise oska tegele ta kõikid vajalike väljas asuvate teenuste suhtusega, vaid väga konkreetselt postituse, mikroteenuse näiteks, kasutavai Maija Skuellia, siis siin rohkem võib-olev või või argevile olema mingisuguse teegid püütalise ja mingisuguse teegid Maija Skuelliaoks ja kõik, et ta nagu puhtuma keskkona. Ta saab natuke spetsialiseerida. Ja tänusele spetsialiseerilisem on ka võimalik, et näiteks see mikroteenus imperiuseerideks püütalis, see näiteks Node.js ja see opis jaavas. Meil võimalik teha otsuseid vastavalt enda vaadustale või näiteks, et on töödad, kes oska, et jaavad väga hästi ja nemad tegelevad kasutajate mikroteenusega, kes nemad saad seda jaavast teha, aga teine meeskond, kes tegelad postitust hallusega nemad saad seda püütalistega vaja. Või kui näiteks on mingisugune hea põhlus, et miks teadud tüüki olemeid, miks teises programeeriks tead, et meil ei tead teha, et erlandis, et saavutada nii hästi jaav lõimete jõudus või paraliseerimine selle mikroteenususe. Selleks, et see oleks kasutata fomata, kui meil on ühe selle monoliidse teenuse asena, näed pallonis omapäevat pead suhtama, on meieks vähtpised meelitame näed sadarvittele vastavaks. Sest me ei taha, et tegiks see olukord, et me mõtlen ise mingisugune selle protokolli väljakudas postitusteteenusega, siis kaks aasta pille on inimesed lahkujed, kes ole protokolli väljamõttesid ja keegi enam ei osteta protokolli arendada ja edasi arendamena rost. Pige peab kasutama standartsaid, liidaseid protokolle appi appisid, et kui me otsustame kasutada appisid, see on parem kasutada näiteks open appi standartid, et igavasega väheksama appi spetsiokatsiooneksisteeriks, et uus arendamiseks sisse tulla, kui ma oma potpima, kuidas sa appid kasutada, saab mõõdate todta open appi spetsiokatsiooni ja on suusse lihtne aru saada, et kuidas sellega appiga suhelda sellase mõet kasutada mingi tästi keerulist ja ise väljamõeldud lähenemist, et seda appi kõmme päevad inklementeerid. Aga mõte on üldkagi see, et ei oleks vaja midagi täiesti uut väljamõelda, vaid kasutama näid veidi teenuste standartaid. Appid tuleb kui kireldada, nii teht open appi spetsiokatsiooneks hea läheks vahelpõdele kui kui ei pea. Ajalooliselt sellist lähenemist on kasutatud ka teist sugus nimetekad, et mittele mikroteenuste, vahel üldse teenuse, seda olub keisimil nimetel teenustele orjene teeritada kõik tuur, et erinev moodulid laheanduses on eitele teenustena ja üks teenus kusub teise teenuse meetodeid välja ja meil tegib see teenuste komponeerimise meetodeid selle suuremma rakkemise loomine. Enne kui seda nimetelti mikroteenuste, siis lihtsalt oli teenustele orjene teeritada kõik tuur ja tänapäeval ka seda kasutatakse sellises tarkvaratehenika valdkonnaselt. Mikroteenuste nimi on pige nagu sellises arendate valdkonnasel nimi, aga teoreetis, tauksta uuringus kui te teete, et sootsite nii tartikteid, midagi, et võite leida ka romkem SOA-kompetit service-oreendad arviteksioon. Vaatame siis näiteid, et see on selline ühe monoliidi jagamine tükkideks näite, aga vaatama, kes siis konkreetsavad näiteid võib-olla. Meil võib olla näiteks selline mikroteenuste põhjumine rakendused. Meil on mindisugune shipping service, meil on inventory service, account service, mis on suhtselt sarralad meil on nagu kolm jagadust. Aga meil on ka mindisugune frontend, et me tahavad kasutat, saaksid meie rakendust kasutada üldus läbi frontend, et palen näiteks nii olos kürtis jäete jahvast lipp või see frontendi. Aga teadud teised rakendused ei tahavad frontendi kasutada, tahavad appid otsa kasutada, et nemad siis peaksid välja kutsuma näiteks. Account service appimetodeid, inventory service appimetodeid või shipping service appimetodeid. Ja tegelikult see on suhtselt tüütud, kui nüüd meie peame oma mindisugune kolmandosopole rakenduste lakama selgitama, et meil on kolm erine appid, üks asjadud selle IPA peal, teine asjadud teise IPA peal kolmandosopole rakenduste peal, et ei ole nagu selline lihtne kasutada haeosusteemi komponente kui iga mindisugune kolmandosopole rakenduste näiteks kelegi pood poodud mobiili rakenduste peabhaid, niil on meie siseelu, et lihtne on nüüd teene. Selle tüutud tihti paneks selline appi lüüs või vära või appi cakevi vahele, kus tekib meie rakenduse, meie saad üks aadres, võib lihtsalt inhost näid ja seal on defineeritud näiteks endpointid, et meil on tele rakendus slash accounts, tele rakendus slash inventory, tele rakendus slash shipping ja saapikeit või tegedab siis õigese kohta suunamisega, et kui tuleks meie hostname slash accounts, siis suunateks meile aggouns konteinerisse, aggouns servisse, kus sisemist võib olla mitu konteiner. Ja lisaks on suhtselt tavaline, et teaks eraldi ammebasid, et olde eraldiga need amme, et ikkust tõlsest, et näegiks shipping teelud, nende oltud shipping ammebasid, inventory teelud see on inventory ammebasid ja shipping teelud tavalist peab kirjuta inventory ammebasid otsäe, vaid, et nii teha on vajal või kisida näiteks mingisuguse, hetke seisu mingite opektide, mida ostatakse etke seisu, et see on igelgis, et selle inventory teeluse käeks. inventory teelud on see, kes vastutad, et kuidas amme hoitakse ammebasis. Ja see väitib seda, et kui inventory teelud midagi ammebasid kirjutub veel oot, et mingi teene teelud, see mudab seda infot ja inventory teelud seda teab. Ja füüsiliselt need ei pea olema nagu eraldi, et servereid või konteinerid võib olla samas, ammebasi servereiks kolm erinev ammebasi, aga nüüd olega täiesti eraldi konteinerid täna, et meil on kolm ammebasi, kolm IHLSKL või kolm Postgresi, ehk see olelem nagu ammebasijõuduse vajadust, et võib-olla kasutus on nii suur, et meil on mõistlikum teha kolm ammebasi. Kuna neid iguni koosju kasutata, siis me saame ammebasid aseval natukas ka leerida, et kui meil tõesti on, tekib ammebasijõuduse problem, et meil on teed, et me saame ammebasi agada eraldi ammebaateks, mis vajaduseb misse keraldi, et ka leerida näid. Kuigi see teeruseks sellega, et meil on mingisid rabort teerimist vaja, siis võib-olla meil oleks see, et saame mingis ESKL mängid jooksutada, mis join-rool tabelleid saha seerinev ammebaateks mõni kordud sellega problemolla. See on sellega tüüpil nästi lihtsa ammebasi näide, mis on võib-olla puudu kaegu, et kuidas need appid omavaja suhtevad, et kas võib suhtevad OXE, kas võib suhtevad väga appi Gateway, aga põhjumõtsad shipping-tenus või väljakutsus inventori-tenus on eetud, et vaadata näiteks, mis see on ja mingisid mõned hinnad või kas objektid on laos, et üldse neid saaks ostaja need. Aga see on selline suhtselt lihtne näide. Natuke keerusem näide, et ütlevad, meil oleks vaja designida mingisid Uberi või pool-designena rakendus ja me soovime ehitada sellist sõidujagams appid, et mida meil vaja läks, et meil tõenad, et on mingisid appid, mida need sõitjad ja kliendid kasutavad autod tellida või sõitja või juht täeks, kes soovik taksaks tellida. Ja selleks, et appi ehitel tavas me peame mingisid ress liidese tegema, tõenad, et me taga meil ka brouseris saaks meie rakendusi näha, kui meil pihtime, soovime nagu eraldi rakendus unua brouseritele, mõnikud muurtsed tähtsalt sama rakendus, mis töötab nii brouseritest kui mobiilis, aga võib-liseks pihtidaks eraldi. Võib-olla meil on vaja mingisid sõidjad SMS-et alata, siis me peame ka tegema mingi võimalas näiteks väliste sõlumite kohale toimetamise appidega suhjad, et näiteks teeme trilio, appi ja adapteri, et kuidas trilio. Ja siis täst vakastavaga ammebase, siis tegneks saame ammebase adapterid, ja võib-olla meile veel mingisid teised teenad, mis vajavad nagu legipäsev. Kui me eetame siis monolidse rakenduses, me peame keetama ühe sellise monolidse rakenduse, mis oska suhelata kõikiga ja tekivadki sellised väliset küljev, et iga välise integraatsiooni haaks me peame siis haldama ühtene külge oma rakendusest. Ja see tekitabki näge monolidse rakendus ja sõsteemide keeruliselt. Ja mida rohkem on meil sellised välise komponent, midagi me päris suhtlama, seda rohkem meil sellised külki tekib ja meie monolidse rakendus peab saama hakkama kõigi suhtlusega. Ja me peame siis otsustama näiteks, et kuidas skaleerida, et kui mingil hetkel tohutul palju rest pärin, kui siis see tuleb, siis selle tõttu võib kõrgatada meil suhtus Maija Skool adapteri, kes me ei saa neid eraldi skaleerida. Meil ei ole lihtne öelda rakendusalat. Kaksent procent aast tegele Maija Skool päringutega ja kui siit tuleb liiga palju päringut, siis ära nende peale liiga palju aega kulutamiseks. Meil on raske, kui meil tekib tohutul palju kasutad, meil on raske loogiliselt eraldada, puhu peaks fookkuda panema ja mingisuguste väliste teenustega suhtus võib lihtsalt kannatada selle tõttu, et teised küll on lohtemakkiinsama. Ja samuti see, et kui me muudame näiteks juste mootelid rakenduses, siis see muutus võib mõõntida kõik teisi, kui meil on suuren rakendus, mis otsustsutna Maija Skooliga. Meil ei tegi seda olukord, et kui me siin midagi muudame, siis me saame seda hoida täiesti sellise autonoom sõnad. Iga muudatus, mida me teeme ühtemooduse võib teisi mootuli suhtseb palju mõjutada, see peab jälle ka rakendust testima, nimoodi sellitele monoliidsemeleks. Me ei saa juste komponeerid lihtsalt testita. Ja lihtsalt see monoliid kasvavad väga hästi, hästi keeruliseks ja tänapäeval on täitsa taval, et mingites kritilistest sõsteemides 30 aastat vanaa mingi koopoli monoliid kusagi jääb ja selle asendamine läheks nii pole maksma, et seda ei taheta kea asendada. Aga kui nad võib-al lihtsavad sõsteemid, siis mida võib-al teha, kes on see, hakkakse enam tükki välja löödima. Meil on see monoliid, meil onks vaastamotendiseerida, võtame dry management jääb välja eraldi mikrotenusena ja hakkame monoliidist tükki välja löödima. Aga kui me Sarnas Asia monoliidse rakenduse ehitaksime ütleme mikrotenuste põiseks, siis võib-al sa näksid, et meil on nii igalse mootul eraldi mikrotenus, mingi passenger, webi, driveri viides ja võib-al me oleme need isemeehitad, et nad ongi brousseri teoks isegi ehitam eraldi ja siis appide jaoks me ehitame appi metodid, et nad saavad appid appi metodite kaudu annatele liigi ja siis võib-al appidele on eraldi veel, ongi eraldi mobiili rakendused, mis otsasalt ei ole sealtud salle arkitektuuriga. Ja me saame komponentit panema, panema üks teisega rääkoma, siis taalt, et need peab pii appi või resti kaudu teketada siis eraldi sellised mootulid või mikrotenuseks ja kui meil on näiteks mingisutuseks, vaja võiks suhtust hiljuga, et või send pilik, et saavad kas sanumeid, me teemeegi juba eraldi sanumete saadlise ja mikrotenuseks, et kui siin jääb, et tuleb, mingi mul on väägus saavad kas sanumeid, siis poedakse sõjadus selle haldile peesende erodega ja nad ei peesende erodega sisensed, siis siin pealik peeli, kuidas midi jahe send pilikin autuk sanumeid saada ja toivomattalisev. Nüüd kui tuleb toodu palju appid väljude, et strip managementi, siis otsasel see ei mõjutada teiste mikrotenuste jõudus, eliti kui meil on näiteks sellest strip managementi jooks, ma saanud üks konteinerid ja kolm konteinerid, et kui me ei tee lõrmatuks ka leerimist konteinerid ja tasemel, et me suvalsel aal luba ma suvalden aarav konteinerid juutapanna, et me siis saame korampeerida, et eks peegi teistest mikrotenuste, sest on oma konteinerid üleval ja nendest suunad, et siis siis saad ülepäringud, isegi kui strip management mingit tohjusest saab ülekoormatud, et ta saab liiga palju appi päringud, siis see ei mõjuta teisi, kuna nad jooksevad võib-ale isegi teiste serverides, pilvetsuohja teiste serverides jooksta, et siis saab hoida jõudluse vajaduse või resursid niimoodi, et karanteeride võib-ile resursse, et teha vajalik operatsioona. Ma saab otsustada, et ska veerida seda ära, agi seda mikrotenuste raaltikukäis on teadud. Ja siis on ka see, et kui me muudame üks kõik, mis mootulid siin, siis see järjest vähem, nagu mõjutad teisi mikrotenuseid, et kui sa appi jääb täpselt samaks, aga sisended võib-ale loolike, kui sa saad ütlema tervi, siis välja seid mikrotenuseid mõjutad, et nemad, kui sul on täpselt samab umeeta teid, kui me muudame appi, nagu sisended võib-ale väljutad, siis võib-ale, et kui siia lisama uue sisendi, et nüüd, et lisama paymenti tegevaks ka mingisuse lisa parametr, et siis tuleb ka muhtada kõiki teisi mikrotenuseid, kes kutsuvad välja seda meetabid, aga ta on ikkagi natuke limiteeritud, et me saame neid eraldi testida ja iga mikrotenus saab olla tegelikult implementeeritud mingi eraldi meeskonapool, kui näiteks meeskonad saad valida, et me ei ole meid payment-ski, et vihti võib, et kuulda mingisugune tööpakku, mingisugune tööpakkumine on, et lähed te sellesse asutusse tööl payments-tiimi ja nemad tegelevad ka ainult payments mikrotenustega, võib juurdu, et see sama tiim seal meeskondis, kes tegeled näide payments mikrotenusega, nemad väga ei teagi nagu või või viidestest või teistest mikrotenustest, ja uuel töötal võib-ale on lihtsam, nagu sisse hüpbata ja hakkata tegelema ainult osa mikrotenustega nemadi, aga kogu koodi baasi tunma, et tead kõik, midas mikrotenustest kõik, aga sammult siin tegid ohu, kas te märkata siin mõnda probleemi, mida võib-ale ei ole nagu monoliikse rakenduse pulud? Mis on need joone? See on need joone. Mida? See on need joone. Aga meeldis, mis see misse joone on? See on suhtlus nagu mikrotenustel vahel. Kus toidub suhtlus siin? Jah, kus kes selle serveri tead suhtama ise endaga. Et suhtlus on põeks meelus. See on lihtsalt kutsud metodi väljas, jätu jätu meelus ja kõikide nenda metodi üks teise välja kutsumene üli kiire. Monoliikse rakenduseeliid on see, et sulle ei ole nii palju nagu lokaalsest võrgu suhtlus. Moment, kui sa lähed üle mikrotenustel, et kõik väljakuksest toimud üle lokaalsa võrg. Vähemalt jõtne me sama serveri vahel kaks konteinerid saadaad üks siin resparenguid. See on tohutud palju aegus tegelikult meelu. See on vajalik olukorras, kus sul on vaja skaleerida seda susteen. Ühes serverist enam ei piisad, või kasutatab päris nii tähad. Tead sa tead vähemalt hakkama meid serverid repitseerima ja kui on rohkem kõiks koopad, siis nad hakkad oma suhtlusteku. See oli seal ninguni. Olukorras, kus ma ütleme kolm või neri replikaad monolitist vaja johsutada, ei ole see väga erinev selles, kui sul on 15 mikroteevas, mis omavad suhtsavad. Sest suhtus võib toimuda ninguni üle võrgu ja see läheb palju ulemaks, kui mida rohkem replikaad ja sellest hakkama saada sinu miljoneklendida või 10 miljoneklendida. Aga samas see võib pea tähendada, et lihtsa rakjandise mikroteevasse tegemisen on mõniga toht. Kõik need pärinud tegemine, aidustav tegelikult seda aega, kuni kasutada saab pärinudle vastusa. Teine opt on see, et see on suhtselt keeruids. Aru saada, mis probleemid on süstheemis, kui see on mingid jõudluse probleemi, kui tegivad mingid eateatled. Selliste süstheemide debugimine ja silumine ja jõudluse testimine on palju keeruidsemaks. Siin võivad tekni veel palju erinevad probleemid, mida mõnale süstheemis väga palju ei tule. Võib-olla ei eksisteergi mõnda akitektiasutuses, kes mõistab kõik, mida või teene, et nii hästi, et ta oleb kõigest ideaalne ülevaade, kuna iga mikroteevasse see, et olla täiesti erinev loobid. Eri nagu meilis keeled, viisid, mustvid, et mikroteevasse mõistmine või ülevaade saamine võib olla palju keeruidem. On välja tullud, et teatud tüüki rakendused ei ole hea mikroteevasse teaks. Tavalliselt, siis kui väga suur maht anneid tuleb saata mikroteene prohael, on suhtseba ette pilne. Video streamingis lahendus Amazon Prime Video, nema oltsustasid mingi, et tagasi minna monolyptse te rakenduste poole. Nad kombineerisid päris mitme, et mikroteenuse tagasi monolyptse, ja nad raporteerisid, et said mingi 80% kasu sellest. Nendel pilve arved olid 80% väiksemad ja võtsid vähem resursse. Liiga agar, nagu mikroteenuste teale ülemine võib kogu sisteemi tegelikult natuke nebafektiiseks tegema teha ja võib olla palju keeruidem. Mikroteenuste omadused, üks asi on käa tiinsam, et meil on palju lihtsam arendada sisteelis koosad väikestas komponentidest. Me saame arendada ainult seda komponenti. Arendajad ei pea teadma kõik, kõidest muutest ja komponenti mõistmine ja arendas võib olla palju kiirem. Ja kui meie muudatust puudutab ainult 10% kogu suureks rakendudest, siis on seda palju lihtsam testida. Mida väiksemanse ala muudataks või selline indistias võibba surfasere, seda lihtsam on saa testida ja kiirem nii saab muudatust ära testida ja laivi panna. Meil on ka lihtsam võib-al teha sellest, näiteks driver veeb uist kaks koopjad ja testida neid eraldi ja jätana tööle paralelselt. Seda tihti kasutadaks selliseks testimiseks, et lasta kasutatak kasutanud nii varapersioonid uud versionid ja vaadad, kas uues versionid tegivad, kui ei tegi, siis pahetada kõik varapersioonid uue versionid ära ja isegi lasta kasutavad testida, kum persioonid on ennest rohkem meeldid, et saada kahtu uidneid, et sama aeksalt jooksutada niimoodi, et me saame testida, et mikrogenostik on see lihtsam. Teenu on skaleeritavus, et me saame individuaalsed kõiki mikrotenuset eraldi skaleerida, typiliselt me paremene oltu üles konteeleeritene, lihtne repliceerida konteeleerit arvu. See natuke oleme sellest, kas konteeleerid ja mikrotenus ehitada niimoodi, et nad ei ole üks tehtud üldsa sõltuvad, aga tihti, selline, kui mõnes mõttes sisse ehitad mikrogenosti põisesse lahenendises, et me iga mikrogenus ehitame nii autonoomseks, kui võimal. Kuna meil on väikse komponentiks, üksik komponenti on palju lihtsam sinest ülesseada testida uueldada, meil testkeskkonada väiksemad meil on lihtsam, et arelda saab oma süveargutis, või mingis trip managementi konteeleer üleks seada, kõik ka ei ole jooksutama, ilmatab teha mingil midmeid anmebaaselikolla jooksutama, tommolel trip managementi testiselt see olega anmebaaselikse vaja. No, tüpilist on tegelikult. Teno loogilne vabaadus me saame iga mikrotenuse jaoks valida oma tehnologia, programeerings, keeled, teedid, keskonad, et ei ole kui liimiteerikult, et projektiis kasutadakse ja püütanid, et siis ei tohi ühtegi teist teed kasutada. Kuna minkrotenuse nii ole ole üksteeselt väga sõltuvad, siis teoreetselt ole iga üks suvalises keeles kirjutud, mis küll ei proovi hea olla, sest kui kõik inimesed lahkuvad, kes erlangi oskavad ja siis pitad otsima töötajad, kes tuleb esim. erlangi oskat, siis või või raskeme, lihtsam on ikkagi hoidane keelet lähedasest ühtesele, et saaks asendada arenda, kui lihtsam on iga lahkumaid. Koodid võib olla rohkem kordud kasutatavud, kui neid tulakse väiksemate mootulitena ja aita pältida sest teedubid seeritud koodi, et olukorras, kus on üks mootul, üks mikrotenus, kui saavadud video ka rääkid ja teiste ei olegi juba, et muulatud video sõnumid otsedaata, see tegi, et seda kohtud, seda olukord, et meil on mindmäs erinevad, mõnolid immoolkulis meedatud video sõnumid saavad. Et see ongi täiesti objekto orjenteeritud lähenemine, et meil on need tarakvaramist tegeleksest video sõnumid, et ongi väga konkreetsev video või notikiteisjonteehuse sees ja seda ei saavgi muu ala eksisteerida. Teevretselt saav ka arendud alust selle teedada, aga väga loogiliselt meil on teada, kus sa asukort peab sollelema, et seda sõnumid saavad. Ja väitsem kiusatud, saavad kooperide koodi, mis sama asja teed, kuna meil on loogiliselt mikrotenus, et saavad selleks vastutuoli. Ja vastupidelus või tõrke talus on ka parem. Selled oltu, et meil üks mikrotenus maha läheb, võib-a näedil, kesja mikrotenus maha läheb, et siis ei tähend, et kogu system crashi, et mikrotenusajas tekib mingisel viga, mis jooksad kogu konteehneri või selle pratsesse, mis selle konteehneri jooksad, et siis ainult see mikrotenusele tohle prestarti teha. Kui lastevad üles vale koot, siis võib-a, ratifikation teenuse töötab mingit aega, ei testitud korralikult läbi, aga üleään rakjamele tööda, kui ratifikationid jõu kohale võib-a, see on väga halb meie klientidele, kui sõitjade saan mingisel tead, et käte või kasutaja ja tead, et nüüd auto on kohal, aga põevist üleend asjad jätkuvad töötamist isegi kui süks teedata maad. Samas võivad olla, meil mõned väga onnuduselt keskse teenuse, läheb strip management, mis võib olla kriitiline teenus, teiste teenuste korralikult töötamise jaoks, meie 100% ei saa kalanteerida, et ühe mikrotenuse crashimine ei tähenda seda, et kogu rakjumus on kasutatav, imma selle mikrotenuse. Aga vähemalt me saame restartida ainult ühe mikrotenuse või palandada üste mikrotenuse, et üleend saavad järgata jooksist ja võimalik, et midagi muud väga pärkile. Ja konteenerit ongi nagu üks teamise aluseid mikrotenuste mustri edukuses, et on lihtve üleselda komponent ja panna nad oma või suhtama. Tuleviks väginu ka natut ja võib-olelne teistest protokollides, mida kasutatakse mikrotenust maha. Tänasest tänarääginu tigad nendest võib-olelne haadatakse ja tegeapide ja natuke ka järjekordate näiteks. Mõnesvõites võikki olla alguses lihtsam luguva selle monolitte rakjumust prototipina. Eritukes meeskonna suurus on väike, et teete mingi startuapi. Alguses võib mikrotenuste lähenema isegi natuke naaglustada. Teie lähenemist, et te peate võib-olel liiga palju keskondisid üles. On teed otsustama, kuidas jagatuda nii edas. Monolite prototipi heitame alguses lihtsam. Samas on hea vähemalt planeerida, kuidas see tuleviks monolitist mikrotenuste üles ümberjagab. Monolite seeis on parem, et jäta konkreetselt eraldatud mootuliteks. Hiljem on lihtne mikrotenuste jagada, sest lihtsalt on vahelik, kui tohutult palju kasutajid hakkab tekema. Kui teil ei olegi nägemust, et hiljem tohutult palju kasutajid tekima, võiks hakkab, et võib-olel see ei ole vaja otsalt mikrotenuste rakjumust kandu. Aga risk on see, et hiljem monolitist mikrotenuste ülemeed võiks väga kalliks minna võiks. Ajamõttes vähemat kalliks minna võib-olemite rahamõttes, et teab väga palju ümper arendama selleks, et sa teha. Tasub itkaka alguses planeerida, et isegi kui me heitam monolitit, me heitam selle niimoodi, et vähemalt loogilselt on meil mootulit, milles on saam moodi selline eraldatus. Meil on konkreetne mootul, kelle on esegele paljub lenda välisid suhtusega ja meil ei ole sama kootist hiljus, onumine, et saada kogu kootist laia ligal kooli. Milline konteinereid teed ühemasinepe kogu tööplastakõst? Kui te teete samamoodi mikrokrestru rakenduse ja panete kõik konteinereid samas makinest tööle, siis saad või ikka eraldi virtuaalse serveri. Te peate nad panema kui tege oma suht. Kui te tead teise viisi, kuidas saad suhtema panna, et mulle on samas makinest seisad proksessi ja ma kasutam teist viisi proksesside valjad suhtuseks, kus te kasutad kogalselt võrg, kui te teete digipääsu, linuxi, mingi teile sõnumi saadnud selle proksesside valjad, pilde proksessi communication, tõrreidselt see oleks enam sama kui ilma võrguta. Aga suhtseid keerulnud, et sa seidele talastatak teete. Pige ikkagi panaks rääbi üles, saakutakse sõnumeid saadma järe korda, et see on kõik serele, madate teada pärinud, et see proksesside valde käib. Selle hetke kui tegimte, et samas serveris sellide proksessid, mis oma vahe suhtad üle lokaalse võrgvõrg, see ei ole väga erinev selles, kui on microteamasut, näinid kahe erinev serveri peal. Ikkagi selle lokaalne võrgvõrgvõrg suhtlis on palju aegaselt või alu mälu suhtlis. Või nõimelohannes suhtlis. Aga kui jäänki, et meil on teinastid otsüükstisega suhtele, et teid lihtsalt kiinutavad kiin samale mälu adressi. Ja siis... Ja siis on siis sellie suhtuure, et meil onki üks kiinutavaja, siis kaks lubejad näiteks. Ja seda saaks teha, seda tavaselt väga ei tehta nemaati, mõnes mõttes sulle ei olegi siis väga mõtev, võib-olla et mippa erinevse konteeerise panna, aga sa tõesti saaks seda teha, et... Siis sul tegivad natuke näin probleemid, et kuidas sa ei jaga õigus, et sama mälu ala lugega konteeerite vahel. Mõikud sa teaks, et näiteks lastakse näite konteeeritel kasutada mingisuguseid mällisid faileri, aga sa tegid mälu, et sa tegis mälu mätpitud failneid, et sellist asju kasutatakse. Et see läheb suhtselt keeruiseks ja tavaselt seda ei tehta, et sellise hõu pigem eitimid otsa monolidi, et miks ma nad siis eraldi konteeeriteidut panenev. Siis parem võib-olla panna kiinat eraldi üks rakendus, mis siinemist kasutab võib-olla lõimesid ja suhtlab otsa mäluus rakendustega ja ikkagi hoiandud samas konteeeriteid. Kuid tähekte, et sa oled kui mõikud see kaululikus, et juba on see mikro teinustleiga süsteemi valjumast, aga sul on vaja ajuudiselt mingisuguseid on saite prookseleste kaks kohvud kohvuseleis maimada. Siis sa oled, et sul on näiteks üks server kaasalet. Sellest mõtus, et sa loomulikom panna see sama mikro teinustel rakendustest keskkonna ühti serversse ja konteeerit on samas serveris, suhtelad kaasavõrku kaotu üksteisega ja põe teada väga hästi. Lissalt ei ole monoli, ta on ikkagi mikro teinust rakendus. Mingi probleemi sul sellest ei tegi, et kui sa tead, et on imatioksid käe. Ta oled oma läpaka, seda samamoodi panna mingi rakendus, mis koosna 13. konteeerist oma läpaks töövad. Kuid tööta tegad väga hästi. Kas tundja ei olnud kui plusseks sul ei pea kõrragioks, et see oli siinutimiseks, et see ei pea kõrragioks, mõtus on kõrra päevas. Ia, mõni kord on seda lihtnega lõimadega teha, lõim jooksad korraks, siis panasin ja kõik. Ja mõni kord on ei näle hea, et on eraldi konteeeris. Väga tihti teoks tõeda. Kui päris kupeenete seda, siis ma spawnin ühe konteeerid, mille see on minimaalne vaalikult failid, et jooksad ta mingi asikron jobina tööta vära, ees konteeere läbi. Sellest oleme räägine kui kupeenetes lõandub natuke. Kupeenete seda teoks tead päris tulti. ja kus ma en? ja siis on hiljavad seda monoliitsed rakendus keerulise meie arvendada, kuna meil jäävad kugevavad seosad erinele moduülte vahel aga samas mikrotenesta põisest rakendus on väga lihtne, nagu võtta üks komponent ja ta ümberteha näiteks kui ma tekin nüüd selline vajadus, et ütleme ningisugune Passenger mäes mända apvi ei ole liiga skaleeriga, et meil on maile liiga palju näitas, et replika et näis konteinerid, et teelete ümber pyytanist erlangi ja problemi jäsku erlangi saab seda kiusest toonudid kirjenta ja meil on suhtseb lihtne ühe komponenti ja implementatsioon täiesti ümberteha, sest ta suhtur teisteiga läbi standartsada apvideina, kui me muudame siselis koodi ja kasutam täpselt sama open app specialkasiooni, siis keel ei väljas palju teha, et mis keeleks on implementatioonitudne, et neid ei huvita, mis keeleks on, me saame lihtsameni välja vahetada ja... Samasi on juba monoliitsaga, et näiteks teist röktes, et seal saagal kuseltaks pyytani, aga seal importi teke, et mingid funksioonise kutsud, et see ei pea tead, mis seal seest toimab, seal funksioonikutsud, et seal ei pea oleks. Üks näite on see, et sa soovib 20000 masinopeteteeki, sa pead siin, siis nüüd on kõik on pyytoni, sa kakutad 20000 masinopeteteeki, see masinopeteteek talab pead versioni pyytonteegist. See pyytonteegi on mingi konflikteise püytonteegiga, mida teine muod on kandutada, kui kohe tegis on probleeme. Sa pead siis otsustama, et mis on see pyytonteeg, näiteks mingi openSSList, ja millest tegist töötab mõlema versioniga, ja kui sul on mingisuguse nõud, et see osa tarkvarast veel ei ole ära uuendatud, et ta ei ole kompetiiv, siis uue pyyt on mingisuguse teegi versioniga. Ja sa vaad selle teegi uuendada, et koheleki probleeme probleema eht, uuendad selle ära ja sa lähen siia uuendada, et seda ära sa lübab nende teegide tasemelid probleeme tegide. Tihki on meile ainult, see on kõr seda näha, et me oleme kasutanud näiteks pilveteonoloogias mingi siis komplekki püytonteegidest töötavad jälgminevastele meid tegid, läpsed sama nagu requiem as file. Kuna me ei pannud teegil, nii täpselt paikat, näiteks ühe teegi versioon oli pandud, et ta võib olla üks püttnis versioon, mis on suurem kui teises püytoni versioonis, teises püytoni teegi sellepandutatud on täpselt kui konkreetne versioon. Ja see üks püytoni teegi versioon, siis järgmine aasta on üht uem, ja see ühe teegi vana versioonegi töötab, tulad ka teist teegi uuendada ja siis tegivad itse sellepäeksed probleemid. Ja sa pead siis olema tead, et kas lõib selle teegi uuendada, kui siin on üks sama teegi, mis siin. Ja see võib juhtuda, et see on mingisõguses teegi meeldodi signatuur on nüüd teine, sedaks parametritaturi teises kui kasutama uues versioonis, kui vanas versioonis. Ja see võib juhtuda, et ma uuendan seda, kuna ma panen sinna uue maginapeteegi, aga see maginapeteeg pahab kõige uuemad versioonid püütan teegist ja siis ilagi muud läks, kus on muja monolidis väik. Sellist väikse probleemid, aga tegimeed. See on kül üks selline labane näite võib-olla ka lihtsalt meil ei ole nagu eraldatud testondi. Kui me paneme konteneridese, siis igavühel on erinev vähemalt konteneri, kes on. Siin teegi tuleb, seda ei muidu kõige siin olevad. Kohe on nagu selline, natuke lihtsam, et me pead aga mõtlema selle peal, et kas mingi teegi muudaltus ja teegi uuendamene võib midagi muud kõikki teha. Aga sul saab ju olla sama asja arvudis mitu eria teegi versiooni, seal ükskust ühte teegi ja tege teist. Jah. Aga niis ma või ma ei pilvona teegi. Aga sest ta ei oleks karismonoliid, siis ma ooksutaks neid eraldi protsessidena. Ma pean nad väemalt erinevad pyytoni protsessini ooksuma, kus mõnev on pyytonil erinev virtuaalne keskond. Et siis ei saa, et sama pyyton protsessi ei saa korra ka kahe erinev pyyton keskondi kaks oksuma. Siis nad peab peame kaahe protsessini ooksuma ja siis ma ütleks, et miks mitte nad panne kui kõik erinevtele ooksuma. Kui mõnevad mingu nii kahe erinev protsessi ooksuma, et ma teiknud kui kõik konteneritena. Ja siis tekib sul see probleem, et kuidas sa nad omaju suhtsema paned. Ja kas sa kasutad standardid või mõtled ningisegust väga krastama asja, et kuidas mälualased kasutada välja. Ja siis täna töötab, aga puole aastapärast võib-olla ningikui võib-olla sa ei enami tööta. Võib-olla sina tead, kuidas sa teist implementeerida, aga teised uue töötead ei teha, et kuidas sa mäluala võist optimeeritud suhtus teha. Tekijad kohage see probleem, et mida keerukemaks süsteen tekib seda raskema, nagu seda tuleb seda säranduda. Kui sa ei kasutada standardseid viise suhtsut viise. Aga kui sa tästki huvita, et optimeerimisest teeme nii kiireks, kui võimalik, siis lihti minnaks standardseid kommunikatsiooni viisides kaugamale. Ja siis see teab kogu rakenduse kieruisematse. See on ka üks võivus, et miks monoliidi ei ole lihtne konvertida ümber mikrotenostalahelistest. See on väga palju sellised, et läksid kasvama asja, mis sa ei tehkud, kuna oli lihtne teha monoliidis, aga kui sa neid ära jagad tükiteks, siis see võib olla päris asja. Monoliidis ka, ja sul kasutab palju funktsioon, iga selle funktsiooni saad spanoma ette mingis teinus. Jah, ja see ongi sul, et sa hakkad seda niimoodi tegema, aga olukordades, kus nad ei ole mõeldud, et nad täiesti eraldiseisvad asjad, siis see pruugi ei ole nii lihtne, ei pruugi ei ole nii võimalik. Loogik on lihtne, et kui me taame siit minna siia, siis me hakkame selliseid tükkesid peale lõikama ja loodame, et me saame nad teist eraldiseivad teha ja tead, et tüüpi akkendistest saad, aga hiljem võib-ki olla, et nad toesti kasutavad nii mindid mõluola oma või suhtemiseks või mingite parametriade muutmiseks, siis sa tead nüüd hakkama metodeid vähel muutma, et sa pead nüüd rohkem infot kaasa panema, et ei saa meeluskustel pärtust võtta, ei saa liselt globaalselt muuteid kasutada, isegu sa arvast globaalselt muuteid kasutavad, siis üks pool muudav neid, ja teene pole ei saa sellest teadami, et sa pead jälle mingit synchroniseerimist tegema või siis need parametrit kõik kaasa panema metodidega, et sul kohe tekivad hästi palju, siis palju sellest väikse probleeme, et kindlasti sul on õige mõtte, et täpselt seda teeme, et siin on mingi metod, liikutama selle metod, et selle on nii funktioni ja vaatame, et kas ta töötab ningmaldi, kui kohe töötas, ka midagi asju ümber tegema, aga see probleem on, et midagi, midagi ümber tegem, meidud toogud palju aapade tehtima, et kui on hästi designated monolith võib-al, aga mina täitsa on mitte ja töötab, aga see lihtsalt kunagi ei tea seda ette, eriti kui see on monolith, hästi vanamonolith on 10 aastat tagasi lood. No siis samal probleem tekib ju ka seal, meil on palju net mikrohysteeme, et kui ühes ei muudame seda vissel, siis või väljas loig on, ja see on atuk umutub, et siis mingi laitete tehti võikad olla. Et kui me muuda midagi sees ja meil muuda seda appi spetsifikatsioon, et meil näiteks ootan appi spetsifikatsioon ja tead jääb täpselt samaks, siis ei toivud see, et meil väljas oleb mitte neid muud. Võib juhtuda, et nüüd on see kolm kod aeglade, ja siin on mingisemene delay või sellene timeout, et ta ootab ainult või, kui ma 5 sekundid, aga nüüd mingi pudel, et sa töötab selle üks sekund, teatad olukordotus. Nüüd võib tegida problemi, ja mitte midagi väljas kohti muudlud, aga sees muudlused nüüd on aeglasenud, ja siis siin on ka võib või. Ikkagi on alati midagi, mis kaettumid minna. Tein asi, et kui me väljas toot, muudame, et siin on meedadi väljakutse ja siin on olema lisna argument kaasad, mis on vajalik argument, siis ja, et meil seda metodid või üks kõik mis teisi metodid või siin längilik, tarkkara jaavascripti siin muutmakama, sest nüüd tuleb mingisugud lisaparanad ja kaasa panna, siis me peab meid ka mõutma. Ja see läheb palju keerulisemaks, eriti, kui meil on mingisugud muudatused, mis on mingime mikrovenuse peale, ja me peab meid ka mõutma hakkama, et mono teatad olukordotusest muutmine võib olla lihtsam, kui sellist asjad hajusas sesteemist aru saamine, selle kogus koopi mõistmine võib olla palju keerulisem. Ja kui arhitektuuride läheb peaa valutama, et alendatel võib olema lihtsam, et ma muudan mingisugud, et see on metodid sisu ära, et viib pole mingisugud töötavad, muudakse töötavad, aga, et arhitektuuride, et õigete arhitektuuriooksid, et teha võib olla väga keerulina. Kõist vist väga keerulina, aga võib olla palju keerulisem. Ja testimine ja viga teast aru saamine, et kui kasuta sai veha, et sai mingi veha teate, kus sa tuli, kasuta pärin lähti siia, siin, miga ei olnud võib olema, siin, miga võib olema, siin, miga võib olema, siin, miga võib olema. Aga kui sa sinna arhitekna võib logina, kõik need logid läbi vaatad ja leiad üles, kus viga tekis, ja otsid, oskad üles leida, kus on viga, aga sa täksid rääkuma selle mikrotelise meestonna või selle mikrotelise meestonna või selle mikrotelise meestonna käel. Ja need asjad saad lipaakimine asi läheb ka palju keerulisemaks. Ja see probleem võib tekida ka siin vahelmilt osad, mingisest järjekorras või mingi võrku konfiguratsioonalil paigast ära ja selle põttes ta ei tõeb, et selleks tehaks se visakse monitorinle ka siis stressimist, et sul sisse tuleb kasuta pärin, sa tead seda pärin kui ID meelde, ja kui siit tead, et sa logisid, logit, sa palaks sa pärin kui ID, kui siin tekid, et sa logisid, logit, sa palaks sa kaasa pärin kui ID, ka siin pärin kui ID ka, siin ka logiteks ja siis jääd, et sa need, et pärin kui ID logiteks, et nüüd mingisest lipaakija või siruja saad minna, mingisest selle kestse selle logimis vahelmist näist asures ja küsida, et panu mulle kõik logimis on seadud pärin kui ID ka, millel on 702,50 kuu. Ei võib-olla selled, et sa tead arvan, aaa, see jõudnudki kuraks siia järjekord, iga peab olema siin või siin vahelmilt ja siin ei ole nüüd, et ta prooju seda välja kurt suuda, siin logia ei ole, järjekord see jõuendus kudagi ei onnestunud või pärinkode ei tund kohale või mingi võrku probleem võib-olla. Nii et ta võib selles mõttes keerutunud minna. Eriti kui siin on erinele progameerist kieli erinele logistandard, siin on erinele logistandard ja siin on meile erinele logistandard, siis tõesti võib-olla probleem, et kui sinahab, et minema ja tockerlogid läbi laatama, siis tockerlogid on 16 gigabaiti pikaad ja võib-olla päris pare käsidev. Kas kohati proogate ekskontrolli playing cross eal see mitte teemannistlikus jaotus, et kui ma olenki suhtlus, et kui ma olen meilusotas, siis mul peab alati, see mis esimeses on, jõub esimeses, aga kui mul ei võrku, siis ei proogini. Ei proogini, aga prooviteks sellel designid see nimot, et see järjekord väga tähtis ei ole, sest üldjuhul ja, et kes saab taksu esimesena kätte, ega kasutada seda ei pea, et keegi teine proovis samal ala, nagu taksid kätte saada ja tema sai kiiremise ländale. See ikkagi probleemi tekitab, aga see olema väga sest pakkan, et standarts on. Ma ei oosti aga praegu võib-olla hea näida, et see tuu, et kindlasti see, mida keerulisem, see loogike seal on, sest see on, et seda raskem, aga mul täna ei ole olev teile väga väga rääkida. Ma mõtlen sellepäev, et juba toonagi näiteks tuleb. Me jõubasest ägst, et kuidas sulle siis hakkame jakama näiteks, monolitsiv rakendust mikro teenusteeks. Me saame äri loogikajärgi otsustada, et need, mis tegevad tellimustega on, siis tellimuse mikro teenusteeks, et me tegevad, mis tegevad kasutate, kui on kasutatud mikro teenusteeks. Tihki prooviteks, et seda nimati teha. Implanerateerin iga sellise isaseistva loogilise teenuse, mis ningid olemistega olemitega tegeleb, siis eral kui mikro teenuse. Ja me saame need mikro teenuseks jakada oma asutus on meeskondatele vastik, salaka upad näiteks, iga meeskond saab isegi valita, et mis mikro teenusteega nad on rohkem parelsamad tegele, et kui mis mootuditega nad on rohkem parelsamad tegele, siis saavad teha näiteks valida. Teatud asukusti teads isegi, et töötad veel lastaks valida, mis ma järgisena teha tahal. Ja ideaaliselt võiksik ole iga teenustelemine suurselt lihtsa väike selle vastutusalaga, et ei teaks liiga palju teadma, et skoop oleks väiksem, et see ei pea liiga palju teadma. Aga see olev, et kui suurkele asutus on, kui väike asutus on, siis seda ei ole võimalik. Ja eka et ei tahaköet oleks 125 mikro teenuste. Lihtse selle peal olema jääma ikkagi lihtsalt selle mõistiku ja suursel, mis olev inimesi tarvud ka. Meil on ka tihi otsustatud, et mis suhtlust me kasutame mikro teenuste mahael. Taasest kasutades kasvotse suhtlust näiteks HTP, suhbi väga dihti kasutataks, aga näiteks HTP asemelud GRPC kasutada, mis on see ARPC tüutbi ja palju efektiiseen, kui HTP üle lokaalse võrgu. Ma tuleb suhtlul natuke räägjadest GRPCs. Ja tead, et järe korda on hea kasutada siis, kui me võib sisse tulla hästi palju sõnumeid, aga meil ei ole tähtis näite töödelt ära ülikiiresti. Meil võib-olla on kasulikum jääta sinna puhver järe korrana, eest meie mikro teenuste saab minna ja järe korrast sõlmusi võtta ja ne vära töödelda amme paesi panna. Sõnumid saad, et võib-olla meil ei olegi tähtiselt SMS-või e-mail-jooks koha kohale. Me võimegi sinna tead, et ta saad on jätte teketud järe korra. Ja see võib-olla eriti hea, kui me näiteks ööse saadame 10 000 SMS-korraga või 10 000 e-mail-korraga. Meil ei ole tähtiselt, me skaleerime nüüd kiiresti konteeerid arvu ühe pealt saja peale, et korraga tead 1000 sõnumid ja 10 000 sõnumid kohe ära saada. Võib-olla on täits okei, kui see toimid nagu aegaselt üle öö saadetakse nüüd sõnumid kohale. Meil ongi võib-olla hea panna sinna järe korra, ja siis panna mõned konteeeritöölems järeks võtavad ja saadavad sõnumeid. Näält sõnumid ja järekorad tihti töötavad päris hästi seste puflitena. Meil ei pia olema aktiiselt mikroteenust ja kujult töötajad, kes kogu töö kohe ära tead, vaid me saame tekitada neidne vahelisele järekorra ja lastane järekoraks tegemust võtta endale ära teha. See vähendab selle skaleerimise vajadust, vähendab sõdeb me peama korraks hästi tohutud paju resursse tööle panema. Meil on eriti fixeeritud arvservereid ja meil on maksimum konteeerid arv või maksimum resurssid arvmedatuseid kasutada, siis mõnigud on lihtsalt hea asjad panna ootel järekorda, mitte eeldada, kui keegi saadab hattete pe sõnumi, et kohe on prokses valmisida vastu, et ma ära töötama. Teina alternatiiv oleks, et meil on hattete pe server, kes siseemised hoiab järekorda, et hoiab kõik saabunud sõnumid endasees ja töötad nende paeksad läbi, aga selle oht on see, et kui see crashib, niis juhtab lokaalsse järekorraga, et see on nad kohtlik, kui lasta mikrodenustel endal siseemised hoida järekordem mälud. Väliselt järekordi jäedate järekorvast rääpikit kasutad, hoida asjad mäludus mikrodenustel vahel pufrina ja mikrodenustel saab võtta, kuna midagi töötab. Aga see samuti teeb kogu selle lähenemise jälle teerulisemaks, kui meil ei ole otses uhtlus, siis kaua on sõnumid järekorvast. Kas nii-kui sõnumid liiga kaua järekorvast? Me peaksime juulta panema mikrodenust, ütleme neid replika, et olukorras, et järekorvast on liiga palju objekte või liiga palju sõnumid või sõnumid arvi järekorvast järeks kasab, et me peame siis selle põhjem, aga see teeb siis järekorvast otsustat mõnigult keerulisemaks. See võib aidata, kui me paheme jäädata järekora mikrodenust ohele, aga see ei ole veel atvitektuurike keerulisemust tegega teha ja rohkem sellest hajussisteemide problemi esine tõsta, et kuidas me neid järekorvast raldame, mis me teeme, kui järekorvad järgst kasuvad. Ja mõnigult meil võib olla ka keerulisemaid operatsioonet, et me kasuta saada päringu, ja selle asemel, et see päring on päringu väljakutsumiseks, me kutsume välja ühe metodi, võib-olla me peame parele ees, et kutsuma välja nelimeetodi, nelas erinevas mikrodenuses, et kui tegi kokku kombineerimis kasutale saadma, et meil tekib selline olukord, kus me peame väljakutsuma järjest edasi saadma seda sanumest vaid mitu pärinud tegema ja pärinud tegema, et kokku kombineerimiseks vastuseks, et kuidas komponeerid, et mikrodenuseks väljakutseid teha. Ja meeliks küsimuseks, et kuidas kasutame ühte keskustatannebaasi, niimoodi, et igal mikrodenuseks on õigus näiteks lugeda kasutatanneid, või me teeme eraldi kasutat teneuse ja ainult me saadame rest pärin, kasutatelt teneuse, et kasutada infot kohuda. Ja kas me peame kõikile mikropenestala oma anmebaasi konteeleerid või on üpselne anmebaasi server ja kõigil teeme oma anmebaasi tabeleiga mitte. Tekiju ota päris palju sellise küsimuseks, kuidas me haltamis mikropenestamaalis koosti. Et kui me tegime vajatus, et sellise Appi Composer boost rielel, et meil on mingisuguna päring, mida me teeme ja meil oleks vajana, et joinida anmeid kasutate teneusest, orderite teneusest ja mingisugusest delivery teneusest. Meil on vajanest raportit, et ku raport ja kui me ei tee seda otsa annebaasi põhjal, et meil ei ole teeda warehouse, kus või kannada kokutud, meil on peama apiide kaudu tegema, et meil võib-olla peamegi seda päringida vastuanduks, saadme kolm päringid, kolm erinal mikropenusele ja koko kombineerime selle vastuusele, sõesti tegema näiteks mingisugusek joini, pääluvus, mis sealt maha vastu. Meil on kolm chasoneid, joinime kokku ja saadame ühe chasone vastuudame. Et sellise liul me saaksime teha eralte api-komposeri, kas api-gateway tasemel, et meil onki mingisuguna api-komposer mikro-tenus, mis meshiid kolme teenuse kutse üheks väljakutsuks välja. Kled, kes selle api-komposer meeldad üheks väljakutsuks, tead selle taga kolme teenuse väljakutse. Et see on siis natukene vastu pidin olukord, kus meil ei kasutada päringid nii-ajal, et ei jookse läbi erinalte mikro-tenuste, vaid kutsutakse välja ja koha vastatakse. Eralte anmebaaside tegemise hea külg on see, et me saame teenuse täiesti omavad sõttumatuks teha, et ühe teenuse anmebaasi updateimine näiteks ei mõjuta teisi teenuse tõtsi, et meil ongi täiesti eraldi anmebaasi konteenerid, ja kui me ühe MySQL juuhendame, siis sa ei mõjuta kui teisi mikro-tenuseks, sest need on enda MySQL konteenerid või Postgres konteenerid näimiseks. Ja muudatused, et me muudame sisemist tabeliskeemat ja näiteks kasutatabelis, kui on meil iga mikro-tenuse haks oma anmebaasiskeema seal tabelis ja ühel või teisel mikro-tenusele ei ole lubatud selle tabelile päringu teha, siis tabeli anmebaasiskeeman muutmine ei saa mõõde teisi mikro-tenuse, nii et jälle on selled mõttes hea. Ja mis saaksahab see võimalse, et mikro-tenuse saavad valida endale sopiva anmebaasi mudelid näiteks. Mani tahab JSON anmebaasi kasutada ei, ta tulegi kunagi vaja mingi taga keerimispäringuid või raporteiks generereeda. Ta lihtsalt kasutad JSON-ed hoia, võtab kasutada JSON-e, kirutab kasutada JSON-es uued läärkused, ta ei ole ka vaja mingiselt kasutata üle mingi päringuid teha, võib-olla siis that's okay, et ta on mingiselt hästi kiire JSON-dokuments, database kasutus oli ja teine mikro-tenuse paljad, et valida Postgresi 300-maja-sküeli valid. Teoreetiliselt võib sellest kasu olla, kas ta päriselt ka kasu on, et meil on lisa kontainereid, lisa resursid, mis näide annebaasideks vaja on, et sellest ei kruugi väga kasu olla. Jagatud annebaasi puul on lihtsam üppemete erite transaktsioone, mis puudutavad erine tanneid, et samal aal, kui me kasutame, me tahame samal aal muuta, ka kindlasti tellimuse teavad ja me ei taha, et need autos sünd läheks. Näiteks meil on mingiselt kasutada päljad ühes annebaasis ja sellest tellimuse infoteksias annebaasis ja kudas me kontrollime, et selle transaktime mõnikord saab seda teha niimoodi, et me kasutame hapikomposerit, kes on siis, kelle ülesana transaktiivselt korma anne vära muuta ja kui see ei õllestud kõigist tolmes, siis saab tõmata see transaktsioon, aga kui see on kõik ühes annebaasis, meil on lihtsam jooksata üks pärind, üks SQL-annebaasi pärind, mis ongi transaktiivne, et muudab kolm tüüpi annet korraga ära. See nõuab ka vähem suurtust mikrotenustumahel, et kui me jäägatud annebaas, et kui me muudame kasutad annet, siis me peab suhtsama kasutavad teenusega, ja tõrreedsed me saaksime kiilema suhtluse, kui me kasutame aga see annebaasi, ja me ei püa niipal erine oida annebaasi päringud tegema, nii et mõlemal valikul on oma sellised ediselt. Kas lihtsalt XT-a, aga kui aga problema on kõik, et kui on sellised ühke jüüb lihts? Nel on ikkagi eraldi igal asutus on oma annebaasi ja XT on sellised api, ma ütlesin, et api aga põhjelis see, et see on sellised nimetud, et see... ...tüüs. Nel on oma security liusid küll ja security serverid nende ees, aga see on see kiir tee nende vahel, et XT ongi sinne lihtsalt apid oma vaheline suhtluse standard mõttes, ja iga asutuse ees on see XT security server, kes suhtlust vahelatab ja kõikidel asutustel on oma annebaasid ja kui sinaka asutad näiteks mingisugust riigi registrid, siis seal registrids olevad anmed ei kooperi ühtegi teise annebaalde. Eesti riigi lähenene karanteerik ja anmed on ainult ühäskohas ja kui need muutatakse, neid muutatakse ühäskohas ja kui teene asutus taab need anmed, siis ta peab peab läbi XT päringi tegema ja security serverid, et siis logitakse, kes küsis need anmed ja iga anmed päringi saab logida ja ei teki synkroniseerimist probleeme, aga saab pead, kui tööst tegema päringid, et kui sulle on ningisugune teenus, mis vajab kolmest registrist anmed, siis ta peab need kolm päringid läbi tegema ja sega karanteerib, et sa saad see logida, et sul ei ole koha peal mingis mälus need anmed ja sa ei saa vältida nende anmed uuesti küsimist, ja politsi ei tee päringid, siis jääb alati jäljad, et politsi ei tegi need päringid selle hetkel. See igal teenus on oma anmebas haitad, kes sul tegelikult jälgidad, kes need anmed kasutab ja Eestis on kõist seadused, mis karanteerib, et anmed ei tuplikeerita, et inime ei pea kolm koord oma anmeid edastama tästasama anmed kolmel erinele asutusele või registrillel, et registr on vastutavad nende anmed ja küsimist teises registrist ja selle tehtu neil on vaja. Aga ta ei ole nii väga mikro teenuste muster, ta on pigem ikkagi süssteelida vaheline suhtus, mitte mikro teenuste põhjine suhtus. Sisemiselt mingisuguse asutuse registr võib olla mikro teenus, aga päljaspod vaadab, kes on taragu mingist on monoliitid ja mikro teenuste kombihaatsioon, nagi nad ikkagi suhtavad üle internet ja üle XT. Aga ta on mõnesmõttes rohkem kõrgemataasemalne service-oriented arkitektuur, et kõikidel on täpselt sama standardiga teenused, ADTP ja SIP, siia maani on SIP-päljapäe kasutusel. Ja siis appid panakse painka mõnesmõttes teaduse standardja XT jaoks, aga sisselemist registritele võib olla omaapi, aga XT suhtuseaks on omaapi ja mingite arbet see tüüpi meedrute väljakutsumine toetab saan läheb seubi. Mikro teenustele on võimalik, et tulema või või võimalik, et mingist on osa üle internet? Sul on kindlasti võimalik, et nad on üle interneti sul ka, aga siis tegik küsimest, kas ta siis enam on mikro teenustele. Samas kuiks sul tekid olukot, kus sul osa mikro teenustele on pilve ühes regioonis, siis on teises regioonis. Ja saan, et ta on kui nüüd sama mikro teenuste rakendusosa, aga see lihtsalt paned nad kõikid asja kohtudest, kus on klientid näitud. Klientide ei peaka sootsa ühendustatma Saksama keskusega, vaid saaksid võtta kõige lähendalat asemega. See läheb natuke keeruliseks ja ta on lihtsalt võib-olla definitsiooni küsimuseks, kas sa nimeltad seda mikro teenustele. Või sul on mikro teenuste rakendusele erinele tasu kohtades ja teadud tead federeeridud viisil oma maail suhtelavad. Aga tõesti kuperneetises on sul võimalik, et sa defineerid rakenduse ja sa üldad, et mul on kolm kuperneetese regiooni või klastrit. Ja paned selle rakenduse kaks kooped sinna, et sul on rakendus, mis tegib nende regioonide peale suurem rakendusena. Ja siis teadud komponentavad mõjal. Ma ei oska võib-olla hea näide tuua, kas see on üldse mõistlik. Sest sa tehti tahad, et sul oleks enamahend kõik mikro teenustele kõikides regioonid olemas. Sest sa ei taha, et sul suhtus oleks liiga aeglone ja isegi annebasides. Sest sa ei taha tegelikult, et sul oleks eksisteeris ainult ühe anne, kes päris annebaside. Mõnes pohjast tegaks peikem replikatsioon, et sul on samarakenduse replikatsioon peikides regioonides. Aga teadud olukordades võib-olla, et mõned mikro teenuste komponentid on erikaks tegelik. Aga paremaks võib-olla näide leida. Siin on koost ja näite teadate järekordade kaudu. Meil on mingisugune order service, kes kussees on mingisugune operatsioonid. See on mingisugune operatsioonid. Kui meil on vaja näiteks väljakutsuda mingisugune customer service appi meetood, ilma töödete järekordadega me saaksime, et ta süü proosalt väljakutsud. Me teame tegema asumtroncent, et me peame selle väriingu ja operatsioonid kirjutama järekorda. Kui meil on kohes, et tulemas vaja, teame ma ootne leema. Aga mida ma ootame? Päringu läheb siia, töödates usaga mõel. Me teame tulemas kätkesolda, mis tavasalt teaks on, kui siin teha päring, toedate järekordade kohel, tavasalt panaks päringu raasad kaks asja. Üks on päringu ID, see on minu päring 1,67 miljoon. Tavasalt panaks selliseks, et ma kuulan seda teadate järekorda ja saada selle päringu vastus siia teadate järekorda. Kui see meedot saadab selle päringu, siis ta hakkab kuulada seda teadate järekorda, kus peab vastust tulema, siia võib saada näks 10 vastus, 20 vastust. Ja kahu, et päringu ID, mida te kaasa pani, et siist seeerida, milline vastuste järjest ilmua, milline on vastus selle originaalsal päringule. Ja see töödleja customer service, kogi sõkone konteele, siis kuulab seda päringud, ja ta vaatab, et mis on selle päringu, mida ta redb live to järekord. Töötab sen ära, et sa võtab annemaasis kasutmea info ja sa praad seda kasutme info vastusena sellese järekorda, mida saad te kuulema käkkesaamiseks ja siis siin, mis treeniteks, et oodab, et kui nii saabub sinna järekorda, siis päringu vastud, mille sama ID, kus originaale päring. Aga jälle tekitab see kerukust juurde, et nüüd peab hakkama haltama, et mis juhtub, kui need järekord nüüd suureks kasuavad, kuidas skalereida seda teenuste, et mitte võiteks, et mitu röntgikad peab sellest teenudest olema. Tihki nüüd enam ei saa, nagu teenus, et CPU või länukasutise järgi otsustas, et kas ta on üle korva, aga mitte, et sihti see teenud, et isa otsustab, kui kui kiresti ta neid objektsidesalt järekoraks võtab ja pigene töhaksama otsustama järekordnade pikkuse turhjal, kas siin poolt peab olema rohkem töötse, kesid järekoraks midagi võtab, et siis võib, kui seal järekoraks pigaks, mis võib olema siin peab skalereidimaalt, ta ei saa hakama nende vastuste töötlemisega, et siin peab olema rohkem kontainereid, kes tegelevad sellest oordeks servicei töötmisega. Mis kasul me saame, kui me mikro teenuseid rakendame, on, et Tarkvara on lihtsameri hooltutada ja testitunud. Võimalda sage ta silmi muudatusi teha ja neid testida, et ülespanna uus version kohe, et saab teha sellist continuous integration ja continuous deploymenti, et saab kiresti ära testida ja kiresti uue version üleslaste ja vasta kasutada peab saa testida. Teenuseid on suhtse mõrgalt üksteise ka seotud, et on lihtsam, et meie arendad saavad arendada teenuseid ilma, et ma täiksid kogu sisteemi tunnuma ja see vähendab muudatusta mõju kogu sisteemile. Mida vähendab, muretsava sellest tõttu, et kui ma teen samakoodis, et kuidas sa muudatub muid asja, seda vähendulid testida, seda vähendulid teadmiseva jääva kiireni ja saab muudatustu teha. Kõik teenuseid on ise sestad juurutatavad, et me saamegi teakitada neile omad kit repositooriumid ja eraldi CI-CD pipelineid ja meeskonnad saad näite luenudada ühe teenusei versioon vahetatud näite kuberneetise välja, ei peagi teisi teenuseid pausile panema, et kuberneetise osateks väga hästi nagu rolling update, et teenusei koopad välja vahetata ilma, et ilmstegi eroged tegiks. Mida väiksem, sest teemoond seda tõenaduse on, et meil onnestud seda teha. Monolidse rakenduse uuendamise, et kui me peame kogu monolidse rakenduse pausi tegema ja siis ta ühes panema, on raske vältide olukorda, kus mõned kasutavad saada eroneid. Aga kui me välja vahetame teenusei nagu väikeste tüppide koopa, on seda lihtsam ka. Likult see on võimatu monolidselt puhul. Võimalik on areldada komponente meie süs teenist palju väiksemate meeskondade poolt, et võib-olla meil ongi tuleed asutuse praktikant ja lööldaks, et meid huvitab, kas peab. Peab, et notifikatiivne teenuse oleks palju efektiivisem, kui me püütanasame erlannu kattu. See võib-olla ei ole asutusseks väga tähtis, aga kui oliks huvitavad seda praktiku projekt. Uuel praktikantid on suhtse lihtne. Oltbid ära, et mis on notifikatiivne teenus, kui ta ainult teab seda, et mis püütvii päringud saadab, et sa ei ole muuskete peagi jäägi jõupima. Ja ta või sa proovid implementeerid, et võtab sa püütnud kohti kirutada erlannu sümbad ja testib sellel ära. Võib-olla raporteerib, et nüüd tegin sühteetnist test, et saad sinu 10 000 sanumid. Ja see oli 56% kiirembu püütnud. On lihtsam mingi väikse, et araneleks teha ja uutel töötanest ja praktikantid sühteemiga tuttuvuda, kui ne peavad võib-olla selgelt sõltima ainult ühe mikropeenuse tehtud olukordid. Aga mikro tehnuste puudused on ka see, et raskem on arvusalmata kogu süsteemi hajutatud arhitektuurist, et me ei tegele enam ühtse rakendusega. Meil on võib-olla ühe kit repositooriumis asemel 12 kit repositooriumis, minne ka tuu tuttuda. Ja tehnustevaalist interaktioonise testimine on ka palju keerulisem, kui rakenduse enda testimine. Me teame, et kõik ülespane on meid uvitav võrgukiilus ja kogu süsteem juurutada on ka palju keerulisem. Meil võib-olla ühe komponenti teie ülessealtmine lihtsam, aga kui meil komponenti paljas järjekorrast tööle, panaks selle, et tekida mingi imelikad olukorrad ja meil 16 konteele ülespaneme võib-olla natuke aeglesam, kui ühem monorid ülespaneme. Ja võib ka rohkem mälukasutust vaja olla, et kui me kasutame, et kõikil erinev, kui me saame neide mälu panna täpselt niimoodi, kui vaja, me teame ikkagi planeerima niimoodi, et kõikil oleks 500 mälu, et oma maksimum kasuksega pakka ma saaks. Kui me jagame ühe suure monorid ja väiksema tükkideks, me võime igale väiksema tükkile, et vaja olla panna lisamälu, niimoodi, et see kogumälu kasutas on veel suurem, kui monoridibugul. Ja teistid resursid saavad mood, et me peame igale järkma ikkagi mingisuguse isa resurside mahu ja selle tõpul kogum resurside mahu tükkideks jagamise tõttu olla suure. Nüüd teene teema, mis meil on, on tokkeri-anhitektuur ja on need teene, et haldus, et ma võib-olla seda lõpuna ei jua rääkida, kuna me vaatasime siin näitud ja arutasime natuke, aga mul ongi plaanis kui kui kui kubernetissa lõend, et ma vaatan palju, ma siin jauan ja siis ülejäänud jätan siin kubernetissa lõenduse sest. Et natuke meeldetuletust, et kui me seama üles tokkeri-serveri, et kui me seama üles tokkeri-serveri, siis me tavasalt on mindi hulk konteeleid, mis jooksad sellisele serveri peal. Meil on serveri peal tokkeri-demon, kes haldab neid konteeleid ja tavasalt iga konteeleid oksamiseks meil on rekistist vaja alatamada konteeleid pilt, kui me saad kaha sa teita, et me tegid ka mindistune pilti lokale rekister ja me teame haldamad tokkeri-pilt ja tokkeri-konteeleid. Siin lihtisest käsepid me ostame tokker pilt, tokker pulli ja tokker ram, mida teisevare te tahtipumides kasutam. Tokker tavasalt tänapäeval on pigem selline liides interfeis, nagu konteeleid halduseks, aga siseliselt enam ei islele teerik, kui tõlsene tokkerid jooksad, mida me käinudid. Hihti tokkeri kasutab nüüd sellist tarkkura nagu konteeleid liih, mis on siis tarkkura konteeleid loomiseks ja tokker ise pigem annab teile neid apikäsud, et kuidas konteeleid tuuga, kuidas konteeleid hinni panna, aga isegud sa peale konteeleid ei apikäri. Ja konteeleid on selline tehnologiasta soovima tokkerit ja kasutuda konteeleid halduseks, on tokkeri asjad teise tööristad, kui on tokker nüüd nagu tasuuline enterprise teenus, et teene luba, kui sa oma vajadust teha öpiga teha tasutakaasuta, aga mingis firmaas võib pole ei tubata tokkerid kasutuda teha pitsentilõtma. Ja siis tegelikult peale teeb saab ka lima tokkerid ette kasutuda, et on näiteks teie erinevad pinuks, käsur ja kandida, on eritse l, et käsur ja käsutus, mis on tokkeris arvan, et konteeleid liikauudu otsa asj jooksada ja siis on see pasku tarkkura. Et on amatud tarkkura tokkeri asutudist ta. Ja kasutatakse siis rand C, mis valjustab ette nimeruumid ja käivitevad konteeleid, et teavad konteeleid seest protsesid ja konteeleid seest soksad vähemalt üks protses tavaselt piltis. Konteeleid omadused meelded tuletus on, et neid on muutmatud selles mõttes, et kui me üks kõik mida konteeleid seest muudame, siis see konteeleid pilti ei muuda, et me saame samas konteeleid paas piltist ja uue konteeleid saada tagasi paas seis, et kõik on nagu, et kui meeldada ei muudatas tol originaalsed pilti. Konteeleid on mõeldud ühe kordseks kasutamiseks. Tokkeris võib-val seda väga ei märka, sest te teete, et tokkeri paata seisma, paata uuesti käima, paata uuesti seisma, paata käima, ja see olukord jätkab edasi. Aga kuberneetises seda teha ei saa. Et kuberneetises panas konteeleid seisma, see tähedab tegelikult kustutamist. Kuberneetises on mõeldud alati, et kustututakse lihtsalt ära kõik, mis on konteeleid seelt muudatuse tehtud, ja palaks uus konteeleid nullist tööle, ja see toimub iga kord, kui kuberneetises panad vahetat versionid akkuvarast, viigutab ühe konteeleid ühes serveres teise, viigutamist tegelikult ei toime, toime kustutamine. Kuberneetises on rohkem selline, et teate eelt, et teie annabase konteeleid võidaks seisul suvalisel hetkel kustutada. Kus teadab seda seda annabase konteeleid? Kostudad mitte. Peate annabase üles jääb ma niimoodi, et kõik vajalikult asjad konfiguratsioon anned oleks mingi voljumi sees, ja see ei kustutakse, kustutakse ainult konteeleid. Aga ka voljumide haldus on omakorda keeruline, sest kui te jooksutad konteeleid mitme serveri peal, siis millise serveri peal on see voljum? Kui see voljum on lokaalne file-i voljum, sest ta on ühe serveri peal, kui ta on liiga palju ühe serveri peal, siis te võib-olla kolmat ühe serveri üle, et seal tohku mõet selle balanseerilide peale. Aga ma räägins just kuberneetes loengud, et tegelikult see on tarp, mis haltab neid lokaalsed voljumid, niimoodi tõstab neid ümber, või kasutab visiagil võrgukettaid selleks, et näid voljumeid poidagi teise serveri peal, ja seda problem ei tegi. Aga teist, kui te jooksutate MySQL-i konteeleid, te liidite selle, siis keegalme kauda. Tokeris on normaalne, sest te ise jooksutate liidkasu, aks kuberneetes võib see liid toimida taustal. Teie kasutane ei tea, ketta ära kusul, et jääb pandi selle. Ma räägins just teises loengus. See on lihtsalt vajaalik, et kuberneetes saaks ennast optimeerida. Teie, kui kuberneetes administraator, peate seda teadma, ja peate konteeleid ülesadme niimoodi, et pide kadu meile. Võimeks maountime voljumid, või mauntime välise kausta ja hoidma konfiguratsioona seal. Te peate ise hoolitsema sellest, et kõik vajaalik, mis on persistempinea, ehk pidevana hoida, peate seda konfigurata niimoodi, et saab korra eht teha. Kuberneetes ei kasutata tokerpilte. Kuberneetes on tavaliselt ettevalmistatud kuberneetes templaidid, mis automaalsalt loovad õigeid voljumid ja asjad valmis. Kui teie peate poskress sellest kuberneetes, siis ei kasuta tavalis tokerimidžid, või kusutata poskress helm charti, või poskress operaatorid, kes ise oskap ja sinna sisse neidatud korrektne kasutus, mida tokerkonteeneritesse ja tokerpistitesse tavalist ei ole. Sellest mõttes on lihtsam kasutada kui tokerit. Tänal ei ole sest aega rääkida, aga meil tuleb kõik eraldil oend selle kohtal. Aga sellise juba ei ole pohutu, et tegigi mul on suurit, eks ma ala vakrani hidutama, panen siis sellele lõu alla lupu, aga siis protseist abetakse arasemale alu. Ja, et protseist peab olema loodud sellisena, et annab asi protseist ta vasta ange, et nad küiaad selle signaali kimmi, teevad kõik transaksioonid ära, või panavad need transaksioonid tagasi, kui nad teevad transaksioonid ära või roolivad ära, ja siis ise lahkuvad, nagu ise eksitivad. Et sul peab olema protseist loodudki niimoodi, et nad võivad neid võib kildita suhjais lajal, aga see kilimine ei ole kohene, vaid see on ikkagi signaali kinni püütmine ja protseist tead lopu, nii siis lahku välju. No see kilimise mõttem, et kohestab, et toonis signaali välju. Kui sa annaad maksimum signaali, et midagi ära tappas, siis on sinu probleem. Mõtlen ka, et see server jooksid kogu, oleks meed toot, et midagi signaali vallel, lihtsalt ongi üks, et neb välja asjad. Jah, selle vastu taval see taitab right-ahead locking, et näites, Kafkas kavutatakse seda, et enne, kui sa midagi töötla, magatsead kirjutu kepale. Et sulle tead päring, see kirjutu kepale. Ja poskas kavutab kasadad, on right-ahead locking, kui te oota kuulnud see asi nagu pool. Et see ongi see, et ma ei hakkab töötlama, ma kirutan, et ma hakkam töötlama kepale. Ja kui ta järgmise käibitukse, ta vaatab kepale, mis oli see operatsioon, vaatab, kas ta tegi see lõpuni, kui see ei ole lõpuni, sest ta võtab uuestas right-ahead locking, siis hakkab see kasse tegema. Tekikselnad journal või right-ahead locking, ja seda kasutatakse ka Linux-is ketastale. Ketad samuti teevad endale nagu logid, et väga tihti kasutatakse, kes logid selle jaoks. Et tuvastad ära, mis jäi liimati poolelid. Ja see peab olema sisse eitadud protsessi endosse, et selle asja on tarkkarasse. Annebaasi protsessid peavad olema viisavad targad, et nad saavad logist võtta, et mis eeline protsess oli, mis oli pooleli sellele algukrasjist. Ja see on tegelikult suhtselt keeruline, mis juhtub, siis kui midagi võtla, et kui toesti midagi korrupteerud, siis võib öelda, et Annebaasi ütlele öelda, et teete start-container, Annebaasi ütlele, ma ei saa alustada, midagi right-ahead lockis korrupteeranud, ma ei tea, midagi ta teha. Ja siis administraator peab minema uurima, et mis protsaksioon ei pooleli ja midagi käsit siin korda tegema. Et teadud olukord, et see võib tõesti kõik täitsa metsu neme, et siis peab ikkagi inimene minema uurima seda. Aga ja, või tugev selle right-ahead locki kohtad seda kistikasutad, et saajustas teeme, et seda aga üks vägist läbi. Alaati midagi käsid. Olukorras, kus ma võib-ole ühe järgmiseks olla näitanud, kui suured on Netflixi mikro teenudad, ja mida ei oska, ei ole võimalik, et isa ei visualiseerida, ku palju need on, et alati midagi käsid. Netflixi teised teevad ka chaos testimist, kus nad laivis lasevad asjad Annebaasi näitas katki ja testivad kogu sesteemi ja tellu. Ja see läks liiga kalliks testida, et ei ole võimalik laivist teha koopet. See laiv on nii kallis, et see on lihtsalt lihtsalt ei ole võimalik koopet teha. Teadsisest chaos testimist täiesti laivis ja ei saa... On okei, kui kasutad teile video mängimine või filmimängimine korras katki läheb. Aga nad teevad sellist chaos testimist, kui ka natukse aadega, et karanteerid, et kui Annebaasi katki läheb, et siis asja teavad tõel. Ja väga hästi on võimalik konteeride abil tagata paralelisest, et me saame panna konteerides kolm koopjad konteerid tõele, et kõik töötavad erinevatud portid üle, me suuname sisse tulad pärilud kolme porti vahele, teeme näets nii Raun Robin kolmusjaoturid jaotus nende vahele. Konteeride teavad olema steitas selles mõttes, et kõik, mida nad hoiad, mäluna peab olema ajutine. Nad ei tohitsi mälus hoida midagi, mis on pajalik järgmise päringuteöötanese. Mälus võiks hoida ainult neid asja, mis on pajalik ainult selle päringuteäitmise, et kui järgmise päringuteeidame, siis me ei tohitsi tegelikult sõutada öelmiste päringuteese ootud anmedest ja mänualadest, nagu see käsimine taks olema konteeleete väline asii. Me võime ajutiselt pildi saallistada ketale, et käilitada mingi masinope teeg määgid selle peal, mis nouab, et pilt oleks netfallisistemis, aga järgmise päringuteeoksada maja otsalt ei ole maja. Me peame tegelikult eesame, et iga laal võib konteeleete haltust tarkvara migreeride konteeleete surgeda, skaleerida, väljamahetada, skaleerida nähele ka allaskaleeridas. Ningil hähpeal me tahame kolme konteeleeraaseandri oksida kaks konteele, millise konteele me kinni paneme, ku kõu ma ootame ja allaskaleerime alati see probleem, et võib midagi vahe kiitsema alla. Konteeleete elist on see, et meil on rakendused saavad juosta täiesti enamaltatud keskkondades, nad ei ole oma alasseatud, nad võivad jagata mingisugust file, aga need fileid on read online, nii et neid kunagi muudeta otsaselt, kui mingid muudatuse teaks, siis on lisakihiina nende peal enne kiitama ajutuse. Konteeleet on aesti lihtne, nagu liigutada, kui taas need isegi liigutata, aga saad seidma ja sama hiniks, kui sa te muu jäl üles, aga vajaduse saab ka mitreerida tokkere konteeleerid, et jääks meilusnapsot ja panmed kettastasnapsotne liigutatakse, aga tavasid seda isegi tehti erikub uber netse. Me ei saa me teha palju tehedama, et keskkondasid, kui me saame konteeleerid panna omavahelneet samu layeri jagama, et me ei tea, nagu keskkondades koopa tegema nii, kui me teeme näiteks samast konteeleer imidžiest võib olla 16 replikat, siis me ei ole vaja annetes või nendest alkfailidest koopa, et saavad need failjesid ära kasutuga. Konteeleerid on nii saa leeritud mitte nii tugevat kui kõrta omavahelneetapuul, aga ikkagi suhtselt head ja konteeleerid loomine kopeerime käibitene on palju kiirem kui kõrta omavahelneetapuul ja samat elis nagu elis, et saad juba lihtsalt saa leeritamas. Kui te hakkate looma nagu keerukama, et siis teeme konteeleeritapis, siis te oost te peate hakkama kankutama container-toker-komposi. Tõske käsi üles, kes on toker-komposi kankutamist. See on suhtselt lihtne, et põlimad siis siin üks blok on toker-rank-kuma, toker-rank-käs, kus te kõik parametrit, paepenavuus, standardsad kirja, et veeplad siis üks container ja siis erinev parametrit, et kas te kuiidite selle kõikist kaustast, kas tal on mingiselt mingi testrakonteeleeritel, kas tal on mõnid salapuseid, mis on keskona muutüad, mis port on ekspositud ja mis käes kaandud, et saa container-is toksudada. Tavastab lihtnese käst kirutud, et saab containeri emitsi sisse, aga mõnikord on hea, see on kõik, et see on kõik, et see on kõik, ja siis palju see, et saab container emitsi sisse, aga mõnikord on hea, see kasutat viitisema containeri pitti ja siis panas sa randkäs ka kohane randkäsu sisse, sest ilmes on me need procesi siinelmise ja oksutamise parametrit muute, et me saame siin kifad muutele, et ikka kaas poole poole papeid, et paname paname pane põlemud ilma, et me peaks olla tokkata niimoodi. ja tavalselt paraks. Nende võidate olla sinne eraldi nagu kirjatena Topper Composes, aga nende võib olega failist loeva. Siin nende ala mõetud, et nende on eraldi nagu kirjat siin samas failist Topper Composes. Siin on ka nähe, et nende on Secret, Postgres User Secret, Postgres Password Secret on siis failides poetud. Nad on nagu kirjat samas failis, aga nende asukost võib olla eraldi nagu failis. Nad on failis võistis keskkona muutööta naala poetud. Siin on siis hea, kui te selle template'i pärate kitst haabi siis se eläisalmast kaasa. Juhul, kui eritikudent Secret on kuski kittigi nooril kaustas või väljastol kaustast poetud, et nad ei pea olema alam kaustas. Siin ongi, ma parem üles Postgres ja me panan üles mingisels webiteenuse, millega me webiteenuse meiseb pildi, ma alam kaustatud, et see on Topper faili. Ja kui meil on mingit parametrit, näiteks me Postgres jõuda, mis on kasutaja parool, siis me siin saame aga midata samadele muutöötele. Kas eraldi, ma panan et paik ka või drag on etiks failid on abartad, et kus on kasutaja nime faili ja kus on paroolis faili. Ja kui kui kui nad on praegu nad kuulita tehtud. Ja siin saab isegi kerukamaks minna, et saab ka hakata panna paik, et mitte koopa, et näiteks sellest webiste, et ma taan, et webist oleks kolm korteereer, aga sellise liulud on portide kättevaatid olema, et peab siin oleks portide pandi, mis see panemaga, et me ei pananud, et see on kolm porti, neid 8000 kui 8200, sest muidu samasse masinasse ei ole võimalik panna kolm korteereer, et sama porti kuulama. Et siis peab olema ka portide reinge. Ta võtab need automaatsed selle reinge-ist alates alguses, ei ta kontrolli, kas port on kasutuses, kui on kasutuses, siis skipib selle. Mõnikord mul on teginu probleem, et ma proovin Docker Compose restartide, millegi pärast ta ei õnestu sama porti võtta, kun ajal, nagu container peab korralikult andu stopi, siis ta võtab järgmisev. Et seal on natukene, sest sellega tuleb ettevaatik olla, et need portid ei tohi kasutuses olla, aga peab kõesti skipib meed, kui nad on nitu. Aga ta võtab alguses peale 201, sest misti istja ma teha, et ma panen siit kui kolm hoopelt, leidis 21, 21, 22, aga on pärast kohvima, aga midagi välja spore, kuidas ma liidu see siia sellesse portid suuna, et kui ma näitis NGINXi containeri panen püsti NGINXi, siis ka seal jäts konfigureerimise viipaadresid on, nii et see on alati selline, et järjest kerõmiseamad läheb, aga see on väga hea, kui sa pakendata nagu mikrotenuseid siin üht ja Tocor Compose koku ja pananud korra ka tööle. Ja Tocor Compose tegelikult oskad neid nagu üks haaval ülespanna ja kontrollida, et kas kõik jooksevad. Ja siis saad ka panna neid siia. Panna näiteks siia. Tepends on, Postgres, idee on siis, et enne panaks sa Postgres ülesi, mis panaks see container, mis Postgresi täu sõltu ülesi. Selleks kontrolli tege järeekordad, mis järeekord on, et ülespanaks sa. Aga tavasult on ikkagi parem siia käskuri rakenduse sisse eildada, et kui ta saa Postgresi kõhendust, sa proovad vist uuaselt. Et täitsa louhulik peale. Siin on tegelikult aske kontrollida, et Postgres on vahelik, mis pärjegi vastavõrtuma on, vaidase see, et Tocor Compenerm alustab. Kui planeetises sa pananud reegmitsia tisse, kuna Postgres on valmis, sa panna teise containeri tööl alust, siis, kui enne on valmis. Aga see võimaldab, siis containerid käima panna, komplekt container käima panna ühe käsuga ja näites kithaad või pannagi kogusi infrastruktuurid kirjeldes selleks ühe Tocor Compos valinad, mida me taham üleks panna. Lisaks on võimalik, et Tocor panna tööl ja siis klastri peale, et meil on näiteks kuus serverid, mis jooksutavad Tocor Containereid ja me joinime nad kõik üheks klastriks ja siis panna meie Tocor Containereid tööle, siis terve klastri peale juba. Me ei pea Tocorid jooksutama ühe serveri, nad me võime jooksutama ka siis Tocor Swormina, kus meil on nagu üks appi, peale ka autume töid jooksutama, aga need tööd võivad jooksutama üks peal misuguse serveri peal nendest kuues näiteks. Ja seda näiten aga ei see ole võimalik, et mida Tocor klastriks on võimalik konfigurerida nagu üheks Tocor keskkonees. Tocor koodumia Tocor Paneetist on võimalik juba? Ia, itselt Tocor Sworma see on lihtsam ja kui Paneetes on nagu hästi kergu. Võib-olla mul on üks samm puudu, aga mis on vajalik, et Tocor Swormeetada ühe Tocor, masina peale on vajal instalida Tocor, siis on vaja jooksutada üks kas Tocor Sworminit. Ja siis teise, see prindib pendeleva käsu ja kui te kopeerid selle käsu ja jooksutad selle sama käsu prindib viie serveriga, siis viis rikki põhjooningad siia klastrisse ja teil tegid paari minutiga kuue nootine klastrit. Tocor Swormi loomine on täst lihtsalt. See veel eeldab, et masinat saab kooma ühelus, neid on võimalik instaleritud ja need on see, ettevallistus võib natuke kerulisem all, aga see käskude jooksutad on meil on vajal kuute käsku jooksutad, kus masinat üheks klastrit siia kokku panna. Ja pärast seda ma saan siin klastris jooksutada Tocor Run käskud asemel Tocor Service Break käske. Ja selle idee on, et ma ei nüüd enam jooksuta ühtekonteele, et ma ei vaidma tene teemuse, mille sees on üks kuni n konteele. Ja tagas ma määrad, siin oleks näiteks kolm replikat, ma määrad enam, mis on 40 ja ma määrad enam, mis on konteele, ja kui ma teinud, et käsku on enam samalmas Tocor Run, selle vahe on see, et siin see port tekib sellisena, et see port kuulateks kõik nende serverite peal ja väljas pooltu, et sama port rasutatavad suvalse serveriga, ma saan nüüd saata näiteks main node-ile pärin kuu porti 28.0.21 peale, et siit suunatakse liiklus sõistilendis kolmest replikast. Siin on sisse eedad kolmuseatud. Ma ei teha suunama liiklust teatud node-ipeale, ma saan suunata liiklus 1-pitmis node-ipeale või vähemalt main node-ipeale, ja automaatsed jagatakse siia tuleb liiklus kolme või ükslikku paljude replikate vahele äranistele on. Sisse eedad kolmuseatud või emal ta väga hästi tokas loormi abi skaleerida sõsteeme, niimoodi, et me seame üks kuni rohkem konteneet üles. Kasutatakse hästi lihtsalt sellist pannkoobin algoritmet jagada liiklus nende replika konteneete vahele ära. Väljas poolt mul jääbki nimaad selline port 28.0, et kui ma siia saadaan siis pärin kuu, siis saadatakse edasi, kas node 1-28, node 2-28 ja nõud 3-28, siis jäänud kohvalt konteeleerid või porti 5000, aga väljas poolt ma saan siis lihtsalt liiklus siia saata, ja ma saan jooksalt ära muuta mitte konteeleerid siin taustalt tegelt jooksalt, praeg on kolm, aga ma saan lihtsalt käsujuoksult, et tokas service scale vb1-le vb5-le, et mul piisab ühes kasutat näed, et 50 konteeleerid peale scaleerida ja ühevõi konteeleerid peale scaleerida, tohkes on lihtsalt lihtsalt nii imad, et nitu konteeleerid ei appist see jooksalt nende servete peal. Siin tegelikult on limitatsioonid, et kui te seda natuke ümber ei tee, siis see maksimum siin on tegelikult serveri tarvat. See on selletõtta, et tegelikult prooviteks sa panna iga serveri peal, et sama porti peal asja jooksma, ja ma ei saa sama porti peal, sama serveri peal seda porti kaks korda kuulata, nii et see defaultimeha saab sama paegi, mille konteeleerid jooksalt ja kui teid serverid on, ei tee anna, et anna piste, et konteeleerid on rohkem ligi tähes, rohkem cq, rohkem mälu. Ja kui te tahate, et saaksite rohkem kui teereed jooksalt, siis tuleb see porti ka selle tead, et tead, et pealist mord. See on kõikis väikilisioon, et kui meil on teenevast kolm replikat, siis lihtsalt ei jooksalt kolme võrkeri peal selles klustris kutagel, ja me tavast ei otsustad, kus ta jooksalt. Tokkas mormi on suurselt lihtne kasutada, aga suure huulga kontenele teha hallus läht keeruliseks. Ja teene asjumis läheb keeruliseks on klustri ketta avade aldame. Kui me peame mountimaan mingisugusid välised kaustasid, kui meil on anna, siis me olnud seal, anna, siis me olnud ter, anna, siis me olnud ter, ja me kasutame mingid molyumid, siis see molyum on tavas lokaalne ja me teame määram ära, et see server, et sa pannt siin ei oksutada, kui ta on siia võib ma mingid annaid saljastanud, siis me ei saa seda väga lihtsalt muha jooksutuda, kui need anned on saljastatud siia. Et tihti meil natuke tegid probleem just annebaaside jooksutamisega tokkas mormis, sest ketta alade volyumite hallus on natuke eba. Ma äitaksin efektiivne, aga ta on sulksed keerulne, kudas hästi seda hallata, et mul server alati jooksub selles noudis, siis kus need anned on olemas ja ta ei kasuta teise noudi anneid ja need asju. Automaastiskaleeristid on isäinneveteerivad, kii peab need scale-up meedodeid käivitama, aga nagist püütun skõptis selle jooksutamile suhtse flichtne. Ta ei ole nii stabiidne, kui teised lahansid nagu kuberneetes ja võrkude haldamine on võimalik, et ta saate igaroa hakkandis selle luua oma võrku, aga saate ka tokkere kompouse ja sisse kirutada, et loome spark võrgu, spark rakendise jaab sen edasi, aga nende haldamine reeglite panemine nendele, et spark võrgust ei ole lubatud andrabase võrku, midagi saata on, et mõnikord võrkude vahelise rootimis reeglite asjada paikapanemine võib suhtseb keerulne olla tokkere normuus. Ma jätan need vahel ja räägid nende kuberneetes laingus. Need on standaardsed viisid, kuidas konteerin halldust kasutada ja ma üpun ühele slaigile, kus ta võrgen tokkersvormi ja kuberneetest, et selleks, et hallab ka suuremat keskkond, on mis võimalik kasutada ka stokkerit ja kuberneetest ja näiteks, nii mõlemast saab kasutada klastriete haldamisele suuri klastried luua, saab protentsiönida üle klastrisel teenusele nii et sama teenusele, nagu kolmdes võrkliket näiteks. Meil on võimalik teenused, automaatsal leida teenuse nimetohjal, et kui meil on eteks poskress teenus, siis meil peab poskress teenus nii, et kasutama saame nime kasutude, kus saadub poskress ja tühendavam poskressi. Seda ja kormust on võialtas üle maailm mõlemus. Mida meil saad okkessu on, et meil on hästi teha sallestus lumi orkesteerilist kuberneetest, sest see on sisse eitadud ja lisaks saab kuberneetest ülesseada lisad hakkara, mis oskeb paremini sallestus lume ja voliumid automaatsalt liigutada, automaatsalt skaleerida ja automaatsalt anda luua uusi voliumid, kui me paneme uue konteerid ühels. Kuberneetest on ka võimalik paremi, tarkvarne versioni tagasid oma, et kui me paneme üles oma appist, tocker, konteerid version 2 ja see ei tööta, et me saame kuberneetest ilusti roolid takkida elmisele versionile ja tockeris see ei ole sisse eitadud nii lihtsastgi või. Kuberneetest oskeb paremini ennastat, ta on parandatud, kui midagi krasj, siis tihti on isegi sisse eitadud, et kui ei õnestasida parandatada ja mene varasama ja versioni tagasi, tockeris vorm oskeb meiteks tockeri konteerid restartida, aga ta näiteks ei oska juoksotada teise servere peal, kui ta selle servere peal ei tööta, aga kuberneetest võib valida, et ei õnestu selle servere peal käivitata või proovida teise servere peal selle samas juoksotada. Saladuste ja konfiguratsiooni haltus on kaks kuberneetest palju parem. Me saame saladusi tekitada kuberneetest olemitena, et kirjutada kuberneetest appist, et meil on oskras saladus ja siis teised konteerid saame üelda, et kasvab seda saladust. Toker sormis on salati fajlide põhine, et ta peab olema kaasas selle tockerfailiina, mitte tockerfailiina aga tockerkäsuka või tockerkompousefaili. Kuberneetest on sisse eidatud automaatna skaleerimine, et saab üelda, kuna peaks lisama või eemaldana konteeleid vastavad monitorimis parametri, ja kuberneetest on ka monitorimine sisse eidatud, et keeltud asjude saate monitorida kuberneetse enda appi kaudu, nii et saab nagu otseselt konfigureerida, et saate kuuluti, et et tockerkompouse sisse kirjutada, et kuna lisata ja kuna eemaldada replikate meilne konteeleid. Songi enamem kõik, mulle on paa slidii veel, aga ma jätan need konteeleid orkestreeenimise slidisi alles, saab iselukeda, aga need OCI, open container interface slidid ma siis räägin, kui panets laingu algus. Tegelikult parem nii mahu, etki sinna lainud esame siia. Kokku võteg, siis mikroteenused lihtsustavad mõnesmõttes hajussusteemide loomist, et me saame luua nad unikaalsete selliste konteeleid enna ja suhtusest kasutadastandaartseid appisid, tööde järjekordasid ja neid skaleerida, eriti, kui ma kasutam Tokers Formi, me ei kasut ühe sõlmest Tokerid. Tokers Form võimalda luua tockerklasterid, et me saame siis skalereid ühelta serverid, paljude serveride peale, järgmeste kordade me vaatame Kubernetest. Kubernetest on palju võimsam ja põhimast, et peab kõik kära automatiseerida, mida muidu peab operaatore tegema käsit Toker klasterid kuhul. Paljus obi on Kubernetest just suuremat konteeleid ja klasterid teidamise. Samast tead mikrotenuseid sistemi arvitektuuri palju keerulisemaks, et neid on lihtsalt palju raskel hallat nagu monoliitsed rakendusi, et natuke tuleb see ka ettevaate kolla, ka et mitte luua nagu siikend suur arm väiksev tenuseid, kui järgmine loegi me just vaatame, et mis aastat on nanotenuseid, mis on palju väiksevaku mikrotenuseid. Teeme ka praktikumis selle läbi, aga te ka näed, et need on tegelikult täitsa-täiset asja kasutatakse teist tüütbi, nagu funksionaasuse jaoks või mikrotenuste puh. Tõesti mikrotenuseid võivad olla epafeksidik tiisiamat resursi kasutus osas ja võid te näedid lugega selle Amazon Prime Media kohta, mis kasu nemad saaid. Võidsid paarsammu tagasi monoliidipoole, et nad täiesti monoliidiseks ümber ei teenud, aga kombineerisid mitmed mikrotenuseid tagasi monoliidsel, nad täiks mikrotenusteiks või midjumtenusteiks. Just see lokaalse võrku kasutamine, et kui tegelikult tegelikult pildifailide, videofailidega siis ei ole hea, et tõsta ümber üle lokaalse võrku, et ta on väga väga aegaseks. Hea on vältida suurpe mahtuda arme te liigutamist, nii et just sellist maasineopte mikrotenuste puhul lihti on parem nagu kasutada viiteid näiteks 5-i sisteemitele või objekts storage-i teenustele selle asemel, et kui tegi anmed ja piltte päringutega kaasa saada. Ja lihti ka, et töödi järekoht, et see ei panda piltte, või paneks see viidea piltidele näiteks selle asemel. Järgmine loengusest räägime siis nanoteenuste, ja tulevikus räägime natuke täpsemat kuba neetesest. Näedime natuke rohke mikrotenuste armitektuuridest ja sellest tandartsatest ka kontenerd liigestest. Ja viimases loengus räägime siis täielikult pilvepõhistest rakendustest, mis ongi desainitud, kas konkreestalt kuba neetes jaoks või natuke üldisemalt pilveteenuste jaoks, et räägime näedest täielikult pilvepõhistest ja rakendustest ja standardritestest. Ja teeme ka selle iseleb, et me võtame siis oma kasutuslo. Järeline kord me lisame või nad nanoteenuse oma kasutusloosse. See nädal me ehitame oma appi kaheks konteinerist, eraldavad siis selle raamatud otsinguappi eraldi konteinerisse. Siis lisame vahe mikrotenuse või nanoteenuse sinna juurde ja tulevikus siis jääme üles selle täiesti pilvepõhistest rakendusena ja me lisame ühe komponenti veel juurde ja paleme ka frontendi sinna juurde. Tekib me seal hästi lihtne Hardware Melee avaskript frontend, mis kutsub välja appi päringud. Ta on nagu sinna hästi puhas ja avaskripti põhin, et ta ei kasuta näidis reaktiivne sellist. Pige mõrpeltab, et kuidas neid päringud, appi päringud ja avaskriptist otsa välja kutsub. Ja siis lopud ja lopuks meil tekibki selline kahest mikrotenuse, ühes nanoteenuse, ühes frontendist ja mõndades pilvepõhist koos on selline rakendusmine, me lopuks asuret üles paname. Palun kontrollikega oma asure konto jääki, et kõike seda ära ei ole kudutanud ja palge mõned asjad kilmi, kui see on juoksmas teil midagi, mida praktikumii juheb ei nõudud, et see on juoksma ätakside, et iga küs kontrollik üle, et ei ole kõik rahma ära kudutud. Nüüd võib probleem tekeva ilmas, et praktikum ei tegema. Aga tänaseks siis kõik. Ega teil, zoomis siin pisim siia ole. Kui ei ole, siis ma panen zoomi väikselt kinni. Tänan. Kui ei ole, siis ma panen zoomi siia ole. Jaa, ta üle 10 ei olnud. See oli just alla 10. See ei maksa ütse midagi jah. See on teie tasku tänna. See on siis storage. Storage on lihtsalt se kontentri, et netvrakis hoidas ja hotmaili ei aastakõpfaila. See ei maksa ütse midagi jah, et nad isegi ei võtda, ei kisi raha vist aastakõpfaila. Ei kisi raha vist allotumbamise eest. Teoreetist võib pole, kui ta paate mingil hiigel suuret piljifailid sinna ja kasutat rohkem kui mingil 10 terapäiti kuus, siis võib lakata sinna kihima. Aga see võits olla sama nagu keegi ka mainis valasamas loengus, et see võib enamneam samamist kitpagents alavai kithab pagents. Et kui see lihtsalt hoidakse hotmaili ja jahastakõpfailet. Ningid püütanud saan väljakutsuda ei saa, midagi tunaamiselt ei jooksutata serveri pole kõik käivistatse teie browseri ja kõik. Javaskõtti ja hotmaililiselt teie browser käivist ja kõist. Et see on lihtsalt hotmaili ja javaskõtti failida allotumbamise.