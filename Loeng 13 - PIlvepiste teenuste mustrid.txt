 Tänet tulemast siis eel imasesse loingusse, et see kui rääkime pilvepõhiste rakendust arhitektuuridest, et kui ei me kord rääksime konkreetselt, nagu oleme rääkinud Kubernetesest, oleme rääkinud mikrolinuste põhiste arhitektuuridest, siis natuke näed kombineerime neid kokku ja rääkime täiesti pilvepõhiste rakenduste kontekstis, kus rakendused ongi designitud pilvees ülesseadmiseks. Ja järgmine kord ma siis rääkin sellised kokku, et võtama kogu aine kokku ja kattama kõik teemad ja rääkime natuke selistest kõikki nend kaetud teemade eelistest ja puudustest, ning teine osa järgmise näedaval loingust on eksamikonstituatsioon, kus te saate tulla kohale küsida küsimuse eksamikohta ja mina selgitan, kudas eksam ole makad. Nii et tulge kindlasti järgminevalt ka kohale. Aga rääkime siis pilvepõhiste rakendustest natuke üldiselt, vaatame selliseid keamiseid tegureid pilvepõhiste rakenduste designis. Osa on endest on teieoks tegelikult päris loookiliselt, sest nad on nii palju üle võetud juba täna päevaltes rakendustes, et nad enam ei tundu kidega väga uudselt olevad. Siis rääkime erinevatest pilvepõhiste rakendust mustritest ja ühes peamisest me rääkime selline teenuse mõrk, kus me eemaldame teatud loogika mikro teenuste rakenduste seest ära eraldi tasemale. Ja see on peamaselt kui selline kuberneetsesese speiifiline muster, mida väljas poolt vägem kasutatakse, aga rääkime ka erinevatest omaadustest ja elistest, mida see muster siis pakku. Ja kui teil tegid küsimise, siis küsige suulid viisilas zoomit chatis ka. See teema võib olla natuke kasjust keeruline, aga võib raskeest huomata, kui te ei ole ise nende teematega väga tutta varasamad. Mida siis pilvepõhine, et see tähendab, hingest, kelles on see Cloud Native ja võib-al see ongi natuke kirjaltavam kui eestikenne term pilvepõhine, see tähendab, et rakendused ongi designidud pilve jaoks või pilves ülesseaduseks. Nii ole designidud rakendust, mida oma serverite peal võib ülesseada võib. Vähemalt vajaab selle vahedavselt pilveplatsformi ja tihsti selleks vahedavselt Priva Killer platformiks tegelikult võib olla Kubernetes, mis tähendab seda, et teie saab ikkagi oma serverit, oma klastrite peal ülesseada. Otsuselt ei ole vaja, et oleks avalik pilvetenuspakkone kasure, vaid pigem, et see keskond, kus rakendus ülesseatakse kuhuda deployedakse, on siis pilvepõhine keskond. Kas siis ülesseidadud konteineritele Kubernetes-ale rakendused on pigem mikro-teenustapõhised. Isegi, kui ülesseadda Anne-basi, siis Anne-basi ise töötab pigem mikro-teenustapõhised. Tänab vaatame ka näitas poskres näitele, kuidas selline kõrg käideta või haia või öelapalli poskres välja näed, kui ta ülesseadab pilves või Kubernetes. Üldjuul on eeltused, et me kasutame DevOps ja sellist kiiret rakenduste ülesseadmist ja lanseerimist, et need rakendused on designidud niimoodi, et teha väikselt muudatuse kippis ja rakendus uus version panedse üles automaatselt siis kest testkeskonnas või kusilikin production keskonnas ja muidin seal tise kontrollide, et teha toivam iga merge peale või iga realisi peale, et ei pea iga merge peale automaatselt tööpeale. Ja me ei loo rakenduse liiguselikilve vaid pigene arendamigi rakenduse pilve jaaksul isegi pilves niimoodi näiteks, et meil ei peagi olema endal testkeskonda rakendus koha panaks kui perneete süs ülesest võib-al teises test namespeisis, kui nagu lõpkaduta digi ei täese, aga teie võib-al ei paja oma arendusteskonna oma arvutus. Ja täna algust peale siis rakendust jaaksul, mis on mõeldud pirmais juurult. Me kasutame Cloud Native Computing Foundation'i definitsiooni, et see on üks selliseid community sellised organiseksioone, mis proovib standardiseerida pilve konvisiit rakendusi. Ja nad standardiseerivad väga palju, mis on seotud kuberneetesega, et näiteks, mis peaks olema kuberneetesest toetatud kontainerete piltiformaadi. Selleks on valitud dockerfile pöhine pilve, või mitte pilve, või kontainerete piltide ehitamene, et ei peaks kasutama erinevaid viis, ja kuidas kontainereid ehitada, et pigem paljutik töötab standard. Või töötab viis nagu selleks standardiks, mis oli dockerfileid ja dockerpiltide ehitamene. Selleks organiseksiooni definitsioon pilve põhiste platformadi rakenduste haaks on, et pilve põhisus on Cloud Native Technologies that empower organisations to build and run scalable applications in modern, more dynamic environment, public private or hybrid clouds. Ta on nagu väga konkreetselt ei ütle, mis seal olema peaks, aga isakirjadise kohjal, mis seal samal lehen on, mida te võitte minna juurida, on, et selle lähenemist viise aluseks on just kontainerid, tehnuste võrgub, mis me ka tänna räägime, mikrotenusad tegale või 5-et APIs ja muu selline. Ja idee on, et tehnikat, kui neid rakendud on imoodi nagu on ette nästud, sa võimaldeid kiinni taha nagu vähe oma vahel ranged seotud. Ega komponent on pigem nagu eraldiseise teenus, kui teenus või targvõra, mis otsaselt on seotud või sõltub teisteist teenust, kestegangis pigem mikrotenuste põhised, kui siga rakendus on oma keskkonnast ja ei jookse kokku, kui teised mikrotenuse komponentid teised hajusust kõrni komponent kokku jooksevab. Nad on vastu pidavad, piht isegi iseparanevad, et kui mire juhtu, siis on rakenduse kuberneetes deployment template sisse eidadud, et kuna peaks rakendus restartima, millistele pidevatele, päringutel peab vastama, saaks teda kutsuda terveks teenuseks, et kui ta enam nendele teenuse kanegi pide vasta, siis järeikult ei ole enam terve ja minge ajapärast peaks tala restarti tegemult pood jäält täiest ära kutsutama. Nad on skaleerivad, juhitavad ja jälgitavad, meid on võimalik mende mitte ainult seda kasand on elus, aga ka nende olekud ja tervist on võimalik jälgida, ingliskelesensuobservabilitee, et me on võimaline saada täpselt ülevad, et kui hästid on töötab, mitte ainult seda kasda töötab ja mitte ei ole nii või kapinaarne, kasda töötab ja mitte ei ole tegemaid uutad hästi töötab. Ja me pead olema juhitavad, et meid on võimalik reaal ajas ümber konfigureeride ilma, et kasutavad midagi märkta, et rakendisem ümber konfigureeride, et kasutavad ei toigi saada ja teateid, et mingisugust teenuks teada käette saadevad. Ja kombineerides sellise tilvepolise architektuurid, Cloud Native lähenemise, automatiseerimise, DevOps metodologia või võimalikse sarendatel, hästi minimaalsem aevaga või väitsa väga tõluga läbi viia pidevaid ning ette aemakavama mõjuka muudatusi, et ei oleks seda olukord, et me võtame terve nädalat teema uue riliisi ja loodame, et see riliis läheb tööle. Võib pigem tähtse hästi väikseid, mitukorda päevas muudatusi ja nette hennustatav, et mis nende muudatuste mõju on. Pigem võimalatavad hästi väiliselt muudatus teha, mille mõju on. Mõju on hästi väike ja palju lihtsamene ette hennustata, kui see, et me teeme näitiga iga kuus uue riliisi või iga kuus väli-alaselt. Võib pigem seda teha, et iga arentaja mingisuguse feature muutmise või arentamise tulemus, et kohe teakse live keskompele mõudatused läbi. Kuidas sõelda, see muudatuse ja testimise vahel on võimalikult minimaalne, et vähendada selle ohtu, et samal ajal, kui see arentaja arendas mingisuguse featureid välja, siis teine arentaja arendas teist featureid ja nende vahel on konflikt. Kui need featureide testimise ajad on nii lühimiseks, kui vähemalik, siis on ka väitsema oht, et nende vahel konfliktid tegivad ja midagi väga kaltkuline. Pilve põistarhitektuuride peanmised omapused on, et me enam ei huvitu nii väga operatsioonisisteemidest. Kui me kasutame konteinerid kuba näete sa poode, siis meid väga ei huvita, mis operatsioonisisteemis kuba näete sa server jookseb. Kui me jooksutame asju pilves, siis me jooksutame konteinerid, nano teeluste funktsioonide ja meid väga ei huvitud, aga see töötab Ubuntu, Rocky Linux, Centos või mingis muus keskkonnast, teadest, et see on Windowsis või mida ARM platformi peal. Meid väga rakenduse, designistid oegis väga huvituda, mis operatsioonisisteem tagane. Nad on nagaseliselt operatsioonisisteemi agnostilised, et ta võiks töötab ükslikmist keskkonnast erikõnume konteinerid või kuberneetist kastuma. Me panelme rakenduse tööle õige mahog resursside, et me saame igale konteinerid remelata täpselt nii palju resursse, kui tal vaja on, ja limiteerida, et nad mikrotenuselt ei olegi luba, et näile ei olegi lubatud kasutada rohkem resursse, kui jahast vaja läheb. Me võib-olla ümber konfigureerime näid suhtselt tiltie kiiresti, et näiteks näile lisavad resursse anda, aga ei tekita seda olukorda, kus ühel konteineri mingi põhjusel on võimalik kasuta 250 kord rohkem mälu või ketta ruumi või cpu-ud, mis tõmbab kõik teised teene koomad. Pige igale konteineri ja kuberneete selle rankelt seabistame limiidid, et kui palju mälu või ketta alaja, cpu-ud on lubatud kasutada. Ja kui midagi ei tööta hästi, siis me vaatame logimisest, monitorimisest ja muudamele konfigurationid ümber, nullist alates me paneme väga rankelt paik ka, sest see kaitsad selle vastu, et kui mingit teenused rünnatakse või võeteks ülevõi, nende on väga innelikult mingisuguse bugid, siis ei onnesti kogu sisteemi koomad omata kui mõned mikro teenused üleva, mingapõi resurssega võib. Sen on sisse eidratud DevOps Continuous Delivery pig-er juhutus Eesti lieles. Kõik teenused, kui võimalik vähegi on, ise seisvad, et nad ei sõltu otsaja teistest mikro teenustest, see alati ei ole võimalik, mikro teenust, mis kasutad annebasi on andanpalliselt sõltuuses. Ja kui vähegi võimalik, siis kasutada automaatsis ka leeritamist, et ei looda selle peale, et mingit operaatorid konturis siis iga omid ja iga õhtul muudavad konfiguratsiooni niimoodi, et see onks rohkem replikaid mingitel teenustel. Alati seda ei ole võimalik saavutada eriti annebasi tepugul, aga mõnikult on vaja näiteks annebasi mingisuguseid saavutane, et kui ümber arutada, ku palju partitsioone vats olema vastalt selge, ku palju nõud on ja ei ole alati võimalik rea laehas annebasi, et ka leerit üles ja alakulad võrelikas mikro teenusti. Ja siis olme paasinu ja ka tagi õrst on tehti, et kui sen kirjat ja siis igal kirjal on näiteks ikka nii tees, ja kui teed ergi õrselt ära, siis näiteks kui ma olen vaasime näiteks. Kordi mene niimoodi töötab, aga ühtemad sa soovid kesed päeva nõud kolme nõud ja asjame viit nõudi kasutada ja sa soovid ühe nõudi juurde panne emat. Kui sa sa olemas ola sa ammetega teed, et sa peadks kõik ammet kõik ümber saflima kesed päeva, ku palju kasutada. Selled jõudus probleemid on, et taaks jõudu panna, aga siis sa peadks taga ammet ümber konverteerima ja olema armete mahusse. Kui sa ei saa niimoodi reaaläest teha, et ei saa niimoodi reaaläest teha, et midte ammetabasid aru teava konteineride lisane ematame, nagu millisekundite viimust, aga ammetabasid puhul võib olema sisse heitada, võib olema sisse heitada kotsasid, mis sa teadat. Aga me oleme vaatane kõite posköösi lähendamist täna, kus see ei ole probleem. Aga seal on teatud imikatsioonid, et pikem skaleeri maind lugemist kiirutud, midte niimoodi lugemist ei. Kas sa saast oma andne baasi? Et sul on kiirutud aluks 3. aande baasi, sa tahad skaleerid vii ande ale, et sa siis võtad kinneist 3. aande baasi ja te mõlevad standaist, et 2. noori. See võib olla, et jätsed olukorral sa keib, aga siis sa avutad rempikatsioonid aande lugemiseks, aga mitte kirutamist. Siis sa sa piikagi kirutada ennakorra, aga kirutamise efektiivsus sellest väga ei parane, kui sa ei jaka andmed reasas liidepartikioon. Ma pole 100 % ikintel oma vastusest, aga põhjimõtteliselt jah sa saaksid teha koop, aga see ei ole päris olemas oled ja andmed jagamine viie vahel. Ja ta on tegelikult ka seda, et sa saad paraleeselt ainult kolmest lugeda. Sul on kui valik, et lugeda kahest vee lateratiivselt kahele, aga põhjimist, et sa saa viest paraleliselt lugeda sellise liulikade. See on see põhjimus, et mis typ nii päringud sul on. Kui siin tuleb sisse päringud, mis on hästi paljuded kasutatad, siis tööste saad võib-al nende viie vahel, aga see on suhtsev keerulne halata, et sa osades hoiad teadud hultpartitsioone, siis teistest saad koop, et osadest partitsioonidest sa tegem taaksud, et sul on mindisuguna hultkanneid, sa jõgad andmed partitsioonideks ja siis nendest kõikides partitsioonidest on fikseeritud numper koop. Et siis on palju lihtsam halata, et onks siis Annebaasi plastristus on piisalud Anne vära repriseeritudu mitte, ja siis sul ei ole nii lihtne, et okei, teeme lihtsam koopaid juurdele jämaldame, et see kõik uutab alega. Et teadud Annebaasisüsteemid, siis on see sisse ehitatud, et sa paljad 2000 juurde ja taustal toimub mingi prosess, mis meid replikajad liigutab ja ümverlikutab, ei ütlema, puole tunni perast on see süsteem võimsam. Et sellised süsteemid on paremega kuskil esküell Annebaasisüsteemis, et sa annad see natuke teeroidelt kikki. Ma ei täna korraks vaatalista ühes näkida. Ja ja sinna sisse on pihti ehitatud kõik kiire taastumine, et kui midagi kokku jookseb, siis kui perneetises võiks sa võtta paar sekund suuest ülesseada, plus kui meil on skaleeritevuse ja replikajad teenuks peale, et meil on midu koopad sest teenuks teenuks teoks, mille vahel liiklus jagatakse, siis see pihti tähendab ja seda, et et kui üks replika kokku jookseb, siis ei toeks väga mõjutada teisi. Kui kõik kolm, ütlema, et meil on kolm replikad, meil on hästi peale kasutajad ja kõigi kolme kasutus on suhtselt suur, et ei olnud olnud, et kõigil on nüüd 8% resurssides kasutus. Üks näidest ärakukku, mis tegelikult võib olla suhtselt tuge signaale, et midagi tööta väga hästi, sest kaks replikad peavad nüüd hakkama saama sellega, mida enne kolm replikad ärakasutus 20% oma jõudusest, et näid enam kasutata pärin kõik teelindada, nii et kaks ei kruugi nii hästi hakkama saama kolm. Kui midagi kokku jookseb, siis kohe taastatakse olukord nii kiiresti, kui võimalik. Ja näiteks kubernetest on see sisse eitadud, et kiiresti tuvastada ära, kui midagi kokku jookseb tegse uuest üles jada. Näiteks on health check mid ja liveness check mid poodides sisse eitadud, et tuvastaks ära kas seda, et mida ainult see, et püütan progamb kokku jookseb, aga ta enam ei vasta pärin kõige korrekselt, et ta jookseb, ta töötab, ta kuulab porte, aga midil põhjusest näiteks, et ta oli annu lepas jõhendas enam ei ole. Ta küll võtab vastu pärin kui ta, kui ta ei vasta nendel korrekselt. Kubernetest on nagu mingisuguse mikropeenuse deploymentisse võimalik sisse eitada kontroll, et pärin sellel n-poodi peab vastama koodi ka 201, kui seda ei toimu 5 korda järjest mingisuguse väiksete lei ka sisteemokoodile restarti või seeki teeme näiteks ka mingi annapasipoodil restarti, et saab sisse eitada, et kuidas kontrollidega susteem töötab, et ära tuvastada kuna peab. Ja see ei ole nagu sisse eitada sellega genuisa kontynvoreksioon. Me vaatame ka teatud selliseid tüüppilisi tilvevõise arhitektuurikomponente, millest me veel ainasi ole rääkinud. Ja siis lähme, mul on just slide-i natukavale järe korrad, enne räägime 12. tegurist ja siis vaatame mõndasid tilve teenust arhitektuurikomponente, millest mainele oleme maininud. Peamiselt fokuseerime servicemõhjile teenuse põrkulemte mainitiga selles pilve põhiste rakendustes definitsioonis. Aga ma enne räägiks üle 12 sellist kõige olulisemat tegurid, mis on pilve põhiste rakenduste designimel olulised. Aga ta ei rakkenda ainult pilve põhiste rakenduste, aga sellist hildiselt, tarkkura kui teenuse pilve rakenduste puhul, et mis on sellised parimat tavad, mida peaks kasutama nende arendamisele ja designimisel. Võib kaks teis, ütlevad 12. juba poolet teieoks on tegelikult loogikult, et kui te olete arendusele vähegi tegelinud, siis kõik ei tule teile üllatusele või midagi väga uudselt. Et neid on juba rakendatud aastaid ja nad on siis heitatud kuberneetises desaili, need osaliselt on nad nüüd juba kuberneetises hetta ära inkumenteeritud, nii et arenda ei teene pise selle veel mõrtamaks, aga nad on nagu mõetud arvessa näende pilve põhiste platformide, et kui te soovite rohkem selle kohta lugeda, see on selle trailfactor.net, selle kohta aga kõna räägim natuke ülevaatlikud, et võib-olla väga sudavale ei lähed. Neli esimesed tekurid on koodi paas sõltuludet konfiguratsioonite tubiteenuseks. Koodi paas tähendab seda, et igal rakenduseks olema ainult üks koodi paas. Teid oliks tekid olukord, et meil on mingisõmene mikro telnus, ja siis arenda on oma koodi paas, siis teine arenda, kas liitub, organisaorist, et tema teab oma koodi paasiga oma versiooni sellest, ja siis mingil põhus on näiteks eraldu koodi paasad testkeskkonna kohta, production keskkonna kohta, ja tekid meil olukord, kus meil sama rakenduse kohta on mitu koodi paas. Et seda tulaks väitida, organisaorist peaks olema ainult üks konkreetne koodi paas rakenduse kohta, mis eksisteerid. Ja see peaks olema versioonitud hoitlas kitis kusagi, ja kui meil on vaja erinevaid versioone sellest, siis me saamegi teha erinevat branchid, erinevat rliisid, kui meil on vaja erinevata keskkondade jaoks nüüd väli lasta. Aga me ei tekida testkeskkonna ja production keskkonna kohta eraldi kit repositoori. Ja versioonikontrooli käitik, kuna sa palati juurutada, on sellees tarkvarjamisele koodi paasid asu pitves erinevasse peskkonda, et hoidan näites konfiguratsioonid imod, et meil tekib kokku pandud rliis, mis on mõnedud testkeskkonna jaoks, kus on oma konfiguratsioon testkeskkonna jaoks. Ja me saame selle sissemised tekitada erinevad sellised tervoops pipelineid erinevata keskkondade jaoks. Meil on isegi sama pipeline, mis kõigeval pusid keskkonna testkeskkonda, vaatab, et see tulemas on korrekne ja alle, siis pusid edasi production keskkonda näitud. Aga miks on oluline on selleks, et ei tekiks segadust, et kui arendad töötavad, et mis versiooniga, mis koodi paase, kui nad töötama peavad, ei tekiks selliseks konflikte, et me peame nüüd hakkama nituud koodi paasi merge-ima ilma, et meil oleks ma üks kit keskkon, mille see on sisse ei tega funktionaalistus, et meid muudatis merge-ida ja kokku panna. Teene tekur on rakenduste sõltuused, et iga mikrotenus iga koodi paast peaks konkreetselt eraldama pakendama põrkoma sõltuused hõlmates muudatis kogu sisteemi mõjutamatev. Meil peaks olema oma keskkond, olguse konteiner, olguse virtual environment, olguse mingisugune muu mikrotenuste teised keskkonat tockerist või kui põrneetest eraldi. Siis on vaja, et kõik sõltuksed, mis see rakendust kasutab, on pakendatud selgelt, et ta täiteks ei sõltuks mingitest sõltuvustest, mis keskkonas on, kunagi teine asi installeerid enne seda tarkkure. Kui te näiteks, kunagi arendast H2 maped use mooduleid, siis on tegelikult hästi vastik, et eksisteerid mingi suur repositoorium, kus iga moodul on alam kaustades. Ja alam kaustades olevad, tarpkora installeerimise on vaja teatada asju ülem kaustades, nagu ka installeerida, aga kui te kõik ülem kaustades installeerite, siis asjad laad kahti. Kui te tegivad sellised väga imelikud sõltuvused moodulite vahel suurdes, manollitsetes projektides, et kõige parem on see, et iga mikro teenust saab installeeride täiesti eraldi seisalt. Ei ole vaja, et importida mingisuguse teisi püütan teekke, linuks paketste kui saagid mõjalt repositooriumites kuna tavalselt mõned asjad installeerideks jäik. Pikema on tähtis, et kui mikro pealus on oma koordne paalis, siis kõik väärikud sõltuvused on saa kirjeldad, et isegi siistud, et teate, et tõenalselt sõltuvused on olemas teatud linuks keskkondades. Kujutakete, et teil on mingisugud püütan rakendus, see kasutatav puntu docker image-it selle püütan rakenduse ülesseadmiseks. Puntu docker imageid tulevad kaasa mingisugud teatud linuks käsud või püütani tegid. Te ei pane oma containeri requirements-file, te ei pane oma dockerfile neid kirja, kuna tavalselt oot puntu dockerbaasimand image kaasa. Aga siis, homme on teil vaja selle ülesseada natuke teises keskkonnaus, näiteks armipial, ja te kasutate natuke teist upuntu versiooni face image-it. Te võidakasutatud upuntu aseme altpaini, et te proovite kasutada näiteks mingist muud face image-it, see siis käsutad kõik. Ja siis te peate uurima, et mis näid asjad olid upunta face image-is, mis minu rakenduse jaoks oleks tegelikult paialikud, aga mida meie arendada, nagu kirja ei pannud, rekoanudusfile või dockerfile, et täks nagu veegedkest olema või kurlkest olema. Et kui sõltude liiga palju nagu nendest eelmiste keskkondate definitsioonidest, siis tegelikult teie selles repositoorimis ei ole kirjas, mis on need ranger nõudad teekidest ja minuks käskudest, mis on vajarik, et teie rakendus töötas korrektselt. Et kui te toetate liiga palju mingitele välistele asjadele, siis te kunagi ei tead näed, et su puntu järgist dockerf image-ist ei tehta mingit väikselt muudatusi, et mingiselt see ruumi koko hoidmise jaoks enam kurlukest ühele kaadud. Ja siis teie rakenduse jaoks on sa rangered väära. Et siis kõik väälikud sõltud, et teaks olema defineeridud selle sama projekti seis ja tähtis on ka, et need oleks olt suhtse täpsalik. Et ärge kunagi kirjutage niimoodi, et oleks nagu, et minu rakenduse jaoks kui on vajad, oleks eksisteeriks Python Package Flask. See töötab tänas, see töötab järgmine nädal, see võib pool aastaväest töötab järgmine aastaväest ära me tööd. Sest installeerid teise liidu uus Flask versioon, mis ära on selles keskkone se tööd. Et seda meil tihti praktikumit juhtub, et üks aastav aastav aastav töötab, järgmine aastav ei töötab, kuna valitud mingisud versioonid, et näiteks Flask peab olema suurem kui C versioon, ja siis mingisugune krypteerilis paket peab olema suurem kui C versioon, aga siis krypteerilis paketi jäi uuendata, aga Flaski uuendataks ja Flaska uusime külteerilis algoritme, hata te peab S-i pakkuda näiteks, ja siis enam ei töötab. Kuna peab natuke nagu tagasi rollima Flask paketi eelnevall, kuna seda ühteen paketi enam ei toa, seda veel ei ole uuendatud. Tokkerite keskkondade loomiselt peab olema suhtseb ranga, et pange teekide versioonid vähemalt vaheämikudega paikvad Flask 2,5-2,7-räteks või, ja siis kontrollid üle, et selles vaheämikudne asjad töötavad. Ja siis kui järgmine kord Flaski uus versioon välja tuleb, siis keegi mingi arenda peab üle, uuendat Flask versioonid, eesti pärast see töötab, uuendat kõik muudle versioonide vaheämikude ja siis kõik asjad töötavad. Sest teed seda ei märka, et kui näiteks mingisuseks kuperneetases lisataks uus nood, ja see nood tood tuma pallal Flaski kõige uuema versiooni, ja siis see rakendus saab kakki, kuna see enamod lihtsalt ei tööta. Ja te ei näe sitä kohe ka, et ta ei tööta, vaid peata lohides kuski välja, et see on, et miks ta enamod ei tööta, ja siis isale saad taru, et kuna uuendatud Flask versiooniga, mingi teisel paketid ei tuha, et ta vaatab, või nende vaheamikud rankamalt paigas. Ja siis Flaski versioon oli lubatud põrgemaks panna, aga teiste paketid versioon ei olnud lubatud panna, ja siis see näed põrgemaks. Aga kui onki kaks paketi, mis ei ole enam samuga, et mul onki näiteks haadete pesraatu ja siis onki see Flask. Ja et näiteks mul Flask nuuab sama teha versiooniga, et näiteks on Flask 2.1.6, siis nuuab see vastavalt haadete pes 2.3. Aga see töötab nii Flask 3-l, või ka Flask 2-l, aga see haadete pes versioon peab vastavalt sama numpre kalv. Aga kui see onki ülepanna? Te saate nagu selle hetke, kui sina testid sa panert vaheamikud nüüd paik ka, et nad on maksimum versioonimis nubatud. Ja siis järgmine kohd kus Flask versioon välja tuleb saavu kontrollid üle requalmets failiga, et kui sa Flaski versiooni uuendad, mis nad järgmised ka peavad olema, ja sa testid, et töötab jälle siis muudat requalmets faili, et sa ningi arenda teeb selle testi läbi, et kas see uus versioon töötab. Seda saaks ka automatiseerida, et proovida, kas uus requalmets faili töötab, või mida töötab, või töötasid scrollbackidese. Aga põhimest, et kegi, kes sul ülekontrollima ja kui seda kontrollimist ei toimu iga nad, kui saad ennad, siis tegijad proovia. Aga siis avad niimoodi, et suurlise teed toimib kliimid, mees keskkonnest requalmets ütleb, et kas sul on see paad või teine paad? Jah, et lihtsalt teaks, et eraldi requalmets failid erinevalt ja testomete jaaks. Ma olen näinud seda, et on requalmets punkt production, requalmets punkt testing environment, et kui seal on mingisugust erinevalt, siis mõnikord on isegi projekti, mis ma olen näinud, et eraldi requalmets faila. Kes kui iselest saaks vist ootgi seelt selle kõrgust? See on rakendusega saab palna siia siin paikane sissele, et edasi asjad, mis kontrollivad. Aga ma ei ole seda prosentikindel, kas nad saavad saada ainult taadikult teha ilma reaast prooks. Mõnesmõttes on ju lihtne. Ma ei stallin ainult flaski, ma ei defineeri ükslikit eest packageid, flaski installeerik kõik, mis tema ajaks on vajalikud ja kõik asjad töötavad. Ma ei installeerik isele, et paketit saate pesjad vajal. Mõnikord seal ei tööta tead kestondades. Eriti pilvast, kui pill valmistab ette teile püütan 3.2.3.11 runtimei ja teie ei taade sinna piltitöötas tekki juurde installide. Aga see ei tööta, kuna pilvateid on paketilis, seda panod mingisugust tead kõik krüpteerimis paketi, millega tegime konflikt selle vahel. Ja ei saa ka tisti seda lihtsalt uuendada, sest mõnaid mõna põhti, et mõnikord on asjad lihtsalt tekivad. Aga kui teel on täielik kontroll oma mikro teaduse kestonna poolt, et ise teete tokkarpalli ja tegid palju paljumiseks, siis on selles mõttes vihtsam. Võib-olla te saate sinna sisse ehitada nagu mingisugust kontrolli, näidid siia siia pipeline, mis kontrollid üle, et kas on mingisugust võimalike konflikt rekordnatspallis. Aga saab looda, et kui te flaskid, flask jääb versioon istaleerib kõik te maaks vahelikud asja, aga siis sõltub, et mis on neid teise paketid, mis teieks vahelikud on. Ja kas siis nende paketide vahel on mingisugust konflikt, ei ole mitte. Ja kui eksist erivad rakendusad, mis ostavad siin nagu automaatselt teha enne installeerimist või oksetamist, sellest võiks olla hea, aga tihti ja rastist aru saada, sest jaa, flask jaaks on võib-olla nii mingisugust paketi 1.3 versioon, teise jaaks on 1.14, ja siis loodad, et te installeerid 1.4 testis asi töötad, et nad saavad nagu see paketide haldur, mis tip isa oskap selle teha, et ta istajad kõik uue paketi, aga mõnikord sellest isav tegud konflikt. Ja üks paket, sellel 1.4.20 ei tööta teine, vaja püstöö 1.4.20, siis see on konflikt. See ei ole nii keerule problem, et pigem ärge ei jätge versiooninumbreid panemat, on see mõtes. Pangeleks konkreetne versiooninumbre vahemik või mingisugune major versioon, et 3.6 suurem ja 3.8 väikse, et mingisugud vahemik panne paik ka, mida tult ole, et isa ülekontrollid ei teada, et see töötad. Aga mõnikord ikkagi tegid jõud progéli. Ja oht on pigem siis, kui see lihtsalt ei panegi välja nii numbreid ja lood on, et tulevalt, kui see töötab, siis kui uus flaski major versioon väige tuleb, et see töötab. Aga tihti ta ei kõugilise töötada. Kolmas tegur on konfiguratsioonis. Selle mõtte on, et konfiguratsiooni teave eraldataks ja mitu teelustist ja muudataks konfiguratsiooni või töövista kaudu konfigureeritavaks väljas pool kood. Siin on päris mitut asjad. Yks on see, et saate mõned asjad hard toadiga, et saate mingis kus ande vasuurli panna koodi, seda kindlasti ei toeks mitte kunagi teha. Parem olaks see ande vasuurli luge, et kas .n failist või sistemi muutujast, et see saaks sitte erinevate deployment pipeline'ides ande vasuurli purli ära muuta ja saaks ilmakoodi muutmata, ilmakfailja muutmata, nagu erinevades keskkondis asi üleksseadad. Need asjad, mis on vajalikud konfigureerita vahe peale erinevate deployment'ide erinevade ülesseadmisi, need keavad olema konfigureeritavad kas konfiguratsiooni failina, mis ei ole kõige parem või siis näiteks keskkonamuutujana. Üldiselt on kõige parem teadida keskkonamuutujana, sest ma saan teha näiteks uue docker-runni ja docker-runni muuta keskkonamuutujana. Kui ma saan ka teha niimoodi, ma kirjutan üle mingisuguse konfiguratsiooni faili, näiteks ngenics.conf-faili vastavalt väärdustele, mida ma saan, kui ma soovin uut poodi ülesseada ja siis mul on seal konfig map kasas, mis ütleb, et nüüd muudase väärdus millekski muuks. Kui mängisugune liitlusejaotur, mis jaotab liitluse kolme serveri val ära, et kui ma talle tema uuesti üles jääma, võib-palve pean tema conf-failis mingi IP-adress ära muutma, siis tegelikult ei saa seda alati teha susteemni muutujate tasemel. Mõnikord peab konfiguratsiooni faili intergenereerima, aga kui peal need, see näiteks on selleks väga hea võimalusolant, et saab konfig mapi defineerida, mis lubab tünaaamins, et genereerida konfiguratsiooni faili teiseisuvastavalt mingitele muutujatele, mis tuleb deploymenti ka koosladeks, kas mingi teampeadressid või mingisuguse annavaihtse urmiidulid või portide tundrit näiteks. Sest kui meil on targpane olemas, mida me soovime, on panna testkeskonda, production keskonda, mixedaging keskondas alati mingisuguse mängisuguse mängi väärguseks jäävad muutuma, kas või IP-adress või portide või annavasi aadressid. Ja kui me saame konfiguratsioonimu muuta, tünaaamiliselt ilma, et me peaksime yhtegi konfiguratsiooni faili muutmata, me tihti saame saada teha ilmakta, et me saame tocker image-it ei pea ümberpidima, see on pige pare. Aga kui peal neete soovimaltab, siis tocker image-i sees, põhimest, et file ülekirjutada tünaaamiliselt ilma, et me peaksime tockerfile ündag muutmata, me saame lihtsalt võtta rekistrilt image, defineerid ta la konfig-mapi, panas image püsti, aga konfig-mapi tulemus on kirjutudeks üks isenne konfiguratsioonil faili üle ja põhimest, panas siin uuesti jõupis mountimine, mis file asandab ära uuaan filega, mis on künne aamilist kindel, et jõudsa. Päris mugav. Et see siis ei tähend, et kui meil minget isennefaili on vaja muuta, siis me enam ei pea tockerfile, või tocker image-it ümberpidima. Ja siis selle juurde tulem, et kui meil on mingisubes tuki teenud, siis andme paas. Kui sõnumete järekord, pilve file storage, teate seda praktikumist päris palju teenud, et me paneme meende adressi kaasa siis süssteemi keskkona muutuena, et näiteks, kus asub Azure File System teenud. Me ei hardcode seda, me paneme mingisussteemi keskkona muutuena, et miks sütved, kus asub. Ja tänapäele see ongi niimoodi, et me enam isegi kasuta IP-adresse, me kasutame unikaalselt resurssid, identifikaatoreid, URIsid või URL-le niimoodi, mis defineerid läpsed ära, kus asub. Me ei tead, et IP-adressi pilved ennast pakku annab meile hostemim mingisubse päevi ka, mille taga on meie andme paast. Ja kui me soovime, et keskkonast teist andme paasi kasutada, siis me pahetame selle tuki teenuse aadressi vitsalt ära. Et igal tuki teenusel, kogu sa andme paas sõnumete järekordis iganas, on unikaalne identifikaatore, mida saab siis veelne pahetada. IP-adressi tegab palju hallel, nad ei ole tegelikult unik kaasad. Juhu IP-adressi taga võib palju teenuseid ja IP-adressid või tegab muutuvad. Et need on problemaatilised, et kubernetises saab kasutada teenuste aadresse, et tekitada andne paasidele, siis ka kubernetises teenus, mis viitab õige telepootidele, kus viitus jõu võigile kohale. Ja me vajame ajadnud, et tuki teenuste muutmiseks nende URI-t väljamahetuda. See on need resursid, siis vakaadus lahti võimalta sõoksalt väljamahetuda igal, kord, kui me uuesti ningis muidse teenuse mitte teenukse üleksame. Et tee haksa tegelikult ei ole midagi väga uutusti, oled seda näin, ikal poolel. Meil peab väga keeruliselt konfigureena, kus andme paas asub. Näiteks, Arkis, mis on see GeoIF ande paas, mina soovisin konfigureerida mindist, kus andne paas olikena, ei ole võimalik. Ainult ka võimalist, kui tähad teha on, on minna ühta serverisse, oksutada putan scripti, putan scripti, genereerid ande paase connection file, siis aga ande paase connection file panasid teadalt kausta, ja siis läbi veelid teenus on võimalist andme paas kasutada. See on väga himelik mitme kotsessi ja sammud selleks, mida andne paasi konfigureerida. Ja minu aks on see, et loomulik, et ma saan minna veebi leed, näiteks välja vaetad, et ma sooveks andne paase kasutada, kuski panan andne paasi hurlii, kas või andne paasi IT-aadressega, ühtegu sellist asi olevõimalik, et jääb reaaselt genereerima mindist mida see on fiili, ja see läks andeks jätu piirtan palju, et juoks seda fiili serverist, kus on litsentsolemas, et jääb reaaselt genereerima siin on. Üks asja, mida oleks ka hea eraldada, et meil ei tegiks ailu ühti sellistki aarsad fiili, mida me üleseame vaid me jääksime eraldama, nagu sellega tarkvara eitamise, pilgimise, tarkvara enleisii ja tarkvara käivitamise artefakid. Mis on siis ehitamine, et me võtame edekse oma C++ programmiga ja teeme sellest paineri, väljalaskmina võtab selle paineri ja panaks sinna kaasa konfiguratsiooni muudkõp, et näiteks, mis on andne paasi hurli. Ehitamine on, et meil on ainult oma tarkvara nagu väljalased, kas võib püütan kaust või siis püütan zippile, või siis väljalaskeb sinna kaasa panaks kõik need deployment informatsioonid, mis on see andne paasi hurli, kuhu see rakendist peab siuhenduma, mis on konfiguratsioon, mida seekord, kus ta jookseb, püüks vaalik kaasas olema. Ja käivitamine on siis, et sellest servades, kus ta jookseb, kõik vaalik on koos, et mitte midagi oleks vaja pildida, mitte midagi oleks vaja lisaks panna, mitte midagi oleks vaja lisaks konfigureerida. Et siis üldkihul on ta täiesti valmisehitetud nagu selline dockerfile, kus on ka kõik vaalik konfiguratsioon olem, mis on siis näite kuberneete selle manifest, mis kirjaldab, et kuidas ta ülesseada. Miks see vaalik on, et kui midagi oleks vaja põetki ja meil on vaalik, et sest see seda parandaks, siis oleks hea, et kui sest see saks lihtsalt uuesti ranni uubstuda, ilma, et midagi paks uuesti pildi makkama, et midagi paks uuesti konfigureeri makkama, et oleks hästi kiire, et saaks selle mikroteenuse lihtsalt uuesti ülesseada nagu sekondiga vähendu sekondiga ja ei tekis seda olukord, et kui me käeme uuesti dockerfile, pildi makkama ja siis teadud põhjusel, kunad seal mingit C plus pluks, package distallerid, et sa võid pyütoni pakette, ei ole võimalik allotõmata vaik, kui kompileerimakka võid, mis sa võid väga kaua aega võid. Paremat lihtsalt, et kui lokaalsest rekistriest saaks docker inni sa allotõmata käivu panna, et võibas allotõmata võid ta panata ka aega, aga üldjuul on tähtis, et sesteemid, mida ülesseadaks saaks hästi piiresti ülesseadavad ja ei oleks mingis, mis te leid seal. Mis saad selle vahelise väljilas ka ja teelitamise tapid? Väljal asub sul näiteks kusagi kitis, et sul on koku package jõutud zipfile, mida sa saadad dockeri rekistrisse. Sule põhimõtteliselt väljalas, kes on kõik konfiguretsioon ja asjad olemas, ma mõtlekits, ma saan paremat näiteks väljamaailda, kus käivitamine on võib-olla juba alla laetud docker image ja supernetese konfig koos. Näites, podi, manifest ja allotõmatud dockeri. Ütleme eitame, meid kütun zipfile, väljal asumine, et me tekitame docker imagei ja käivitamine, et meil on docker image, nad allotõmatud ja sellega kaasas selle platformi, kus ta üles siatakse speciaaline konfiguretsioon, näiteks see podi manifest, et kui kublet tõmbab kubernetese annan kohasest alla selle podi manifesti, mida ta jooks on pananud. Et siin väljalas, kes ei prugi olla seda väga speciaalist informatsioon, mis on pajalik selles serveris, kus ta jooksab. Ketsmõttel on see tihvõlssealistus, aga see run ajal on see, et mul juba on konkreet seda, et sannabasiparoolid ja uuletud, ve? Ja, et näites, väljalas, kes on kõik konfiguretsioon, mis on pajalik kusagi üles teada, aga kui tõesti välja vahetavaks näiteks annabasi URL, siis on vaja näiteks sigaret ära muutama. Käivitamise aal võib-olla on sul pajalik teada täpselt mindisugustlisad lisainfot, mis on seotud selle docker nodeiga või selle Kubernetes nodeiga, et näiteks, mis on mingisuguse teenuse nimi. Väljalaske, et on võimalik siis võtta ja panada testkeskonda või production keskonda või mingisel kolmandaste keskonda, aga käivitamine on juba konfigureerikud siin testkeskonda näha. Et see on testkeskonda speciaalised asja, kui polemas ja orkistreeri on võimalik peale lihtsalt restarti tegema või kustuma ja teema panne, et orkistreeri enam aegu midagi tegema. Ja võite natuke lugele, see on täpselt informatsiooni, et ma peast kõik, et enam ei mäleta. Ma kohraks vaatan, kas mul on märkmed, et see oli midagi pegas. Tavasti märkmed väga jälgi. Ei ole väga lisaks midagi. Procesid. See mõtta on kada. Tänab olul dockeris väga hästi ära implementeerikud, et ei peal seeks ole väga mõttanud. Kõik mikrotenuseid taakse, et töötame eraldiseid ja protses siin on mitte eraldi lõimel, et ei protses ees. Et kõik see protses kokujaoks, et see ei toeks mõõdlada teisi teenuseid, mis seal jooksavad. Et kui me tekkitame mikrotenuseid ja jooksame näide eraldi konteele, kes on automaatselt meieks näge ära tehtud. Tokkeri konteele, container, tin container või üldiselt inud container pakuvad isoleeritud keskkonna kõigile teenuste jaoks. Et see on väga sisse eidata mikrotenuste ja containeri poisele lähemisena. Portnede sidumine on ka see, et iga mikrotenus paks jooksma iseseisvalt ja konkreetse nagu kaase porti peal mingis masinas. Et kui ei toeks väga tekida seda olukorda, et selleks, et üks mikrotenus ühendaks, teise mikrotenus, sest seda peab ühendama mingisuse vahe kihi, et näiteks läbi n-genics. Ja siis n-genics otsustab, puhu edasi suunata. Miks on probleem on see, et meil on tegelikult hea kasustuda porttid kontrollide, kes teenus on üleadud. Et kui meil on konkreetne mikrotenuskontrol, kuulad konkreetselt portine, kes 80117 või 80117, siis suvalne orchestreriamonitoorium võimene vaatama, kes kaeg on mingi potsest, et kes raporti kuul. Ja selle põe, et on iba võimalik otsustada, kas see process on ja kui see mikrotenus töötab korrektselt, põe on näiteks maha juoksund enam, et raport ei kuula, et me saame linuks tasemme kontrollide, kes teegi kuulad raporti ja mitte. Kui selle mingi vara vahel, näiteks porti 80117, mis suunab edasi selle mikrotenusad mingil teisile portile ja me seda teist port ei tea, siis me ei saa kontrollida, kas mikrotenus sooksad. Ja kui iga mikrotenus või iga potsest sooksab oma kuulad oma porti, siis see tegelikult on hea selleks, et ka nad olaks ka jääb täiesti eraldatud, et ei tekik seda olukord, et me saadame kuulvi liitust ja kõige kuulab seda pealt. Et linuks ei saa ka olla ainult üks potsest, mis seda porti kuulab ja natuke rohkemisele tsooni tagab. Ja lihtne ka näiteks panna, et seal meil on API, API kuulab porti 88 serveris ja tahama API repliceerida ilmakuperneetest, et ta mida tokeris teeks, et te näiteks, et panna tuua API replika töötama 2021 peal, 2022 peal, 2023 peal ja siis kasutete midagi, mis nende portide vahel liiklusära jagab, et parem on niimoodi teha, kui hakkata nagu mingisugust teisi viise proovima, et kuidas liiklusära jagab, et näiteks rakendus töötab ühe porti peale, et siinna porti peale siin selle porti peal jagab, et kõik replikat reedida vahel liiklusära, et see ei ole kõige parem vahel niisand, pigem on parem seda teha portide tasemane. Meil on väga lihta portoja ümbermätide, kas tokeris või kuppeneetest, et me lihtsalt ütle nad suunad siin porti peale liiklus, et see on kõik, mis vaja teha. Ei ole vaja mingid erilisi muid võimalusi väljamõed, et kuidas me liikluse ümbersuuname, et me saamegi kasutada portiselt ümbersuunamiseks. Ja kuna see on kasutusel võetud, siis liiklusahaldus kuppeneetest samastest vastadest suhti flitne, et meil ei tea, et isegi olema tarkku aram, mis tegelev liiklusse ümbersuunamisega, ta võib lihtsalt konfigureerida IP-tables VG ümber. Et Linuxist tuleb liiklus teadud adresid, et porti peal suunaduks lihtsalt õigise korti ja kõik, mis vajalikult tead, jooksta üks käsik, ja IP-tables siis üks regel juurde panna ja on saavutatud see, et Linuxi tasemel suunaduks õigisei populiiklus ümber, et me ei pea ehitama mingisugus tarkkuara sinna vahele. Ja see vältib seda, et meil peab olla mingisugune tarkkuara, mis edastab ühele tarkkuarele, kes laialjaga. Selle probleem tegib see, et see vahepeal tarkkuara tegib kudelikaaljaks. Meil on parem, et Linuxi võrguliideste tasemel kasutada tulemyri-räägled ümbersuunamise teha sellase, et me paneme peitam mingi tarkkuarad vahele. Parem on vältida sellist mingisugust hästi kavalai viis, ja kuidas me suuname liiklused edas, et parem on kasutud Linux portga. See on tege efektiivse viis, kuidas liiklus ümber suunad räägletele pitkalt ennustada. Kui peate, siis saab vältida IP-tables siit ja tulemyriti kasutamist, aga sellise juhul teab kuhbleta tarp praeise vahendama, et liiklus tuse ei kluubi olla nii-eval. Ja sama haepsus, et kui meil on vaja skaleeride sisteeme panna rohkem mikroteenuse replikait, kui meil on vaja parandada mikroteenuste jõudlust, et rohkem pärimpüt saaks ära töödeda, rohkem pilitöötus taas, kes ära töödeda, siis pigem skaleerida, või ma riisam taas, et paneme kopejuuda. Meil on alati võimalik ka vertikaalse skaleeride, et paneme rohkem resursse, paneme mikroteenuse suuramata selle serverite selle tööle, aga tihti seal on peidetud sellised skaleerimist kahandavad tegurid sisse eitad, et näiteks, kas meil peab olema mikrit ja mikroteenuste sissemid järjekorrad, mis jätavad meeld, et ku palju kraaeg on piditudus taaske, mida on saadatud sellede mikroteenusele, et kui meil on ainult üks ästi võimas mikroteenus, siis ta võib-olla peab kinge suurst sisemist järjekod oidma, aga kui meil on hästi palju neid, siis võib-olla neid individuoasad järjekod, aga neid palju väitsemad ja juhtub pähem halba asja, kui midaid koko jooksad. See on midaid poeves, et näiteks on ka limitid Linuksist kotsasid, et ku palju üks kotsas või palju pidene lahti hoida, kui tihti need on pidem kogu serveri tasan, aga mida niimekal ei ole kotsasid kasanud. Et lihtsamas skaleerida niimoodi, et me tegitame palju replikaid, kui et me proovime rakendus üleseda niimoodi, et ta saa hästi palju mälu, hästi palju CPU'id, ja ta hästi suureks virtuaalmasinast, et tihti on panna efektiinsa palju virtuaalmasinad tööle. Kas selle töötab, et kui midagi väike virtuaalmasin või väike, konteiner koko jooksad, see mõutab pähem, kui koko jooksad mingi siin üks väestest konteiner, et see on üks väestest virtuaalmasinad. Kas see on probleem, et sul piirat arra fali pide meidlahti? Kas see ei teki sulle tokkari ka üldiselt, et sulle tokkari on üks protsess? Et kui sa tegi konteinerid, neid seda, mis seal võihtahavad oma 10 fali rugega, siis saan mingi piiri läis, et ma näid sile tuhade fali pide korra. Ei ole, sest nad on ikkagi inuks ja vaatas, nad on kõik eralda protsessi. Kui ma olen sada konteinerid, siis on pärast sada protsessi. Kui ma olen üks protsess, kas ta konteineris ees väljas või vahet, kui ma olen sada protsessi, kas nad on iga üks erinealtes konteinerides või mitte ka ajal vahet. Kui on protsess konteineris ees, siis ta ei ole kui tegi tokkari protsess, ta on ikkagi täiesti eraldiseise vinnuksi protsessi. Ja see ei väga muuta, aga pigem, see on midagi sellist nende unustatud, et see ümber konfigureerida, et teab Linux serveri tasanel konfigureerina ümber, et mis on see maksimum serveri limit ja mis on individuaalselt protsessi limit, et neid saab lihtsalt ümber konfigureerida, aha teatud olupõrast pilves võib see olla nad kui nendik teerikõttude nendik nano funksioone, serverlask funksioone kasutada, et siis teile ei kruugi olla Linux konfiguratsiooni ligi pääs, et see ei ole asjutsu muuta, aga sellistel juhtutel väga ma ei näe, mikrobeno või nanobenosed või funksiooni teaksid liiga palju file lahkto hoidmat, pigem need on sellised logi haltussusteemid, mis logi file töötlevad, või siis mingiselt annebasi näiteks, in-genie, in-genie, influx või kestiviir, mis hoiavad hästi palju partitsioone ja nad võivad teha toodult palju väikse file, et nad võivad annebasi aga tästipalju väikestis file, et see on sealt pigem tekega tegega tegega progene. Aga võikli juhtud, et näiteks, te paeta kuberneetises serverlase mingiselt annebasi, see kasutab peepfile pidemed ära ja siis mikrobenosed enam ei jookse, kuna ei aina ole terrori, et neil ei õnnehtu file lahki teha, et file te leviid, on täits, file pidemed leviid. Aga tihtisid asad lihtsalt ära konfigureereid ja tähist lubada kaks miljonid file pidemed, 100 000 aga. Otseselt nagu, neid tiirangud on suhtseb väikse, aga natuke epaväelikud, et tegelt, minuks on pakka ma palju rohkemata pidemed, mis konfiguratsioonitasanud, et sa arra pidatud. Ma asad ikka end. Teinaasimis probleemi tekib, et nihti on logifileid, docker. Pidemete, panete protsessi tööle väljas poolt dockerid. Pidemete, see on nginx või plus. Ja tööb logit teist palju. Seeles te tegi mitte mingi probleemi, sest on standard output, ei lähe kirja klas loki ja kõik mul korras. Panete konteele, tokkere, samas ja tööle. Koljaväeva on pärast ketas täis ja sest teeme jooks. See pahe on selles, et dockeri konteeleis väljas poolt keegi ei salvesta standard output. Aga dockeri konteeleis ees, kui nad taad juoksete dockeri lookskesk, kus see docker teab salvestama kõik väljandid poolti pälja. Ja docker salvestab seda kuskile dockeri kausta, konteele kausta tegaks nagu logfile, ja see logfile võib olla viskelt igavõiti suur. Kui te printite välja igas, siis tuleb pärinku kohta midagi. Näiteks nxerix teeb seda tihti, et igas siis tuleb rest pärinku, ja halutate ka pärinku kohta teed logifile. Ja kui sisse tuleb 200 miljonist pärinkud, siis sa on 200 miljonid omi reda ja ketas või täis. Selle vastu vaitab see, et kui te näiteks panete dockeri kausta mingisel teise virtuaalmasina virtuaalse fiskipeale, nii et ta on näiteks limiteeritud 40 gigabaiti võib docker sinna kirjutuda. Ja kui seda hänsi kirjutudakse, siis ei juurdu midagi dockerist väljas pole, virtuaalmasine ei ise jookse kokku. Kuigi docker ei protseisist kõik kokku jõusta. See kui ei ole otsedada sama aegas, aga see on kui taga üks näidieselestus. Nii, et limiid, mis on linuksist asjame konfigureedit, võib probleem, mis on jukka. Ajutisid eeemuse koopajad täiks kasutab ühe kortsalt, et võimaludada sellist ästi kiireks käilitamist, et suuradudas kaneerimise võimalusi ja et oleks võimalik nagu praatsialiselt välja lülitada, et kui teie püüta protses püüab kinni shut down käsu, signali, kill signaali, see on väga hea, et see on väga hea, sest te saate näiteks connectionid kinni panna, te saate mingisubist arvutused lõpuni teha ja praatsialiselt väljuda, et aati on hea tava praatsialiselt väljuda mikro teenuksest, sest eriti kui pärnetele, see võib suvalise laav kui pärnetele, see ei konteinalise kinni panna. Näiteks skaleerimise jaoks näiteks kasutaja konfigureeris ümber midagi konfiguratsioone failis, kui pärnetele sitab delig port ja siis palaks uutport. Tokkeris hoidakse ja teha restart, et teeme protses, mis jooksab panteria sees restarti ja ta reaasult ei lähe, ta ei ole täiesti kinni, aga ikkagi see restart ka tähendab, et killisemitaali saadnud. Parem on, kui teenuste on võimalised nagu kratisiliselt sestkuma, et püüad isegi kiliseknaali, tead teatud tegeluksed ära, et kõik kõus koneksioid kinni panna või ningid fileid ja kirjutamist ära teha, fileid ja buffer ära flashida, et midagi mällu jääks jooksime saajal. Aga põhjemist üks asi, mille ei tohiks olati üllatud, on see, et kui pärnetele saad suvalise teenusega, see on alnud ka siin poodi ära kutsutada suvalise väg. Seda saab teatud viisil kaitsa, aga see ei ole väga lihtne. Kõige niitsa mongi, kui tarp koreisja piiab selle, et killisid naadi kinni ja väljukratisid suhtse pühitsaaja jooksul ja lisab ootab seda, et teegi võtada suvalise aalpoori kinnikonna. Areandustestings ja tootmist keskkonna võib sooida saarnasena. Võimalikult vähe teha peinoloomilise erinevad valikud nende keskkondid mahal ja täiteks oma alvut, mis ma saan üles mingi SQL-lady test keskkonnast, saadest ja end, ma ees kõlli ja panen production keskkonna postres, jah, sellist asja teiks vältida. Konteineride kasutusevõt aitat keskkondis arvases hoidas, veel ei ole vaja postres installeerides, ta käima soidama saame ajutsed panna postres konteinerib oma süleharpest tööle testimise ajal või areandust ajal, ja pärast mis teha kustutada või seisuma panna. Et suhtel lihtne on nüüd konteinerid ajal tätsalt sama tarkvara ülesseada oma läpakas, mis üksküld mis production keskkonnas. Alati on mingisõmuse, et lividid sellele, et kui töösti tarkvara vajab toutu palju mälu, no ei te peud siis võib-olla väga nii vägas, aga keha ei saa eritimid masinuva mudelide puhul, aga eeldusel me saame samu konteinerid oma alvut välja oxtada, siis ei ole väga raske näid keskkondis arvases hoida. Sest muidub ta palatin atukene erineval testima, erineval taarendama, et kui me peame, kui me testimiskeskkoneese tootmiskeskkoneese on erineva tarkvara, kes siis testib, et kui testid juba keskkoneese, ära testiselti tarkvara toetab ka tootmiskeskkoneese, kui ne võib-olla täpselt samad, siis mis mõtle selle testimiskeskkoneese mõnesvõttes on. Hea on hoidanud, et delta võimalikult väikse, et oleks võimalikult vähe erinevasi arendustest ja tootmiskeskkondida pahel. Aga siis poeks veel parem, kui üle toles sama keskkond. Et veel mängu saavaks võtta selle arendustestimise ja lihtsalt jääb jaheva kordja onki tootmiskeskkond. No mõnikud sa tahaksid ikkagi vältida, et sul testimisaal, ennest jõudustestimisaal ülekoormataks on nagi päris keskkond. See on tootmiskeskkond sama, aga sa ei kasuta, enam mul ongi sama keskkonna taga, mulle on koopiasest keskkond. See on selle mõtte, et väikse olema nii võimalikult lähedselt koop, et kui võimalikult. Ja tänapäeva see tocker ja kuperetsing ongi päris hea teha, et samat kontenet jooksutada. Teatud olukordes on probleeme, et tootmiskeskkond on linuks ja arendustest on mäkk arvuti M3 või M2 prozessoriga ja nüüd enam väga probleeme ei ole, aga kui uued läb Apple, Arma arvud välja tulid siis väga paljudel tudenkitel ja ka väljaspele ülikooli oli probleemid, et enam tocker konteneet ei jooksut näiteks, et kõik jooksid kokku. Päris seda võiti rohkem arvesse seda, hakkati tegitama seda, et kui te paate midagi üles tocker haabi, siis teaks BildMitmall-arhitektuurile nii arviida, kui aende 64-le ja siis varmist, kui Arm arhitektuurist tocker imits alla tõmataks, sest oma armbersioon ei proovita alla tõmat enam linuksversioon. Meil oli tudenkitest pigi pikk asju ümber ehitama, et võitsid kogu selle tockerfailide sõltuvased ja iga layer ehitse ümber ise käsid siin Armu peale, et saasi tööle palju, et tekis päris tali probleeme. Aga tänapäeval see on, see arhitektuur on vähendähtis, kuna nüüd on väga lihtne nagu tockerhaabi pannas asjad ehitada lihtme arhitektuurile. Et see on lihtsalt lihtsa tockerpiltkäsule ja tockerpushkäsule, et see registasse saab panna. Ja tead, et olukortus on võimeks ja vist automatiseeride ka, et automaatsal heitab kõigitev platformi ja ots. Mida see soovit? Logimina, ma sellest juba aastaka rääkisin, aga logimina on hästi tähtis sellet öötu, et kui meil on mikroteenuse, et võib olla 16 koopjat näbjast konteineridest iga üks logid. Ja kui teie nüüd peate üle, et sootsima, et kus tekis viga, aga teile saadab suporgi kaudu, et ma nägin sellist erole, et saadab sellist screenshoti ja te näete, mis ekraanis oli veegi nii, sest aga täpselt, mis mikrotenuse viga tekis, on tihti rast arvutada, kui te kasutad ästi holistiku tracemist, kus tracemene teile ütleb konkreets, et mis mikrotenuse viga tekis. Et ilma sellise tracemiselt on väga keerune tegelikult. Et siis on tähtis, et logid, mida iga mikrotenus loov, et neid töödendaks, aga suust, et keerul ikkagi inimesel minna, kui konteinerid logid läbi vaadata. Et on tähtis, et neid logianne tegelikult kogutaks ningite, see keskis, kes on logihalduses justeemidesse, näiteks, logi kuberneeteses, mis siis on võimane, kogu konteineridesse, ta oogu maasalt koguma logik kokku ja näid ratupene ümber töötama, niimoodi, et oleks päringultega otsitav ja näiteks, kas võib graafikult eroritest, et mis hetke näid erorit tekivad. Ja et oleks võimalik ühest kohast kõikki logisid näha, et saaksid näiteks ajaajärgi otsida, ei pea enam liikuma konteineride vahel ringi konteineridesse sisse, minema, et logisid vaadata või tocker loogs keske, et kasutama iga mikrotenuse peal. Eriti, kui mikrotenustest on palju replikaid, et kuuti pettetel on 50 replikaid, mis te käeks tuurimad, mis sugu se teenususeesse iga on. Aga see on logi, et logid mainud riga asjad, et siin näib nii kui iga päringult logiks, see logi või saab täigi. Jah, et tichti on parem infalt mitte logida, kui selle asjad otsad vahel rast ei ole, võib-olla ei taidat vestkestkonnades, või roteelist, või production-kestkonnades, sest ta muidub kirjutab kõik täis. Aga teatud oluvu kordades, eriti nagu sisse tuleb päringult puhul, võib sa olla oluline, et logida päringult, et aru saada näib, et see, et kui tekes viga, mis reasad olis ja sisse tuleb Jason-lid. Et kui sellist asja ei ole, siis mõnigult tekib see probleem, et mina isa ole näiteks sellist asja sisse lüüta paju. Kui ma tean, et logides näen vigasid, mis tulevad mingis teenusesse hapisse, ma talan teada, mis oli Jason, mis selle vea tekitase, ma pean sisse lüüta mesele. Aga kui ma kõik Jason-lid logides, siis oleks toesti justeeme ajaks lihtsalt maha, et kui ma proovin nagu salvestada kõik, siis olevad Jason-lid, et kui päevast tuleb millioneid ja millioneid on fekste, et saadatakse reasad, siis ei ole võimalik kõik asi logida. Info on veel vähem, kui näiteks reasad sisendite logimine, ka info puhul lihtsalt sa ei taha niipole anmed salapugu, sul ei ole paljast teada, et pigem jaheant erade ja kibaat või mording mesudid logida. Aga sa oled kui viga, et sa oled siis logida kõik selle vea päringu, kui sa oled tegineks kõik? Ja see ongi keerulne, sest sul on vea päring tulad näiteks. Kuna sa saad teada, et oli viga, et see viga on ühes mikro teenuses, sul oli see anmed, võib-al kui läbi teiste mikro teenuste, sul oli võib-al mindipäring, kui sa pääregistusse kristiitse ära teg, ja kudas sa teed seda nagu mitte ühe mikro teenuse see, et seda on kõikida mikro teenuste raamdi ja selleks kasutad kõik tracemistid. Sa saad põhimõttelselt proovid ikkagi logida kõike midagi sisedunud päringuid ja kohta, aga lisaks selle, et sa logid kõik infomessagid, sa paned nendesse logidesse ka kasutaja päringuid, et mida et mida kaatri, ID-aid juurde. Ja siis kui kasutaja ütleb sul, et sul tegis eror või sa ise näed logidest erorid, ja sa näed, et see eror on näiteks seotud mingisugude kasutapäringu 1,766, siis sa saad minna keskendse logihalduseks tööriistaja, üelda et anna mulle kõik logid, mis on seotad sellega kasutapäringuid. Ja see võimalutab sa teha täpselt seda, mida ta tahad, et otsida, et mis juhtus kõikides mikro teenastas, mis oli seeotud sellega kasutapäringuga, ja sellise liul sa näed täpselt, et näiteks kahuada mingis järjekarvas oli, kahuada ootas mingi registrivastust ole, mis oli registrivastus, eriti, kui sa isegi aata jatione tovima. Aga see tegelikult vajab tolutad palju rohkem, nagu kettaruume, et kõikime tohvi saadata, et tihti seda ei tehta, kuna sa läheb niiga kallikselt kõikki nagu päringu asju logida. Aga mõnesmaks on ka see hea, et kui sa iseseda erorite ja märka, aga kasutajutab sulle, et midagi töötab hästi selle päringuke, ja sa küsite ma käest, et mis on see päringu idee, ja siis sa anad selle päringu idee siia logidalt tööristale ja ütleb, et näite pole peki annaid, mis on logides selle päringu pohta. Sa aidab sul tippakida sellised olukönti ka, kui sul otsast erorist logides ei ole, aga kasutajupalt tuleb nagu mingisugust tagasidug, midagi töötada, et ta ei õnnesta näite, et ostamidagi ja sinu sisteemise erorid ei ole. Et kui sa erorid tähed, siis tõblast on lihtsane. Siis ei oleks kui ma olin lihtsalt niigi piiru taelnobid, et neidas ongelnobid 24 tundi ja siis kõik vanen logid kustata vära. Ülgivult see on, et siis ei teed, et sa logid halbast tööristad, et sa mingisuguse perioodi sall defineerid. Prometheus on see läheb, et siis kaks nädalat automaatselt, et Prometheus alvestab kaks nädalat annaid. Et seda sa taad prongi suureerida näid. Kust lõmpad, et sa näid salast, et sa ei saa. Ja lähme edasi viimane. Muidume jooksema ajast suhtselt vara juba läbi, aga ma saan ka need teemat lõpastada jäänekõnekord. Viimane on siis haltustprotsesid. Kui teile Annepaasi, ütlele, et teil on Annepaasi poskas konteehner ja Annepaasi midagi katki läheb, mida te teete? No, installi Annepaasi. Et ütleb Annepaasi teile töötab, kui sa aga kõige selgale sõneks et ole tokke konteehnerina, ja midagi Annepaasi läks kaip, mida te teete ära? No, palju suurst teelt. Jah, kui sa taaks läheb teada, mis kaip läks või sa taaks näiteks kind olukorda tarakata, näiteks Annepaasi struktuuris on midagi vältvi ja pärgit enam ei tööta, kuna keegi kursutas midagi esiteisest taberist ära. No, siis tost sellel töötavall oma teha. Aga kui sul töötab nagu backup on nii ka vanale, et sa taaks käe maha. No, sa enne muudatust ja midagi põleks kõnev? Aga kui sa jah. Või ütleb, et teile on näiteks kimpisugun seine, et sinflaks on midagi vältvi, et mis te teete taad? Tänna valju mina läheks konteeris sisse, et keskjaoksutamalt vaadata, et kasutab oskres kesku, et vaadata, mis Anna valdi see, või aga rabelide nii eda. Kesks kõitele, et on jääb kui jääb kõist vahe. Jah, aga see on väga speciaalne. Minu mõte oli see, et te saate rauhusina keskkonda sisse minga ja jah, et te keskjaoksutamalt. Ja miks ma saan oskres annebaas? Sisse minga on selled, et ota oskres konteele ka kaasasse käs, mis sa põlmust oskresi annebaasi ikk. Et ma olen käsuriga käs, kes sa on toka konteele see, millega ma olen võimalik oskres annebaasi sisse vaabida ilmat, millega ma jääks importelahtega näida. Ja see on viimase mõte ongel, mingesud haldus, koksasid, mis on teil vajalikult halduseks, olnud see annebaas, olnud see mingisuguna file stories või teie enda kuita programm. Et selleks, et te saaksid uurida, mis on toiminud live systeemis, jookslas running systeemis, on võimalik lihtsalt konteele sisse mingna linnud keskjaoksutada. Ja tihk, et on näite tarp väraga kaasas mingisugust haldustarpe väraga, nagu poskresi puhul poskresi klient. Ja klienti tarp väraga, et ei ole ainult instaleeritud poskresi serveri tarp väraga, vaid aga mõelik selle peale, et administratore tahaks minna, lokaasad sisse logida ja vaadad annebaas ringi. Ilma, et peaks midagi juurde instaleerida, millite inuks pakete juurde instaleerima, mingis portelahti tegema, et oleks võimaliga ästi kiiresti minimaalse vivitusega minna ja vaadata ringi akatandivaal administratore keski jordetama. Et siis selle best practice mõtani, et hoida need haldustprogrammi koos selle keskkonnaga, mida jooksutatakse produksionsistemis, et administratore te looks võimalikult kiiresti võimalikult mingis haldustoimingud. Kas või see, et te tahate ise annebaasi back upi teha, et saate exekiga tokke konteeerise sisse minna, jooksutatakse poskresi käsu selleks, et nagu poskresi annebaast teha mingis snapshoti, siis paljina salvest peaa konteeerist välja ote kopiga või otsa konteeeril välja salvest peaa. Aga see ei ole siis see halb praktika, et hakkab esel kohteinele seismudev muutuma? See on halb praktika siis, kui sa soovit tema seismuta, aga kui sa soovit ainult dibagginida või aru saada, et kis on valesti. Ja kui sul on väga kiiresti back up ära teha, kuna sa tead, et tunne ääbrus läheb elektromahalega ja sellist. Kui sul on midagi väga üllatustliku, et sul oleks võimalik seda kiiresti ära teha, aga tõesti kõikis sellist tegevusi, mida sa ette puutud, peaks olla palju parem automatiseerida. Oltomatiseerida oleks parem praktika, kui käsit sa administreerime. Aga selle best practice mõtlen, et hallut protssel seda vaelik, et vaelik tarkvara ko kaasa panna nende keskkondudega. Ja tänapäele sa on mõneslõttu sisse eidud tokkeris ja kui pea näete, sest see on võimalik väga lihtsalt sisse minna ja käske jookstuda. Ja nad ei ole nagu ära peidetud või, et sa vestimist. Näädiks see, et piikida konteneeritaga panast ka su shell, et sa saad shell käske konteneerisees, et ta on sisse ehitatud tavad. Teoreetist, et sa saad selle keelat ära konteneeritapuul, et sul ei oleks shell sellimade kaasav, et shell ei jooksta selle konteneerisees. Ma olen näinneid olukordi, kus ei saa shell jooksta kõrte konteneerise. Kui päris, et selle konteneerite puul, annepaiseid puul, sa võib ka ketta kingikonna, et ei ole lubatud. Ei ole ühtegi riid, ei ole ühtegi fail, kihki, et kõik kiidab riid ombi, et ei ole kui lubatud, nagu sa seal midagi muht. See saab isegi selle annepaise puul täiesti kinnipannud. Administraatorele ei ole lubatud minna ja seal paljama. Ja ka processiise annu, ja processiise ka ei ole, tema ka ei saa paljama juha poimuse. See on ainult riid ombi. Seda ta hakkab jaa. Ma nüüd atuke mõtlen, sest meil on aegas uhtsalt vähe, kuna ma arutasime. Ma korraks mõtlen, mida me järgmasena räägime. Ma võib-kohle jätaksele service mesh ja sidecar patterni järgmase loonvõs algusesse ja räägiks üle mõned sellised pilved eelused, mis tihti on vaelikud nende täiesti pilvepohiste rakkelust jaoks. Kus service meshe ja sidecar pattern ja muud service meshi asjad jääbaks järgmase loonvõsse aine kokkuvõttesse. See on kelle selline teema, mis võib-olo pakkas ongi natuke liiga vara mõnes mõttes, kuna me selles ajan sisekuberneetist ei ole kaks otsaegu pakkikumise. Teised teemat, millest me räägime, me vaatame natuke annepohese. Vaatame hästi kiiresti üle, ta näeme, et TNS ei pilves ja CDNi, aga CDNi nagu otsaegi väga ei vaata, kui tegab vaatame, kuidas Google seda teab. Esimese räägimegi sellest annepohesid mustrist, mis on natuke imelik muster, sellest arusada, miks ta kasulik on, on sihti tegelikult natuke keerulline ja häid, päris elulise näiteid ka, sihti väga ei ole, aga selle CQRS või Command and Query Responsibility Segregation idee on, et eraldada kirjutavispäringud või lukemispäringud. Seda saad teha mitmel tasemel, et me saame teha sellel tasemel, et me paneme eraldu serverid, mis serveerid ainult kirjutavispäringud, ja me paneme eraldu serverid, mis serveerid viivad ainult lukemispäringud, aga võib ka teha loohike tasemel, et näiteks me lupeleme rakkeendustel teha annepohese päringud ja kõik muud päringud peale select päringud teha ne keelam ära, et täidis apte või in set päringud ei luba teha SQL-iga. Et luba ma ainult nagu pärit anmed, et lukega anmed SQL-iga, aga keelam ära kirjutamise SQL-iga, kirjutamiseks implementeerime eraldi fixeeritud metodid ja eraldi tartvara, et anned oleks kui muud misse toimigudele oleks täiesti eraldavud, kui anned lugemise toimigudele. Me lugemise luba ma siis täiesti dünameelisid päringud, et mis igajast kudas kavutavad sooviat joinida või kruppida luba me, aga samal ajal me luba kirjutamist ja me kontrollime palju rangemalt kirjutamist, et mis järekarasse toimub, et näiteks, mis serverite kavudust toimub ja võib-olla implementeerim ka metodid, et kasutaja ei saa SQL-iga ükskõik, mis anmed või tabellid muutavad on teatud fixeeritud metodid, mis isesel ära internetereed. Teine viis kudasest veha, et me jagameki kirjutamise ja lugemist toimigud erinealtest sõmmedamaal ära ja me vaatame kuna see Postgresi puhul töötab, et panaks üles Postgresi klaspreet, et anmed muutateks ainult ühes serveris ja see parandatabus järjestidavust ei ole võimalik, samu on meid trollide kahes serveri, sama aegselt ülehidutada ja ei ole enam vaja kirjutamist sõimmeda vahel reaal ajasikroniteerimist teha, mida on vaja ainult nüüd teha on paustavar replitseerimist, et kõik anmed kirjutamiserverise panaks liikutatakse piisavalt kiiresti kõikidesse teistesse ja serveritesse lugemine toimuksest suhtelmised kiiresti paljab muudata. Meil on ka võimalik teist eralsed annebasiid, meil on kaks annebasi üks, mis tegelab kirjutamisega, tegelab lukemisega, teha väga lihti ei kasutata, aga võidakse kasutata olukorrastus ta, kus on vaja ästi võimsaat kirjutamist, et oleks tohletult palju anneid ole paraleliselt kirjutada, aga lugemiseaks pigem kasutavaks raporteerimisi, mingisummised dashboardi loomisi, siis kasutab ühtepäeva, et anmedbasi ästi iskaleerid, et anmedbasi anmed kirjutamiseks, ja krančitaks anmed, ja teaks sellised anmed kopeerilisi ja hiljajan genereritisse raporteid kirjutud anmed põhjelva ja anmed te tõetust toimub kusagil, taustav mindite, tiktate anmed tõetust, aga lihtstabil, ei toimu reaal ajas, ei toimud näites ükskord ööpävas, et on võimalik niimoodi jagada. Ma avatam, et see järgine on, et siin on üks näite, et meil on täpselt üksisama anmedbasi, et ta ei ole te koommaks näite, kui meil on kaks eralte anmedbasi või pigemse esimene näite, ja meil on eraldisebised mikrotenusev või tenusev, mis jooksatavad käskemis anmed muudavad ja teised, mis teavad, et käsut SQL päringutüült kätte saadavaks, mitte käsut võided anmed, et meil on eraldi teedusebneid, kui meid on teeduseb asjad, et millega oltasab saada anmenda muudmisekästu ja eraldis, millega oltasab saada SQL päringutüült tammelt pärida. Et kui te soovite lukeida selle kohtes, on Martin Pauleri koduläele, on selle kohte kirjutatud, ta on päris palju huvitavad arktikleid hajussisteemide koht. Mis tänavahel tikkem kasutab, et see on see teine lähene mine, et teha SQL klastri, kus saavaks hästi heaad lukemisjõudlust, siis saame enitada sellise Postgres klastri, kus meil on siin 4 nodeid, nad on kuberneettisest Google Cloudis ülesseadud, meil on 4 primary, ja siis 4.1 standby, 4.2 standby, ja meil on lisad 4-dir on samas serverist, ja samas koalast ka selle replication manager, kelle üle saame on, et kui siia primarist on kirjutud tammelt ja muudadud see midagi, et kõik teha muudadud saab ska synchroniseerida, siis teistavse standby serverisse. Likte ei tee, et me peabest katsutada seda, aga kui sees seera kokku jaoks, et me saame katsutada seda ja seda, aga kui meie jaoks ei ole tähtis, et anned oleks ideaalselt reaal ajas synchroniseeritud, siis me saame tegelikult teha niimoodi, me tekitame kaks teenuusid, kui kuberneettisest, üks teenuus, mis on kirjutamise teenuus, üks teenuus, mis on lukemise teenuus, kirjutamise teenuus suuna taalt kui siia poodi, aga lukemise teenuus, kui sinna saada päringudis, aga kaks selle, selle ja selle poodi pael sisse tulad päringud äna. Et senneks, et töötaks kasutavaks sellist asja nagu TG pool või Postgres pool, nagu sellist annete, kui sa oda ümbersuunad või päringutaja autorit, kes ise otsustab, kuidas ja milisest see teenuus see päringud edasi tulad. Aga ta on selline korvusi autoris arvanu komponent, mis otsustab, et kuhu, nagu Postgres sii päringud edasi saada milisest see noodidisse ja kliendid kasutavad selle TG pool servisid, et Anne paasid lasti kõhendust, kui nad ei teagi selleks, kes on ride ja midu read replikate mitte. Ja siis TG pool siis, et kui tuleb, nagu S-päring, kes proovad Anne ka ennud lugega, siis ta saadaaks selleks, kuba teed, et sa teenustas, mis suunab siia-sia või siia edasi, aga kui sa päringud kirjutamist, siis saadaks suuna selleks, kuba teed, et sa teenustas, mis suunab aina siia-sia. Eest on siis üks viistkudes skaleeride Postgres siin imod, et ei pea siselmisel TG shardima, ei pea väga keerulist replikateerimist tegema, aga võimalik hästi hea lugemis jõudus saavutada, kui ei ole vaja, nagu võib-olla reaalast karatiid, et kui siia midagi kirjutatud, siis kolmas server, et see ei vastaks stail või natukamaana tannetega. Ja kõik Anne-pallise Anne poikakse siis persistav monumis ja saadastatakse kas kettale võrgukettale niimoodi, et seda pood on tubatud ära kustutuda. Kui see pood kustub, siis ta enne päringu töötamist alati kirutab nagu Praetahedlogi, siis see tulevad päringed enne kui tähed töötamakad, niimoodi, et kui ta ära tatad, seda uuest üleserb, seda vaatab logist, et mis oli kooperatsioonid, mis hetkel oli käimas ja enned uuest läbi. Ja see on talas, et siis ehtedud kõikides pilve põhiste Anne-baaside, tarpvärase, et sellist Praetahedlogid, olguned siis näedis Kafka, Sõnumitehaltur või Anne-baasid, et tihti tehaks juba seda, et ma saan päringu, kui jõutan enne sile kettale, nii allest sisakansa töötama. Või ma proovin seda paraleliselt poimse teha, aga tähtisane, et alati logi olks olemas, et mis oli see operatsioon, midama hetkel täida, või mis operatsioon on täikis järjekorras. Kui totsas ära tatad, et seda oleks lõimendada uuesti logi vaatama, et mis oli täikis, mis veel ei ole tehtud. Mis võib-al on problem, siis kui, mida kooperatioonis väga hästi ei ole, et mis jõutub siis, kui siin hakkab, et see tegema snapshoote ja backhafte või veel hullene backhafte, et mis siis jõutub, kui keegi proovib selle procesi ära tappa või poodi ära tappa, et seda on tullu aske nagu kuperneeteses kaitsta ilma eraldi komponentina, aga selleks on kuperneetes olemas kuperneetes operatoris. Kui te oled meist huvides, siis võite lugeva näiteks kuperneetes Postgres operaatori kohta CloudNativePG näiteks, et CloudNative Postgres tema tuodab operaatorit. Operaator on selleks komponent väljas pool, teid mikrotenuseid, kes võtab üle kuperneeteselt Postgres plastrite halluse, niimoodi, kuperneetes ei kustuta otsa poodi ära või saada pärin, kui meie operaatoreid kustuta pood ära, ja siis meie operaator on vastutav sellest, et kuidas see kuna pood, ja kustud võtab teatud funktionaaliselt kuperneeteselt üle, et hallab ta selleks, et kastamressusse nagu Postgres plastrite, et kui tead selleks kubik, et saada lugeks seda kohta. Aga Postgres iga palju rastgen proovid ja implementeerid seda, et meil on reaalselt write replitseerimene või et meil on mitu write nodeid, et pigem tehaks see midagi sellist, et meil onki üks write node ja ülepeeg teised on read nodeid, ja see listustab tohutult tegelikult selle hajussustemi anmebasiehiitamist. Ja me taame võib-olla lihtsalt karanteerid, et siia on kõik pilutud, et see on võimalikult kiiresti, et anmed synchroniseerikse. Siin, et see replication manager onki see takvara, kes siis politseb sellest, et anmed oleks hästi kiiresti synchroniseeridud nendama. Aga põhjelisted nendest paelidest, mis siin on, on enam vähem kooki, et mida reaal aja soib, et see süngik, et nad ei sisalda erineva tanne, et väljarutas kõige uuema tanne. Ma võib-olla see root 53 väga palju ei räägi, selle ei tea, et see on pilve sisemine DNS, et see võimalatab reaal ajas kirjutada üle, kuidas anmed suunateks sa DNSi tasean, et kui teile on mingi mikro-teanuse nimi pilves, mitte näha kuperneetises, vaid teie klientid ühenduvad selle adrese, mitte appi-adrese, mikro-teanuse adrese üle, et kuhu virtual machine-outesse, mis regionidesse anmed suunateks, et kui teie tahaks seda suunata näiteks, Saksaamal oleks klientid Saksamaa, Soomeks oleks klientid Sooma-Anne keskusesse, kuidas te seda teete. Pilves ongi järalti nagu TNS-teenuse, kus te saate seda konfigureerida, kuna suunatakse ümber, siis sisse tulevad päringud, ja kuna DNSid tegelete sellega, et mis siitke vastab, mis osneile, siis sellise pilve-TNSi taseame saab seda suhtselt kunaamise teha, kuna pilveväliselt DNSid, mingis teeneeti-TNS, ülikool-TNS, Eestisasol teised TNSi serverid või Google TNSid, nad on susta aga, et neie real ajal see on väga jõunest, vahe asju ümber muuta, seal on suuret käsid vahel, serverid, ruutereid käsivad neid asju ja et mitte ülekoormata neid, et kus Google TNSi, et iga sisse tulevad päringud peal teha uuestisevik TNS-päring läbi, see tapaks globaalse Google TNS-heikse arangil, kuna on väga palju käsimistakasutus, siis kiiressi meie asju teha ei saa. Aga pilve TNS-teenuseks võimaldovad ülejät kirutada need reeglid, et kui tuleb mingile hostneemile päring, siis kuhu IP-aadresel saata ja see võimalda siis ümbersuunata sissevavad päring. See võimalda ka nagu lantentsust halata, et kui lantentsus mingis serveris mingis agioonis on liikav madal, siis sa hakkab TNSid asemel tegelikult ümbersuunata liiklust, et see teoreetselt on võimalik, et ima kui ka päringed teha suutimist rea läheb teha kui mingit serveri enam ja aasta. Sisu edastamise mõõrgustikud, kas te jääta, mis nad on? Vahe hässi, aga siis nagu mingit on mõtumata tonnet jaoks. Jah, et saa poodi nagu me Asure, seda on võimest, et Asure static filesi kasutasin, et ma panan üles mingi HTML-fileid ja JavaScript-fileid, aga seda tigki kasutadoks ka piltid ja videofileideks, et selle aseme, et teie Flask rakendus-serveri piltifile ja saate need piltifileid vallalised pilve, et S3 Asure file löidesse ja siis suunate ümber kasutaja mitte enda rakenduse peale piltialatamata vai pilve piltialatamata. Neid oma HTML-i panate pilgilingid S3-est, omas on S3-est või Asure filesystemist, et te panadete täitsa Asure linkid sinna ja siis neid pilt enam ei pea alatõmbama teie virtuaalmasinast, et teie ei pea enam piltid alatõmbamise, otsena serverima neid, teie targvara ei pea vahendama neid piltid, teie virtuaalmasine ei pea kaile vahendama, et teie virtuaalmasinana vähem tööd, et teid piltid tõmadakse pigemagu globaalse kihist alla. Ja mis on näende elis, on veel see, et globaalsed siin on edastamise võrgustikult, nad saavad, aga anmeid lasted kasutatelt tõmad alla kõige lähemal asuvast anmekeskuses, et neid isekasutad kaasada TNS kihsti, et optimeerida kuhu üheneda kasutaja, kui teed pärin kui mingi pilgi peal ja vastavad selle, et kus tuleb kasutada pärin, saad nagu ümpeal suurate kasutajad kõige lähemal asuvasse serverisse. Ja üks kõigi suuremaid võrg, kes seda kasutab, onki Google Edge Network või Google Air võrg, mis pealised teedat juub tubi jaoks piltide kasjimiseks, mitte piltide vaid videode kasjimiseks, sest YouTube video kasutus on nii suuret maailma internet, mis saate ei elaksada üle, kui kõik peab tulema otsa Google Amna keskuskustest. Ja Google samas ei taha jälle anda lokaasatele IP- ja internetiteenus pakkujatele luba, et need videodid kasjida. Nääli steli jaale ei ole enda luba otsustada, kuna kasjida YouTube videod, kuna alab jõmaga. Sest seal on teatud tähtsad otsustad, mida Google tähtsad tead tegema näiteks. Kui Euroopa Komisio nõuab, et mida video maha võites või tuleb mingisugune TN-100A strike, et tuleb video maha võtta, siis Google tahab, et tal oleks võimalustada koha maha võtta, võite, et see oleks käsitud kolm teist tundi kuskil telia serverides. Aga kasi, kas Google saab seda nõuda telias, et nemad nii käsiks seda? Kui sa oled telijat, siis sa tead tema vabaselt esitev või mitte? Nad saavad ja nad tead lepingud selle jaoks. Nad võib-olla ei saa keelata seda, aga kui sa oled telija, siia sa tahad käsida, et sinu internetüüendus Google'iga oleks. Ja telial oleks motivatsiooni rohkem käsida, et vähem internetüüendus oleks vaja üle globaalse interneti kasutada, mis nende jääb laht kaelliks maksama. Põhimest, et Google tead lepingu kõige nende. Ja põhimõtteliselt ma ei tea täpselt, kas nad on võimaliselt, kas ta kudagi reaaselt ka füüsilist või tehnilist keelama, aga põhimest, et selle asemel, et lubada neid käsida, nad põhimest keelavad selle ja siis tead nende ka lepingu, et kuidas see käsimine põhme. Aga käsimine toimub. Ja et käsimine toimub peli. Ja natuke ongi see, et tänas sellega paari slide ideet visualiseerid, kuidas see toimub. Et Google jaaks on tegelikult hästi tähtis vähendada seda liiklust, mis toimub Googlei anne keskute ja inimesed vahel mis need videost vaatad. Ja Google on ehitant siis globaalsse sellise eesnettvörgi, kus keskel on Googlei anne keskused ja Googlei internet. Kes, et siin järgmises kiis on Googlei internet ja välis interneti vaheliselt sellised väiksead anne keskused või stationid. Et see siin Googlei routereid ja anne keskused ja siis kollases alas on partnerid, et näibks Telia ja teised sellised suure partnerid. Ja idee on, et on seda põrku võimalik kasutada siis Content Delivery Networkina, kus võimalikult lähedale tuvaks nagu Anmatt Cashemine Anmatt Delivery. Ja vähele on seda, kui ammed omaat ammat, et võimalikult vahel reaaalat ammet tõmmaks üle interneti Googlei anne keskustes, kui vähegi staativiselt ammed on millega tegu. Googlei anne keskused olid paar aastat tagasi sellised, mida võib-olla juurde pannud, et Suomessa on üks, Euroopassa mitte, Amerikassa paidi juh, Siin on üks, siin on paa. Ja nüüd on kindlasti neid juurdega tundud, et ma unustasin sehastada seda pilt juuandada. Aga see on ikkagi suurselt kaugel inimestest, et on püldus esiteesti sellised tentskonad võib-olla nagu ära kaad. Aga mis Googlei anne? Googlei anne on internet ise eitatud, internet nende anne keskustel vahel ja Googlei anne isegi creeper kaad, mida lähevad üle või all, ofiani alt läbi. Ja Googlei anne on sellised oma anne keskuste vahelise interneti ja välise interneti vahel on sellised ümper lülitumise kohad, kus lülitad ümper. Ja on eradesest väiksemad anne keskused, kus ei ole nagu neid olema pilda anne keskused, need on sellist vahe anne keskused, kus saab samuti Googlei oksata oma tarkvara ja serveerida. Ja need on paegutatud sinna, kus on nagu kül vähem piha asust, kus aga ikkagi väga palju inimete elab ja katab suurem osa Euroopast ja Põhja-Amerikast ära. Aga muja on võib-olla nadk vähem. Aga ikkagi meil on inimestin näiteks suurtes linnades. Eestis ei ole sellist, on tõmest, see on St.Peterburg, see on selline, kus Soomees on sanda keskus. Aga kui Eestist videoid, Googlei videoid vaatakse, siis ikkagi oleks parem, kus see käsinne toimuks suhtselt lähedal inimestele ja konteltele, liverit toimuks ka suhtselt lähedal kasutadele. Et Google teebi siis lepingud siis teenust pakkujetega. Muha juba üks piltselt puhulub. Kontrollin kiiresti, kas see piltselt on muid tegelikult olemas. Aga kuidas ei näidatud juba mingi esimest tegelikult juhu? Samul jaa millegi pärast ära peidetu. Ma panan on haid sellel, et siis panan suursti linnad. On selline. Ja panan ka zoomista uuesti. Aga ma millegi pärast panin ka zoomist kord kinni. Maan siis selline. Jah, ja Google teeb siis lepingud sellist interjete teenust pakkujetega. See vahe on ikkagi suhtselt hiigel suur. Eelmise slide ja sellest slide vahel. Et see on siis Google Anne keskused. Need on neid Google Switchover stationid. Ja siis need on neid partnerid, peenutpakujad. Kes teebad siis lepingu Googlega. Kuidas see toimub on tegelikult? Põhjumist see näiteks Eestis, kui me sisse zoomime Tallinnas. On näiteks üks teereus pakku ütlema, et sa võiks olla telija. Ja telija teeb Googlega lepingu. Ja pakub väikest ruumi oma Anne keskuses eest. Google toob oma rakid ja servidid kohale. Tühendab telija võrpu. Ja telija suunab YouTube ja Google TNSi päringud läbi selle rakid. Need kuglid on oma mini Anne keskuses telija ruumides. Kus on telija? See on siis kõikid suuremades linnades. Ja isegi väiksemades linnades, kui nad on piisalud kaugele erinevatest Eestis, Anne keskustest. Et see kandab väga suure osa kasutajad ära. Ja peamasest seda kui kasutad see YouTube jaaks. Aga kui Google tahaks näiteks Content Delivery Networki pakku oma pilve jaaks. See on kõik need kohad, kui ta saaks käsida pilte, videosid ja need. Ja idei ongi siis, et Google kontrollib 100%-iliselt, et kuna kasutaks YouTube videosid, kuna on nende tarkoare jaoksad siis ja kõigi ISP-te peale maailmas on nende ka lepikult tehk. Ja täna sellele siis Googleil on võimalik pakkuda sellised siigel Anne mahtu vajalikateenud, nagu YouTube-us tooltub palju videoid vaataks. Ja kui kõik ajaksid üle hitereet ja Anne keskustest oma videosed alla 24 tundi ööd avas, siis see läheks, toobaks interneti põhmes koomast. Aga miks siis obi Googleile see juhud, mida see ongi, siis kui ma aavetaks pooleliselt indivüete saada, aga kui olib siin mängas käsimisele kolm? Siis lüüta saab otsa oksustada, et see käsimise kusutaks hara, et saab see koha välja lüüta näiteks teliaserverite stalinud. Ja mis on pilnud nagu täpsama? No ongi, et miks neid seda või olema, aga miks naks seda soovidoid? Sest näile nagu kohustus näiteks midagi maha võkta, kui tuleb avaldus, et näiteks see vikkub mingisugused, ütame, laulu, autorõigus on pealseli. Aga siis nad võtsid selle maha, et enampähem kui näiteks ongi, nagu näites pakkungi siin arutis ideavaatumust eenust, tuleb palju mingi video, aga tuleb maha võttu, tuleb peal maha, aga minu mõni vaataja tegi sellest ente laujutust koopa, et saaks õppu ei vaatud. Aga siin on kõik minu prodeeni. Aga muidu jääks see teli ja koop erendis alles mingi tiis peteemist pakka kuhu käsjudesse. Kui Google ise seda ei teeks ja laseks käsjida, siis 3. osaportel või nende nendel. Et Googles on kindlasti oma anne keskustas selle maha võtta, aga kui ta ei kontrolli seda, et kuidas käsjutaks see kunanat käsid kustutult, siis ta annab seda kontrolli oma ka seda kõra 3. osaportel. See on pidevselt võtta. Aga kas ongi seda kontrolli neil vaja? See oli lihtsalt üks näite, et see ei kruugi nagu kõige peamine olla. Teamine pohjuus, miks nad saad teha ta oda, on minimaaliseerite, ku palju anmeid on üle interneti vaja saada. Et see anne maht lihtsalt oleks liiga suur muidu. Aga see ei lähega seda, aga see ei ole lihtsalt ISP-käsj. Või malik, aga see ei kruugi. Ma ei tea selle täpselt põhjust, miks ta tehniliselt oleks suurem problem, kui ISP-sad isedevalt. Pigeme, et nad tahad kontrolli oida, nad võib-al tahavad saada mingit tarkvarja ostada, mis paremin oskap seda käsjimist teha. Võib-al see ei ole ainaid käsjid, nii maid ka kui tagi optimeerinud, mis mingisuguse kvaliteetiga näiteks videosid edastat resa kasutajal. Et neil on tarkvarja, mis põhjumatsalt sõpselt sõpselt erosasuttsiooni või mingisuguse pitk reibi vastavad sellel, et mis kasutajal koordioon. Ma täpselt ei tea. Aga saad selle kõrta juhtu lugele, kui see on uidros. Jätame ülejäänud teemat siis pahele, kuna ma arutasime, et pärast seda oli mu servismest tema. Saate siin viltinud ka vaadata, kui ma ühtpan seal lõpu. Oli kõrse tomaduse, millest ma räägin siin järgune nädal. Järgmises praktikumiseks see näda arendam edasi oma mikrotenesta põistrakendust ja teenata täiesti pilvepõiseks. Olge sellega ettevaatlik, ärgele järg, kes seda liiga kauaks jooksma. Aga seekord on nõu, et anna te meile teada, mis on teie webi link oma rakendusele. Põhimiseks, mida teht, saad ka mulle e-mail pärast esitalist ja ma kiiresti vaatun selle webi linki üle, et ta töötab ja sanan tagasi, et võite maha võtta. Võisil ma hinden osaliselt teie laenduse ette ära, et ta töötab ja siis pärast seda ütlel saada maha panna, sest te panete üles konteinerid, te panete oma kaks aapid konteinerid ja kauaks see maksab, et seda ei saada asuta jooksma jätta. Et see kauaks läheb pärast maksmani, et parem on, et pärast esitamist meie kontrollime kiiresti üle, sest te saadu tagasid, et saad ta ma rakenduse maha võtta. Ma võib olla ei hinda teie praktikumilaendust ära, vaid vist sanan peale pead, et see osa teil on korrekke ja siis praktikumil jõuenda vaata kiden teie poodi üle, aga esialgu me lihtsalt anna tagasilt, et teie rakendust saad ka võtta seda maha võtta ja siis paned see hinjate enam kõik viipi kadutama. Ja järgmine loeg siis toimub eksami korralduse loeg, kus ma seletan, kuidas see toimub hakkab ja rääkin ka üle selle näite küsimused ja on selle konsultatsioon, mis teie saada küsimusi küsida ja siis teises osas teeme sellise aine kokkuvõtte, kas räägime, et temad üleminest tähendada ei ole taega ja võtta me kokku sellised eedised ja puudused kõik teemade kohta. Võtta me kokku ja võib-olla mõned teemad peale aega jääb, rääkime nagu üle, aga kuna tänaseks toonadust ei natuke väeg, siis teasalt katame, kui siis mõned teedised ja puudust teeme selle rikmasjile. Aga ongi siis kõik tänaseks, kui küsimusi ei ole ja see praktikum siis on viimale, et järgmine nädal enam praktikum ei toime. Taan!